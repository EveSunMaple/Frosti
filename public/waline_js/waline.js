var Eo = Object.defineProperty; var To = (e, t, n) => t in e ? Eo(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var Os = (e, t, n) => To(e, typeof t != "symbol" ? t + "" : t, n); var Ts; const js = { "Content-Type": "application/json" }, Ye = e => `${e.replace(/\/?$/, "/")}api/`, _t = (e, t = "") => { if (typeof e == "object" && e.errno) throw new TypeError(`${t} failed with ${e.errno}: ${e.errmsg}`); return e }, Tr = ({ serverURL: e, lang: t, paths: n, type: r, signal: s }) => fetch(`${Ye(e)}article?path=${encodeURIComponent(n.join(","))}&type=${encodeURIComponent(r.join(","))}&lang=${t}`, { signal: s }).then(i => i.json()).then(i => _t(i, "Get counter").data), zn = ({ serverURL: e, lang: t, path: n, type: r, action: s }) => fetch(`${Ye(e)}article?lang=${t}`, { method: "POST", headers: js, body: JSON.stringify({ path: n, type: r, action: s }) }).then(i => i.json()).then(i => _t(i, "Update counter").data), zs = ({ serverURL: e, lang: t, path: n, page: r, pageSize: s, sortBy: i, signal: l, token: o }) => { const a = {}; return o && (a.Authorization = `Bearer ${o}`), fetch(`${Ye(e)}comment?path=${encodeURIComponent(n)}&pageSize=${s}&page=${r}&lang=${t}&sortBy=${i}`, { signal: l, headers: a }).then(c => c.json()).then(c => _t(c, "Get comment data").data) }, Fs = ({ serverURL: e, lang: t, token: n, comment: r }) => { const s = { "Content-Type": "application/json" }; return n && (s.Authorization = `Bearer ${n}`), fetch(`${Ye(e)}comment?lang=${t}`, { method: "POST", headers: s, body: JSON.stringify(r) }).then(i => i.json()) }, Ds = ({ serverURL: e, lang: t, token: n, objectId: r }) => fetch(`${Ye(e)}comment/${r}?lang=${t}`, { method: "DELETE", headers: { Authorization: `Bearer ${n}` } }).then(s => s.json()).then(s => _t(s, "Delete comment")), tn = ({ serverURL: e, lang: t, token: n, objectId: r, comment: s }) => fetch(`${Ye(e)}comment/${r}?lang=${t}`, { method: "PUT", headers: { ...js, Authorization: `Bearer ${n}` }, body: JSON.stringify(s) }).then(i => i.json()).then(i => _t(i, "Update comment")), Hs = ({ serverURL: e, lang: t, paths: n, signal: r }) => fetch(`${Ye(e)}comment?type=count&url=${encodeURIComponent(n.join(","))}&lang=${t}`, { signal: r }).then(s => s.json()).then(s => _t(s, "Get comment count").data), Us = ({ lang: e, serverURL: t }) => { const n = (window.innerWidth - 450) / 2, r = (window.innerHeight - 450) / 2, s = window.open(`${t.replace(/\/$/, "")}/ui/login?lng=${encodeURIComponent(e)}`, "_blank", `width=450,height=450,left=${n},top=${r},scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no`); return s == null || s.postMessage({ type: "TOKEN", data: null }, "*"), new Promise(i => { const l = ({ data: o }) => { !o || typeof o != "object" || o.type !== "userInfo" || o.data.token && (s == null || s.close(), window.removeEventListener("message", l), i(o.data)) }; window.addEventListener("message", l) }) }, Ns = ({ serverURL: e, lang: t, paths: n, signal: r }) => Tr({ serverURL: e, lang: t, paths: n, type: ["time"], signal: r }), Vs = e => zn({ ...e, type: "time", action: "inc" }), Bs = ({ serverURL: e, lang: t, count: n, signal: r, token: s }) => { const i = {}; return s && (i.Authorization = `Bearer ${s}`), fetch(`${Ye(e)}comment?type=recent&count=${n}&lang=${t}`, { signal: r, headers: i }).then(l => l.json()) }, Ws = ({ serverURL: e, signal: t, pageSize: n, lang: r }) => fetch(`${Ye(e)}user?pageSize=${n}&lang=${r}`, { signal: t }).then(s => s.json()).then(s => _t(s, "user list")).then(s => s.data), Io = ["nick", "mail", "link"], qs = e => e.filter(t => Io.includes(t)), Ks = ["//unpkg.com/@waline/emojis@1.1.0/weibo"], Lo = ["//unpkg.com/@waline/emojis/tieba/tieba_agree.png", "//unpkg.com/@waline/emojis/tieba/tieba_look_down.png", "//unpkg.com/@waline/emojis/tieba/tieba_sunglasses.png", "//unpkg.com/@waline/emojis/tieba/tieba_pick_nose.png", "//unpkg.com/@waline/emojis/tieba/tieba_awkward.png", "//unpkg.com/@waline/emojis/tieba/tieba_sleep.png"], Mo = e => new Promise((t, n) => { if (e.size > 128e3) return n(new Error("File too large! File size limit 128KB")); const r = new FileReader; r.readAsDataURL(e), r.onload = () => t(r.result), r.onerror = n }), Po = e => e ? '<p class="wl-tex">TeX is not available in preview</p>' : '<span class="wl-tex">TeX is not available in preview</span>', Oo = e => { const t = async (n, r = {}) => fetch(`https://api.giphy.com/v1/gifs/${n}?${new URLSearchParams({ lang: e, limit: "20", rating: "g", api_key: "6CIMLkNMMOhRcXPoMCPkFy4Ybk2XUiMp", ...r }).toString()}`).then(s => s.json()).then(({ data: s }) => s.map(i => ({ title: i.title, src: i.images.downsized_medium.url }))); return { search: n => t("search", { q: n, offset: "0" }), default: () => t("trending", {}), more: (n, r = 0) => t("search", { q: n, offset: r.toString() }) } }, jo = /[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|\w+/, zo = /</, Fo = /(?:^|\s)\/\/(.+?)$/gm, Do = /\/\*([\S\s]*?)\*\//gm, Ho = new RegExp(`(${jo.source}|${zo.source})|((?:${Fo.source})|(?:${Do.source}))`, "gmi"), Gs = ["23AC69", "91C132", "F19726", "E8552D", "1AAB8E", "E1147F", "2980C1", "1BA1E6", "9FA0A0", "F19726", "E30B20", "E30B20", "A3338B"], Ir = {}, Uo = e => { let t = 0; return e.replace(Ho, (n, r, s) => { if (s) return `<span style="color: slategray">${s}</span>`; if (r === "<") return "&lt;"; let i; Ir[r] ? i = Ir[r] : (i = Gs[t], Ir[r] = i); const l = `<span style="color: #${i}">${r}</span>`; return t = ++t % Gs.length, l }) }, No = ["nick", "nickError", "mail", "mailError", "link", "optional", "placeholder", "sofa", "submit", "like", "cancelLike", "reply", "cancelReply", "comment", "refresh", "more", "preview", "emoji", "uploadImage", "seconds", "minutes", "hours", "days", "now", "uploading", "login", "logout", "admin", "sticky", "word", "wordHint", "anonymous", "level0", "level1", "level2", "level3", "level4", "level5", "gif", "gifSearchPlaceholder", "profile", "approved", "waiting", "spam", "unsticky", "oldest", "latest", "hottest", "reactionTitle"], Be = e => Object.fromEntries(e.map((t, n) => [No[n], t])); var Vo = Be(["Benutzername", "Der Benutzername darf nicht weniger als 3 Bytes umfassen.", "E-Mail", "Bitte bestätigen Sie Ihre E-Mail-Adresse.", "Webseite", "Optional", "Kommentieren Sie hier...", "Noch keine Kommentare.", "Senden", "Gefällt mir", "Gefällt mir nicht mehr", "Antworten", "Antwort abbrechen", "Kommentare", "Aktualisieren", "Mehr laden...", "Vorschau", "Emoji", "Ein Bild hochladen", "Vor einigen Sekunden", "Vor einigen Minuten", "Vor einigen Stunden", "Vor einigen Tagen", "Gerade eben", "Hochladen läuft", "Anmelden", "Abmelden", "Admin", "Angeheftet", "Wörter", "Bitte geben Sie Kommentare zwischen $0 und $1 Wörtern ein! Aktuelle Anzahl der Wörter: $2", "Anonym", "Zwerge", "Hobbits", "Ents", "Magier", "Elfen", "Maïar", "GIF", "Nach einem GIF suchen", "Profil", "Genehmigt", "Ausstehend", "Spam", "Lösen", "Älteste", "Neueste", "Am beliebtesten", "Was denken Sie?"]), Zs = Be(["NickName", "NickName cannot be less than 3 bytes.", "E-Mail", "Please confirm your email address.", "Website", "Optional", "Comment here...", "No comment yet.", "Submit", "Like", "Cancel like", "Reply", "Cancel reply", "Comments", "Refresh", "Load More...", "Preview", "Emoji", "Upload Image", "seconds ago", "minutes ago", "hours ago", "days ago", "just now", "Uploading", "Login", "logout", "Admin", "Sticky", "Words", `Please input comments between $0 and $1 words!
 Current word number: $2`, "Anonymous", "Dwarves", "Hobbits", "Ents", "Wizards", "Elves", "Maiar", "GIF", "Search GIF", "Profile", "Approved", "Waiting", "Spam", "Unsticky", "Oldest", "Latest", "Hottest", "What do you think?"]), Js = Be(["Nombre de usuario", "El nombre de usuario no puede tener menos de 3 bytes.", "Correo electrónico", "Por favor confirma tu dirección de correo electrónico.", "Sitio web", "Opcional", "Comenta aquí...", "Sin comentarios todavía.", "Enviar", "Like", "Anular like", "Responder", "Anular respuesta", "Comentarios", "Recargar", "Cargar Más...", "Previsualizar", "Emoji", "Subir Imagen", "segundos atrás", "minutos atrás", "horas atrás", "días atrás", "justo ahora", "Subiendo", "Iniciar sesión", "cerrar sesión", "Admin", "Fijado", "Palabras", `Por favor escriba entre $0 y $1 palabras!
 El número actual de palabras: $2`, "Anónimo", "Enanos", "Hobbits", "Ents", "Magos", "Elfos", "Maiar", "GIF", "Buscar GIF", "Perfil", "Aprobado", "Esperando", "Spam", "Desfijar", "Más antiguos", "Más recientes", "Más vistos", "¿Qué piensas?"]), Ys = Be(["Pseudo", "Le pseudo ne peut pas faire moins de 3 octets.", "E-mail", "Veuillez confirmer votre adresse e-mail.", "Site Web", "Optionnel", "Commentez ici...", "Aucun commentaire pour l'instant.", "Envoyer", "J'aime", "Annuler le j'aime", "Répondre", "Annuler la réponse", "Commentaires", "Actualiser", "Charger plus...", "Aperçu", "Emoji", "Télécharger une image", "Il y a quelques secondes", "Il y a quelques minutes", "Il y a quelques heures", "Il y a quelques jours", "À l'instant", "Téléchargement en cours", "Connexion", "Déconnexion", "Admin", "Épinglé", "Mots", `Veuillez saisir des commentaires entre $0 et $1 mots !
 Nombre actuel de mots : $2`, "Anonyme", "Nains", "Hobbits", "Ents", "Mages", "Elfes", "Maïar", "GIF", "Rechercher un GIF", "Profil", "Approuvé", "En attente", "Indésirable", "Détacher", "Le plus ancien", "Dernier", "Le plus populaire", "Qu'en pensez-vous ?"]), Qs = Be(["ニックネーム", "3バイト以上のニックネームをご入力ください.", "メールアドレス", "メールアドレスをご確認ください.", "サイト", "オプション", "ここにコメント", "コメントしましょう~", "提出する", "Like", "Cancel like", "返信する", "キャンセル", "コメント", "更新", "さらに読み込む", "プレビュー", "絵文字", "画像をアップロード", "秒前", "分前", "時間前", "日前", "たっだ今", "アップロード", "ログインする", "ログアウト", "管理者", "トップに置く", "ワード", `コメントは $0 から $1 ワードの間でなければなりません!
 現在の単語番号: $2`, "匿名", "うえにん", "なかにん", "しもおし", "特にしもおし", "かげ", "なぬし", "GIF", "探す GIF", "個人情報", "承認済み", "待っている", "スパム", "べたつかない", "逆順", "正順", "人気順", "どう思いますか？"]), Bo = Be(["Apelido", "Apelido não pode ser menor que 3 bytes.", "E-Mail", "Por favor, confirme seu endereço de e-mail.", "Website", "Opcional", "Comente aqui...", "Nenhum comentário, ainda.", "Enviar", "Like", "Cancel like", "Responder", "Cancelar resposta", "Comentários", "Refrescar", "Carregar Mais...", "Visualizar", "Emoji", "Enviar Imagem", "segundos atrás", "minutos atrás", "horas atrás", "dias atrás", "agora mesmo", "Enviando", "Entrar", "Sair", "Admin", "Sticky", "Palavras", `Favor enviar comentário com $0 a $1 palavras!
 Número de palavras atuais: $2`, "Anônimo", "Dwarves", "Hobbits", "Ents", "Wizards", "Elves", "Maiar", "GIF", "Pesquisar GIF", "informação pessoal", "Aprovado", "Espera", "Spam", "Unsticky", "Mais velho", "Mais recentes", "Mais quente", "O que você acha?"]), Xs = Be(["Псевдоним", "Никнейм не может быть меньше 3 байт.", "Эл. адрес", "Пожалуйста, подтвердите адрес вашей электронной почты.", "Веб-сайт", "Необязательный", "Комментарий здесь...", "Пока нет комментариев.", "Отправить", "Like", "Cancel like", "Отвечать", "Отменить ответ", "Комментарии", "Обновить", "Загрузи больше...", "Превью", "эмодзи", "Загрузить изображение", "секунд назад", "несколько минут назад", "несколько часов назад", "дней назад", "прямо сейчас", "Загрузка", "Авторизоваться", "Выход из системы", "Админ", "Липкий", "Слова", `Пожалуйста, введите комментарии от $0 до $1 слов!
Номер текущего слова: $2`, "Анонимный", "Dwarves", "Hobbits", "Ents", "Wizards", "Elves", "Maiar", "GIF", "Поиск GIF", "Персональные данные", "Одобренный", "Ожидающий", "Спам", "Нелипкий", "самый старый", "последний", "самый горячий", "Что вы думаете?"]), ei = Be(["Tên", "Tên không được nhỏ hơn 3 ký tự.", "E-Mail", "Vui lòng xác nhập địa chỉ email của bạn.", "Website", "Tùy chọn", "Hãy bình luận có văn hoá!", "Chưa có bình luận", "Gửi", "Thích", "Bỏ thích", "Trả lời", "Hủy bỏ", "bình luận", "Làm mới", "Tải thêm...", "Xem trước", "Emoji", "Tải lên hình ảnh", "giây trước", "phút trước", "giờ trước", "ngày trước", "Vừa xong", "Đang tải lên", "Đăng nhập", "đăng xuất", "Quản trị viên", "Dính", "từ", `Bình luận phải có độ dài giữa $0 và $1 từ!
 Số từ hiện tại: $2`, "Vô danh", "Người lùn", "Người tí hon", "Thần rừng", "Pháp sư", "Tiên tộc", "Maiar", "Ảnh GIF", "Tìm kiếm ảnh GIF", "thông tin cá nhân", "Đã được phê duyệt", "Đang chờ đợi", "Thư rác", "Không dính", "lâu đời nhất", "muộn nhất", "nóng nhất", "What do you think?"]), ti = Be(["昵称", "昵称不能少于3个字符", "邮箱", "请填写正确的邮件地址", "网址", "可选", "欢迎评论", "来发评论吧~", "提交", "喜欢", "取消喜欢", "回复", "取消回复", "评论", "刷新", "加载更多...", "预览", "表情", "上传图片", "秒前", "分钟前", "小时前", "天前", "刚刚", "正在上传", "登录", "退出", "博主", "置顶", "字", `评论字数应在 $0 到 $1 字之间！
当前字数：$2`, "匿名", "潜水", "冒泡", "吐槽", "活跃", "话痨", "传说", "表情包", "搜索表情包", "个人资料", "通过", "待审核", "垃圾", "取消置顶", "按倒序", "按正序", "按热度", "你认为这篇文章怎么样？"]), Wo = Be(["暱稱", "暱稱不能少於3個字元", "郵箱", "請填寫正確的郵件地址", "網址", "可選", "歡迎留言", "來發留言吧~", "送出", "喜歡", "取消喜歡", "回覆", "取消回覆", "留言", "重整", "載入更多...", "預覽", "表情", "上傳圖片", "秒前", "分鐘前", "小時前", "天前", "剛剛", "正在上傳", "登入", "登出", "管理者", "置頂", "字", `留言字數應在 $0 到 $1 字之間！
目前字數：$2`, "匿名", "潛水", "冒泡", "吐槽", "活躍", "多話", "傳說", "表情包", "搜尋表情包", "個人資料", "通過", "待審核", "垃圾", "取消置頂", "最早", "最新", "熱門", "你認為這篇文章怎麼樣？"]); const ni = "en-US", Fn = { zh: ti, "zh-cn": ti, "zh-tw": Wo, en: Zs, "en-us": Zs, fr: Ys, "fr-fr": Ys, jp: Qs, "jp-jp": Qs, "pt-br": Bo, ru: Xs, "ru-ru": Xs, vi: ei, "vi-vn": ei, de: Vo, es: Js, "es-mx": Js }, ri = e => Fn[e.toLowerCase()] || Fn[ni.toLowerCase()], si = e => Object.keys(Fn).includes(e.toLowerCase()) ? e : ni, ii = { latest: "insertedAt_desc", oldest: "insertedAt_asc", hottest: "like_desc" }, qo = Object.keys(ii), Dn = Symbol("waline-config"), li = e => { try { e = decodeURI(e) } catch { } return e }, oi = (e = "") => e.replace(/\/$/u, ""), ai = e => /^(https?:)?\/\//.test(e), Hn = e => { const t = oi(e); return ai(t) ? t : `https://${t}` }, Ko = e => Array.isArray(e) ? e : e ? [0, e] : !1, nn = (e, t) => e == null || e === !0 ? t : e === !1 ? null : e, Go = ({ serverURL: e, path: t = location.pathname, lang: n = typeof navigator > "u" ? "en-US" : navigator.language, locale: r, meta: s = ["nick", "mail", "link"], requiredMeta: i = [], dark: l = !1, pageSize: o = 10, wordLimit: a, noCopyright: c = !1, login: u = "enable", recaptchaV3Key: f = "", turnstileKey: d = "", commentSorting: m = "latest", emoji: x = Ks, imageUploader: b, highlighter: E, texRenderer: w, search: $, reaction: H, ...I }) => ({ serverURL: Hn(e), path: li(t), lang: si(n), locale: { ...ri(si(n)), ...typeof r == "object" ? r : {} }, wordLimit: Ko(a), meta: qs(s), requiredMeta: qs(i), dark: l, pageSize: o, commentSorting: m, login: u, noCopyright: c, recaptchaV3Key: f, turnstileKey: d, ...I, reaction: H === !0 ? Lo : H || null, imageUploader: nn(b, Mo), highlighter: nn(E, Uo), texRenderer: nn(w, Po), emoji: nn(x, Ks), search: nn($, Oo(n)) }), zt = e => typeof e == "string", Lr = "{--waline-white:#000;--waline-light-grey:#666;--waline-dark-grey:#999;--waline-color:#888;--waline-bg-color:#1e1e1e;--waline-bg-color-light:#272727;--waline-bg-color-hover: #444;--waline-border-color:#333;--waline-disable-bg-color:#444;--waline-disable-color:#272727;--waline-bq-color:#272727;--waline-info-bg-color:#272727;--waline-info-color:#666}", Zo = e => zt(e) ? e === "auto" ? `@media(prefers-color-scheme:dark){body${Lr}}` : `${e}${Lr}` : e === !0 ? `:root${Lr}` : "", Mr = (e, t) => { let n = e.toString(); for (; n.length < t;)n = "0" + n; return n }, Jo = e => { const t = Mr(e.getDate(), 2), n = Mr(e.getMonth() + 1, 2); return `${Mr(e.getFullYear(), 2)}-${n}-${t}` }, Yo = (e, t, n) => { if (!e) return ""; const r = zt(e) ? new Date(e.includes(" ") ? e.replace(/-/g, "/") : e) : e, s = t.getTime() - r.getTime(), i = Math.floor(s / (24 * 3600 * 1e3)); if (i === 0) { const l = s % 864e5, o = Math.floor(l / (3600 * 1e3)); if (o === 0) { const a = l % 36e5, c = Math.floor(a / (60 * 1e3)); if (c === 0) { const u = a % 6e4; return `${Math.round(u / 1e3)} ${n.seconds}` } return `${c} ${n.minutes}` } return `${o} ${n.hours}` } return i < 0 ? n.now : i < 8 ? `${i} ${n.days}` : Jo(r) }, Qo = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, Xo = e => Qo.test(e);/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Pr(e) { const t = Object.create(null); for (const n of e.split(",")) t[n] = 1; return n => n in t } const ce = {}, Ft = [], $t = () => { }, ea = () => !1, Un = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Or = e => e.startsWith("onUpdate:"), je = Object.assign, ci = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }, ta = Object.prototype.hasOwnProperty, re = (e, t) => ta.call(e, t), K = Array.isArray, Dt = e => rn(e) === "[object Map]", Ht = e => rn(e) === "[object Set]", ui = e => rn(e) === "[object Date]", se = e => typeof e == "function", we = e => typeof e == "string", We = e => typeof e == "symbol", de = e => e !== null && typeof e == "object", fi = e => (de(e) || se(e)) && se(e.then) && se(e.catch), hi = Object.prototype.toString, rn = e => hi.call(e), na = e => rn(e).slice(8, -1), pi = e => rn(e) === "[object Object]", jr = e => we(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, sn = Pr(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Nn = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, ra = /-(\w)/g, ze = Nn(e => e.replace(ra, (t, n) => n ? n.toUpperCase() : "")), sa = /\B([A-Z])/g, Ct = Nn(e => e.replace(sa, "-$1").toLowerCase()), Vn = Nn(e => e.charAt(0).toUpperCase() + e.slice(1)), zr = Nn(e => e ? `on${Vn(e)}` : ""), ct = (e, t) => !Object.is(e, t), Bn = (e, ...t) => { for (let n = 0; n < e.length; n++)e[n](...t) }, Fr = (e, t, n, r = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: r, value: n }) }, Wn = e => { const t = parseFloat(e); return isNaN(t) ? e : t }; let di; const ln = () => di || (di = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function on(e) { if (K(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n], s = we(r) ? aa(r) : on(r); if (s) for (const i in s) t[i] = s[i] } return t } else if (we(e) || de(e)) return e } const ia = /;(?![^(]*\))/g, la = /:([^]+)/, oa = /\/\*[^]*?\*\//g; function aa(e) { const t = {}; return e.replace(oa, "").split(ia).forEach(n => { if (n) { const r = n.split(la); r.length > 1 && (t[r[0].trim()] = r[1].trim()) } }), t } function be(e) { let t = ""; if (we(e)) t = e; else if (K(e)) for (let n = 0; n < e.length; n++) { const r = be(e[n]); r && (t += r + " ") } else if (de(e)) for (const n in e) e[n] && (t += n + " "); return t.trim() } const ca = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", ua = Pr(ca); function gi(e) { return !!e || e === "" } function fa(e, t) { if (e.length !== t.length) return !1; let n = !0; for (let r = 0; n && r < e.length; r++)n = St(e[r], t[r]); return n } function St(e, t) { if (e === t) return !0; let n = ui(e), r = ui(t); if (n || r) return n && r ? e.getTime() === t.getTime() : !1; if (n = We(e), r = We(t), n || r) return e === t; if (n = K(e), r = K(t), n || r) return n && r ? fa(e, t) : !1; if (n = de(e), r = de(t), n || r) { if (!n || !r) return !1; const s = Object.keys(e).length, i = Object.keys(t).length; if (s !== i) return !1; for (const l in e) { const o = e.hasOwnProperty(l), a = t.hasOwnProperty(l); if (o && !a || !o && a || !St(e[l], t[l])) return !1 } } return String(e) === String(t) } function Dr(e, t) { return e.findIndex(n => St(n, t)) } const mi = e => !!(e && e.__v_isRef === !0), ee = e => we(e) ? e : e == null ? "" : K(e) || de(e) && (e.toString === hi || !se(e.toString)) ? mi(e) ? ee(e.value) : JSON.stringify(e, vi, 2) : String(e), vi = (e, t) => mi(t) ? vi(e, t.value) : Dt(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [r, s], i) => (n[Hr(r, i) + " =>"] = s, n), {}) } : Ht(t) ? { [`Set(${t.size})`]: [...t.values()].map(n => Hr(n)) } : We(t) ? Hr(t) : de(t) && !K(t) && !pi(t) ? String(t) : t, Hr = (e, t = "") => { var n; return We(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e };/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let _e; class ha { constructor(t = !1) { this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = _e, !t && _e && (this.index = (_e.scopes || (_e.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].pause(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].resume(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].resume() } } run(t) { if (this._active) { const n = _e; try { return _e = this, t() } finally { _e = n } } } on() { ++this._on === 1 && (this.prevScope = _e, _e = this) } off() { this._on > 0 && --this._on === 0 && (_e = this.prevScope, this.prevScope = void 0) } stop(t) { if (this._active) { this._active = !1; let n, r; for (n = 0, r = this.effects.length; n < r; n++)this.effects[n].stop(); for (this.effects.length = 0, n = 0, r = this.cleanups.length; n < r; n++)this.cleanups[n](); if (this.cleanups.length = 0, this.scopes) { for (n = 0, r = this.scopes.length; n < r; n++)this.scopes[n].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !t) { const s = this.parent.scopes.pop(); s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index) } this.parent = void 0 } } } function bi() { return _e } function pa(e, t = !1) { _e && _e.cleanups.push(e) } let he; const Ur = new WeakSet; class yi { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, _e && _e.active && _e.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, Ur.has(this) && (Ur.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || ki(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, Si(this), xi(this); const t = he, n = Ne; he = this, Ne = !0; try { return this.fn() } finally { _i(this), he = t, Ne = n, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)Wr(t); this.deps = this.depsTail = void 0, Si(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? Ur.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { Br(this) && this.run() } get dirty() { return Br(this) } } let wi = 0, an, cn; function ki(e, t = !1) { if (e.flags |= 8, t) { e.next = cn, cn = e; return } e.next = an, an = e } function Nr() { wi++ } function Vr() { if (--wi > 0) return; if (cn) { let t = cn; for (cn = void 0; t;) { const n = t.next; t.next = void 0, t.flags &= -9, t = n } } let e; for (; an;) { let t = an; for (an = void 0; t;) { const n = t.next; if (t.next = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (r) { e || (e = r) } t = n } } if (e) throw e } function xi(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function _i(e) { let t, n = e.depsTail, r = n; for (; r;) { const s = r.prevDep; r.version === -1 ? (r === n && (n = s), Wr(r), da(r)) : t = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = s } e.deps = t, e.depsTail = n } function Br(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && ($i(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function $i(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === un) || (e.globalVersion = un, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !Br(e)))) return; e.flags |= 2; const t = e.dep, n = he, r = Ne; he = e, Ne = !0; try { xi(e); const s = e.fn(e._value); (t.version === 0 || ct(s, e._value)) && (e.flags |= 128, e._value = s, t.version++) } catch (s) { throw t.version++, s } finally { he = n, Ne = r, _i(e), e.flags &= -3 } } function Wr(e, t = !1) { const { dep: n, prevSub: r, nextSub: s } = e; if (r && (r.nextSub = s, e.prevSub = void 0), s && (s.prevSub = r, e.nextSub = void 0), n.subs === e && (n.subs = r, !r && n.computed)) { n.computed.flags &= -5; for (let i = n.computed.deps; i; i = i.nextDep)Wr(i, !0) } !t && !--n.sc && n.map && n.map.delete(n.key) } function da(e) { const { prevDep: t, nextDep: n } = e; t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0) } let Ne = !0; const Ci = []; function ut() { Ci.push(Ne), Ne = !1 } function ft() { const e = Ci.pop(); Ne = e === void 0 ? !0 : e } function Si(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const n = he; he = void 0; try { t() } finally { he = n } } } let un = 0; class ga { constructor(t, n) { this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class qn { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0 } track(t) { if (!he || !Ne || he === this.computed) return; let n = this.activeLink; if (n === void 0 || n.sub !== he) n = this.activeLink = new ga(he, this), he.deps ? (n.prevDep = he.depsTail, he.depsTail.nextDep = n, he.depsTail = n) : he.deps = he.depsTail = n, Ri(n); else if (n.version === -1 && (n.version = this.version, n.nextDep)) { const r = n.nextDep; r.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = r), n.prevDep = he.depsTail, n.nextDep = void 0, he.depsTail.nextDep = n, he.depsTail = n, he.deps === n && (he.deps = r) } return n } trigger(t) { this.version++, un++, this.notify(t) } notify(t) { Nr(); try { for (let n = this.subs; n; n = n.prevSub)n.sub.notify() && n.sub.dep.notify() } finally { Vr() } } } function Ri(e) { if (e.dep.sc++, e.sub.flags & 4) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let r = t.deps; r; r = r.nextDep)Ri(r) } const n = e.dep.subs; n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e } } const Kn = new WeakMap, Rt = Symbol(""), qr = Symbol(""), fn = Symbol(""); function $e(e, t, n) { if (Ne && he) { let r = Kn.get(e); r || Kn.set(e, r = new Map); let s = r.get(n); s || (r.set(n, s = new qn), s.map = r, s.key = n), s.track() } } function Qe(e, t, n, r, s, i) { const l = Kn.get(e); if (!l) { un++; return } const o = a => { a && a.trigger() }; if (Nr(), t === "clear") l.forEach(o); else { const a = K(e), c = a && jr(n); if (a && n === "length") { const u = Number(r); l.forEach((f, d) => { (d === "length" || d === fn || !We(d) && d >= u) && o(f) }) } else switch ((n !== void 0 || l.has(void 0)) && o(l.get(n)), c && o(l.get(fn)), t) { case "add": a ? c && o(l.get("length")) : (o(l.get(Rt)), Dt(e) && o(l.get(qr))); break; case "delete": a || (o(l.get(Rt)), Dt(e) && o(l.get(qr))); break; case "set": Dt(e) && o(l.get(Rt)); break } } Vr() } function ma(e, t) { const n = Kn.get(e); return n && n.get(t) } function Ut(e) { const t = te(e); return t === e ? t : ($e(t, "iterate", fn), Fe(e) ? t : t.map(xe)) } function Gn(e) { return $e(e = te(e), "iterate", fn), e } const va = { __proto__: null, [Symbol.iterator]() { return Kr(this, Symbol.iterator, xe) }, concat(...e) { return Ut(this).concat(...e.map(t => K(t) ? Ut(t) : t)) }, entries() { return Kr(this, "entries", e => (e[1] = xe(e[1]), e)) }, every(e, t) { return Xe(this, "every", e, t, void 0, arguments) }, filter(e, t) { return Xe(this, "filter", e, t, n => n.map(xe), arguments) }, find(e, t) { return Xe(this, "find", e, t, xe, arguments) }, findIndex(e, t) { return Xe(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return Xe(this, "findLast", e, t, xe, arguments) }, findLastIndex(e, t) { return Xe(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return Xe(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return Gr(this, "includes", e) }, indexOf(...e) { return Gr(this, "indexOf", e) }, join(e) { return Ut(this).join(e) }, lastIndexOf(...e) { return Gr(this, "lastIndexOf", e) }, map(e, t) { return Xe(this, "map", e, t, void 0, arguments) }, pop() { return hn(this, "pop") }, push(...e) { return hn(this, "push", e) }, reduce(e, ...t) { return Ai(this, "reduce", e, t) }, reduceRight(e, ...t) { return Ai(this, "reduceRight", e, t) }, shift() { return hn(this, "shift") }, some(e, t) { return Xe(this, "some", e, t, void 0, arguments) }, splice(...e) { return hn(this, "splice", e) }, toReversed() { return Ut(this).toReversed() }, toSorted(e) { return Ut(this).toSorted(e) }, toSpliced(...e) { return Ut(this).toSpliced(...e) }, unshift(...e) { return hn(this, "unshift", e) }, values() { return Kr(this, "values", xe) } }; function Kr(e, t, n) { const r = Gn(e), s = r[t](); return r !== e && !Fe(e) && (s._next = s.next, s.next = () => { const i = s._next(); return i.value && (i.value = n(i.value)), i }), s } const ba = Array.prototype; function Xe(e, t, n, r, s, i) { const l = Gn(e), o = l !== e && !Fe(e), a = l[t]; if (a !== ba[t]) { const f = a.apply(e, i); return o ? xe(f) : f } let c = n; l !== e && (o ? c = function (f, d) { return n.call(this, xe(f), d, e) } : n.length > 2 && (c = function (f, d) { return n.call(this, f, d, e) })); const u = a.call(l, c, r); return o && s ? s(u) : u } function Ai(e, t, n, r) { const s = Gn(e); let i = n; return s !== e && (Fe(e) ? n.length > 3 && (i = function (l, o, a) { return n.call(this, l, o, a, e) }) : i = function (l, o, a) { return n.call(this, l, xe(o), a, e) }), s[t](i, ...r) } function Gr(e, t, n) { const r = te(e); $e(r, "iterate", fn); const s = r[t](...n); return (s === -1 || s === !1) && Jr(n[0]) ? (n[0] = te(n[0]), r[t](...n)) : s } function hn(e, t, n = []) { ut(), Nr(); const r = te(e)[t].apply(e, n); return Vr(), ft(), r } const ya = Pr("__proto__,__v_isRef,__isVue"), Ei = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(We)); function wa(e) { We(e) || (e = String(e)); const t = te(this); return $e(t, "has", e), t.hasOwnProperty(e) } class Ti { constructor(t = !1, n = !1) { this._isReadonly = t, this._isShallow = n } get(t, n, r) { if (n === "__v_skip") return t.__v_skip; const s = this._isReadonly, i = this._isShallow; if (n === "__v_isReactive") return !s; if (n === "__v_isReadonly") return s; if (n === "__v_isShallow") return i; if (n === "__v_raw") return r === (s ? i ? ji : Oi : i ? Pi : Mi).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(r) ? t : void 0; const l = K(t); if (!s) { let a; if (l && (a = va[n])) return a; if (n === "hasOwnProperty") return wa } const o = Reflect.get(t, n, ye(t) ? t : r); return (We(n) ? Ei.has(n) : ya(n)) || (s || $e(t, "get", n), i) ? o : ye(o) ? l && jr(n) ? o : o.value : de(o) ? s ? Nt(o) : pn(o) : o } } class Ii extends Ti { constructor(t = !1) { super(!1, t) } set(t, n, r, s) { let i = t[n]; if (!this._isShallow) { const a = ht(i); if (!Fe(r) && !ht(r) && (i = te(i), r = te(r)), !K(t) && ye(i) && !ye(r)) return a ? !1 : (i.value = r, !0) } const l = K(t) && jr(n) ? Number(n) < t.length : re(t, n), o = Reflect.set(t, n, r, ye(t) ? t : s); return t === te(s) && (l ? ct(r, i) && Qe(t, "set", n, r) : Qe(t, "add", n, r)), o } deleteProperty(t, n) { const r = re(t, n), s = Reflect.deleteProperty(t, n); return s && r && Qe(t, "delete", n, void 0), s } has(t, n) { const r = Reflect.has(t, n); return (!We(n) || !Ei.has(n)) && $e(t, "has", n), r } ownKeys(t) { return $e(t, "iterate", K(t) ? "length" : Rt), Reflect.ownKeys(t) } } class Li extends Ti { constructor(t = !1) { super(!0, t) } set(t, n) { return !0 } deleteProperty(t, n) { return !0 } } const ka = new Ii, xa = new Li, _a = new Ii(!0), $a = new Li(!0), Zr = e => e, Zn = e => Reflect.getPrototypeOf(e); function Ca(e, t, n) { return function (...r) { const s = this.__v_raw, i = te(s), l = Dt(i), o = e === "entries" || e === Symbol.iterator && l, a = e === "keys" && l, c = s[e](...r), u = n ? Zr : t ? Xn : xe; return !t && $e(i, "iterate", a ? qr : Rt), { next() { const { value: f, done: d } = c.next(); return d ? { value: f, done: d } : { value: o ? [u(f[0]), u(f[1])] : u(f), done: d } }, [Symbol.iterator]() { return this } } } } function Jn(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function Sa(e, t) { const n = { get(s) { const i = this.__v_raw, l = te(i), o = te(s); e || (ct(s, o) && $e(l, "get", s), $e(l, "get", o)); const { has: a } = Zn(l), c = t ? Zr : e ? Xn : xe; if (a.call(l, s)) return c(i.get(s)); if (a.call(l, o)) return c(i.get(o)); i !== l && i.get(s) }, get size() { const s = this.__v_raw; return !e && $e(te(s), "iterate", Rt), Reflect.get(s, "size", s) }, has(s) { const i = this.__v_raw, l = te(i), o = te(s); return e || (ct(s, o) && $e(l, "has", s), $e(l, "has", o)), s === o ? i.has(s) : i.has(s) || i.has(o) }, forEach(s, i) { const l = this, o = l.__v_raw, a = te(o), c = t ? Zr : e ? Xn : xe; return !e && $e(a, "iterate", Rt), o.forEach((u, f) => s.call(i, c(u), c(f), l)) } }; return je(n, e ? { add: Jn("add"), set: Jn("set"), delete: Jn("delete"), clear: Jn("clear") } : { add(s) { !t && !Fe(s) && !ht(s) && (s = te(s)); const i = te(this); return Zn(i).has.call(i, s) || (i.add(s), Qe(i, "add", s, s)), this }, set(s, i) { !t && !Fe(i) && !ht(i) && (i = te(i)); const l = te(this), { has: o, get: a } = Zn(l); let c = o.call(l, s); c || (s = te(s), c = o.call(l, s)); const u = a.call(l, s); return l.set(s, i), c ? ct(i, u) && Qe(l, "set", s, i) : Qe(l, "add", s, i), this }, delete(s) { const i = te(this), { has: l, get: o } = Zn(i); let a = l.call(i, s); a || (s = te(s), a = l.call(i, s)), o && o.call(i, s); const c = i.delete(s); return a && Qe(i, "delete", s, void 0), c }, clear() { const s = te(this), i = s.size !== 0, l = s.clear(); return i && Qe(s, "clear", void 0, void 0), l } }), ["keys", "values", "entries", Symbol.iterator].forEach(s => { n[s] = Ca(s, e, t) }), n } function Yn(e, t) { const n = Sa(e, t); return (r, s, i) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? r : Reflect.get(re(n, s) && s in r ? n : r, s, i) } const Ra = { get: Yn(!1, !1) }, Aa = { get: Yn(!1, !0) }, Ea = { get: Yn(!0, !1) }, Ta = { get: Yn(!0, !0) }, Mi = new WeakMap, Pi = new WeakMap, Oi = new WeakMap, ji = new WeakMap; function Ia(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function La(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : Ia(na(e)) } function pn(e) { return ht(e) ? e : Qn(e, !1, ka, Ra, Mi) } function Ma(e) { return Qn(e, !1, _a, Aa, Pi) } function Nt(e) { return Qn(e, !0, xa, Ea, Oi) } function Pa(e) { return Qn(e, !0, $a, Ta, ji) } function Qn(e, t, n, r, s) { if (!de(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const i = La(e); if (i === 0) return e; const l = s.get(e); if (l) return l; const o = new Proxy(e, i === 2 ? r : n); return s.set(e, o), o } function Vt(e) { return ht(e) ? Vt(e.__v_raw) : !!(e && e.__v_isReactive) } function ht(e) { return !!(e && e.__v_isReadonly) } function Fe(e) { return !!(e && e.__v_isShallow) } function Jr(e) { return e ? !!e.__v_raw : !1 } function te(e) { const t = e && e.__v_raw; return t ? te(t) : e } function Oa(e) { return !re(e, "__v_skip") && Object.isExtensible(e) && Fr(e, "__v_skip", !0), e } const xe = e => de(e) ? pn(e) : e, Xn = e => de(e) ? Nt(e) : e; function ye(e) { return e ? e.__v_isRef === !0 : !1 } function ae(e) { return zi(e, !1) } function At(e) { return zi(e, !0) } function zi(e, t) { return ye(e) ? e : new ja(e, t) } class ja { constructor(t, n) { this.dep = new qn, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : te(t), this._value = n ? t : xe(t), this.__v_isShallow = n } get value() { return this.dep.track(), this._value } set value(t) { const n = this._rawValue, r = this.__v_isShallow || Fe(t) || ht(t); t = r ? t : te(t), ct(t, n) && (this._rawValue = t, this._value = r ? t : xe(t), this.dep.trigger()) } } function G(e) { return ye(e) ? e.value : e } function Ie(e) { return se(e) ? e() : G(e) } const za = { get: (e, t, n) => t === "__v_raw" ? e : G(Reflect.get(e, t, n)), set: (e, t, n, r) => { const s = e[t]; return ye(s) && !ye(n) ? (s.value = n, !0) : Reflect.set(e, t, n, r) } }; function Fi(e) { return Vt(e) ? e : new Proxy(e, za) } class Fa { constructor(t) { this.__v_isRef = !0, this._value = void 0; const n = this.dep = new qn, { get: r, set: s } = t(n.track.bind(n), n.trigger.bind(n)); this._get = r, this._set = s } get value() { return this._value = this._get() } set value(t) { this._set(t) } } function Da(e) { return new Fa(e) } class Ha { constructor(t, n, r) { this._object = t, this._key = n, this._defaultValue = r, this.__v_isRef = !0, this._value = void 0 } get value() { const t = this._object[this._key]; return this._value = t === void 0 ? this._defaultValue : t } set value(t) { this._object[this._key] = t } get dep() { return ma(te(this._object), this._key) } } class Ua { constructor(t) { this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0 } get value() { return this._value = this._getter() } } function Na(e, t, n) { return ye(e) ? e : se(e) ? new Ua(e) : de(e) && arguments.length > 1 ? Va(e, t, n) : ae(e) } function Va(e, t, n) { const r = e[t]; return ye(r) ? r : new Ha(e, t, n) } class Ba { constructor(t, n, r) { this.fn = t, this.setter = n, this._value = void 0, this.dep = new qn(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = un - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = r } notify() { if (this.flags |= 16, !(this.flags & 8) && he !== this) return ki(this, !0), !0 } get value() { const t = this.dep.track(); return $i(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } } function Wa(e, t, n = !1) { let r, s; return se(e) ? r = e : (r = e.get, s = e.set), new Ba(r, s, n) } const er = {}, tr = new WeakMap; let Et; function qa(e, t = !1, n = Et) { if (n) { let r = tr.get(n); r || tr.set(n, r = []), r.push(e) } } function Ka(e, t, n = ce) { const { immediate: r, deep: s, once: i, scheduler: l, augmentJob: o, call: a } = n, c = I => s ? I : Fe(I) || s === !1 || s === 0 ? et(I, 1) : et(I); let u, f, d, m, x = !1, b = !1; if (ye(e) ? (f = () => e.value, x = Fe(e)) : Vt(e) ? (f = () => c(e), x = !0) : K(e) ? (b = !0, x = e.some(I => Vt(I) || Fe(I)), f = () => e.map(I => { if (ye(I)) return I.value; if (Vt(I)) return c(I); if (se(I)) return a ? a(I, 2) : I() })) : se(e) ? t ? f = a ? () => a(e, 2) : e : f = () => { if (d) { ut(); try { d() } finally { ft() } } const I = Et; Et = u; try { return a ? a(e, 3, [m]) : e(m) } finally { Et = I } } : f = $t, t && s) { const I = f, P = s === !0 ? 1 / 0 : s; f = () => et(I(), P) } const E = bi(), w = () => { u.stop(), E && E.active && ci(E.effects, u) }; if (i && t) { const I = t; t = (...P) => { I(...P), w() } } let $ = b ? new Array(e.length).fill(er) : er; const H = I => { if (!(!(u.flags & 1) || !u.dirty && !I)) if (t) { const P = u.run(); if (s || x || (b ? P.some((W, Z) => ct(W, $[Z])) : ct(P, $))) { d && d(); const W = Et; Et = u; try { const Z = [P, $ === er ? void 0 : b && $[0] === er ? [] : $, m]; $ = P, a ? a(t, 3, Z) : t(...Z) } finally { Et = W } } } else u.run() }; return o && o(H), u = new yi(f), u.scheduler = l ? () => l(H, !1) : H, m = I => qa(I, !1, u), d = u.onStop = () => { const I = tr.get(u); if (I) { if (a) a(I, 4); else for (const P of I) P(); tr.delete(u) } }, t ? r ? H(!0) : $ = u.run() : l ? l(H.bind(null, !0), !0) : u.run(), w.pause = u.pause.bind(u), w.resume = u.resume.bind(u), w.stop = w, w } function et(e, t = 1 / 0, n) { if (t <= 0 || !de(e) || e.__v_skip || (n = n || new Set, n.has(e))) return e; if (n.add(e), t--, ye(e)) et(e.value, t, n); else if (K(e)) for (let r = 0; r < e.length; r++)et(e[r], t, n); else if (Ht(e) || Dt(e)) e.forEach(r => { et(r, t, n) }); else if (pi(e)) { for (const r in e) et(e[r], t, n); for (const r of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, r) && et(e[r], t, n) } return e }/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function dn(e, t, n, r) { try { return r ? e(...r) : e() } catch (s) { nr(s, t, n) } } function tt(e, t, n, r) { if (se(e)) { const s = dn(e, t, n, r); return s && fi(s) && s.catch(i => { nr(i, t, n) }), s } if (K(e)) { const s = []; for (let i = 0; i < e.length; i++)s.push(tt(e[i], t, n, r)); return s } } function nr(e, t, n, r = !0) { const s = t ? t.vnode : null, { errorHandler: i, throwUnhandledErrorInProduction: l } = t && t.appContext.config || ce; if (t) { let o = t.parent; const a = t.proxy, c = `https://vuejs.org/error-reference/#runtime-${n}`; for (; o;) { const u = o.ec; if (u) { for (let f = 0; f < u.length; f++)if (u[f](e, a, c) === !1) return } o = o.parent } if (i) { ut(), dn(i, null, 10, [e, a, c]), ft(); return } } Ga(e, n, s, r, l) } function Ga(e, t, n, r = !0, s = !1) { if (s) throw e; console.error(e) } const Se = []; let qe = -1; const Bt = []; let pt = null, Wt = 0; const Di = Promise.resolve(); let rr = null; function qt(e) { const t = rr || Di; return e ? t.then(this ? e.bind(this) : e) : t } function Za(e) { let t = qe + 1, n = Se.length; for (; t < n;) { const r = t + n >>> 1, s = Se[r], i = gn(s); i < e || i === e && s.flags & 2 ? t = r + 1 : n = r } return t } function Yr(e) { if (!(e.flags & 1)) { const t = gn(e), n = Se[Se.length - 1]; !n || !(e.flags & 2) && t >= gn(n) ? Se.push(e) : Se.splice(Za(t), 0, e), e.flags |= 1, Hi() } } function Hi() { rr || (rr = Di.then(Vi)) } function Ja(e) { K(e) ? Bt.push(...e) : pt && e.id === -1 ? pt.splice(Wt + 1, 0, e) : e.flags & 1 || (Bt.push(e), e.flags |= 1), Hi() } function Ui(e, t, n = qe + 1) { for (; n < Se.length; n++) { const r = Se[n]; if (r && r.flags & 2) { if (e && r.id !== e.uid) continue; Se.splice(n, 1), n--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2) } } } function Ni(e) { if (Bt.length) { const t = [...new Set(Bt)].sort((n, r) => gn(n) - gn(r)); if (Bt.length = 0, pt) { pt.push(...t); return } for (pt = t, Wt = 0; Wt < pt.length; Wt++) { const n = pt[Wt]; n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2 } pt = null, Wt = 0 } } const gn = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function Vi(e) { try { for (qe = 0; qe < Se.length; qe++) { const t = Se[qe]; t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), dn(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2)) } } finally { for (; qe < Se.length; qe++) { const t = Se[qe]; t && (t.flags &= -2) } qe = -1, Se.length = 0, Ni(), rr = null, (Se.length || Bt.length) && Vi() } } let Ee = null, Bi = null; function sr(e) { const t = Ee; return Ee = e, Bi = e && e.type.__scopeId || null, t } function Ya(e, t = Ee, n) { if (!t || e._n) return e; const r = (...s) => { r._d && cl(-1); const i = sr(t); let l; try { l = e(...s) } finally { sr(i), r._d && cl(1) } return l }; return r._n = !0, r._c = !0, r._d = !0, r } function ir(e, t) { if (Ee === null) return e; const n = hr(Ee), r = e.dirs || (e.dirs = []); for (let s = 0; s < t.length; s++) { let [i, l, o, a = ce] = t[s]; i && (se(i) && (i = { mounted: i, updated: i }), i.deep && et(l), r.push({ dir: i, instance: n, value: l, oldValue: void 0, arg: o, modifiers: a })) } return e } function Tt(e, t, n, r) { const s = e.dirs, i = t && t.dirs; for (let l = 0; l < s.length; l++) { const o = s[l]; i && (o.oldValue = i[l].value); let a = o.dir[r]; a && (ut(), tt(a, n, 8, [e.el, o, e, t]), ft()) } } const Qa = Symbol("_vte"), Xa = e => e.__isTeleport; function Qr(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, Qr(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t }/*! #__NO_SIDE_EFFECTS__ */function mn(e, t) { return se(e) ? je({ name: e.name }, t, { setup: e }) : e } function ec(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } function dt(e) { const t = hl(), n = At(null); if (t) { const s = t.refs === ce ? t.refs = {} : t.refs; Object.defineProperty(s, e, { enumerable: !0, get: () => n.value, set: i => n.value = i }) } return n } function vn(e, t, n, r, s = !1) { if (K(e)) { e.forEach((x, b) => vn(x, t && (K(t) ? t[b] : t), n, r, s)); return } if (bn(r) && !s) { r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && vn(e, t, n, r.component.subTree); return } const i = r.shapeFlag & 4 ? hr(r.component) : r.el, l = s ? null : i, { i: o, r: a } = e, c = t && t.r, u = o.refs === ce ? o.refs = {} : o.refs, f = o.setupState, d = te(f), m = f === ce ? () => !1 : x => re(d, x); if (c != null && c !== a && (we(c) ? (u[c] = null, m(c) && (f[c] = null)) : ye(c) && (c.value = null)), se(a)) dn(a, o, 12, [l, u]); else { const x = we(a), b = ye(a); if (x || b) { const E = () => { if (e.f) { const w = x ? m(a) ? f[a] : u[a] : a.value; s ? K(w) && ci(w, i) : K(w) ? w.includes(i) || w.push(i) : x ? (u[a] = [i], m(a) && (f[a] = u[a])) : (a.value = [i], e.k && (u[e.k] = a.value)) } else x ? (u[a] = l, m(a) && (f[a] = l)) : b && (a.value = l, e.k && (u[e.k] = l)) }; l ? (E.id = -1, Le(E, n)) : E() } } } ln().requestIdleCallback, ln().cancelIdleCallback; const bn = e => !!e.type.__asyncLoader, tc = e => e.type.__isKeepAlive; function nc(e, t, n = Re, r = !1) { if (n) { const s = n[e] || (n[e] = []), i = t.__weh || (t.__weh = (...l) => { ut(); const o = us(n), a = tt(t, n, e, l); return o(), ft(), a }); return r ? s.unshift(i) : s.push(i), i } } const Xr = e => (t, n = Re) => { (!$n || e === "sp") && nc(e, (...r) => t(...r), n) }, yn = Xr("m"), rc = Xr("bum"), es = Xr("um"), sc = "components"; function ic(e, t) { return oc(sc, e, !0, t) || e } const lc = Symbol.for("v-ndc"); function oc(e, t, n = !0, r = !1) { const s = Ee || Re; if (s) { const i = s.type; { const o = Bc(i, !1); if (o && (o === t || o === ze(t) || o === Vn(ze(t)))) return i } const l = Wi(s[e] || i[e], t) || Wi(s.appContext[e], t); return !l && r ? i : l } } function Wi(e, t) { return e && (e[t] || e[ze(t)] || e[Vn(ze(t))]) } function De(e, t, n, r) { let s; const i = n, l = K(e); if (l || we(e)) { const o = l && Vt(e); let a = !1, c = !1; o && (a = !Fe(e), c = ht(e), e = Gn(e)), s = new Array(e.length); for (let u = 0, f = e.length; u < f; u++)s[u] = t(a ? c ? Xn(xe(e[u])) : xe(e[u]) : e[u], u, void 0, i) } else if (typeof e == "number") { s = new Array(e); for (let o = 0; o < e; o++)s[o] = t(o + 1, o, void 0, i) } else if (de(e)) if (e[Symbol.iterator]) s = Array.from(e, (o, a) => t(o, a, void 0, i)); else { const o = Object.keys(e); s = new Array(o.length); for (let a = 0, c = o.length; a < c; a++) { const u = o[a]; s[a] = t(e[u], u, a, i) } } else s = []; return s } const ts = e => e ? dl(e) ? hr(e) : ts(e.parent) : null, wn = je(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => ts(e.parent), $root: e => ts(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => e.type, $forceUpdate: e => e.f || (e.f = () => { Yr(e.update) }), $nextTick: e => e.n || (e.n = qt.bind(e.proxy)), $watch: e => $t }), ns = (e, t) => e !== ce && !e.__isScriptSetup && re(e, t), ac = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: n, setupState: r, data: s, props: i, accessCache: l, type: o, appContext: a } = e; let c; if (t[0] !== "$") { const m = l[t]; if (m !== void 0) switch (m) { case 1: return r[t]; case 2: return s[t]; case 4: return n[t]; case 3: return i[t] } else { if (ns(r, t)) return l[t] = 1, r[t]; if (s !== ce && re(s, t)) return l[t] = 2, s[t]; if ((c = e.propsOptions[0]) && re(c, t)) return l[t] = 3, i[t]; if (n !== ce && re(n, t)) return l[t] = 4, n[t]; l[t] = 0 } } const u = wn[t]; let f, d; if (u) return t === "$attrs" && $e(e.attrs, "get", ""), u(e); if ((f = o.__cssModules) && (f = f[t])) return f; if (n !== ce && re(n, t)) return l[t] = 4, n[t]; if (d = a.config.globalProperties, re(d, t)) return d[t] }, set({ _: e }, t, n) { const { data: r, setupState: s, ctx: i } = e; return ns(s, t) ? (s[t] = n, !0) : r !== ce && re(r, t) ? (r[t] = n, !0) : re(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (i[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: r, appContext: s, propsOptions: i } }, l) { let o; return !!n[l] || e !== ce && re(e, l) || ns(t, l) || (o = i[0]) && re(o, l) || re(r, l) || re(wn, l) || re(s.config.globalProperties, l) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : re(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; function qi() { return { app: null, config: { isNativeTag: ea, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let cc = 0; function uc(e, t) { return function (r, s = null) { se(r) || (r = je({}, r)), s != null && !de(s) && (s = null); const i = qi(), l = new WeakSet, o = []; let a = !1; const c = i.app = { _uid: cc++, _component: r, _props: s, _container: null, _context: i, _instance: null, version: qc, get config() { return i.config }, set config(u) { }, use(u, ...f) { return l.has(u) || (u && se(u.install) ? (l.add(u), u.install(c, ...f)) : se(u) && (l.add(u), u(c, ...f))), c }, mixin(u) { return c }, component(u, f) { return f ? (i.components[u] = f, c) : i.components[u] }, directive(u, f) { return f ? (i.directives[u] = f, c) : i.directives[u] }, mount(u, f, d) { if (!a) { const m = c._ceVNode || ue(r, s); return m.appContext = i, d === !0 ? d = "svg" : d === !1 && (d = void 0), e(m, u, d), a = !0, c._container = u, u.__vue_app__ = c, hr(m.component) } }, onUnmount(u) { o.push(u) }, unmount() { a && (tt(o, c._instance, 16), e(null, c._container), delete c._container.__vue_app__) }, provide(u, f) { return i.provides[u] = f, c }, runWithContext(u) { const f = Kt; Kt = c; try { return u() } finally { Kt = f } } }; return c } } let Kt = null; function fc(e, t) { if (Re) { let n = Re.provides; const r = Re.parent && Re.parent.provides; r === n && (n = Re.provides = Object.create(r)), n[e] = t } } function lr(e, t, n = !1) { const r = Re || Ee; if (r || Kt) { let s = Kt ? Kt._context.provides : r ? r.parent == null || r.ce ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0; if (s && e in s) return s[e]; if (arguments.length > 1) return n && se(t) ? t.call(r && r.proxy) : t } } const Ki = {}, Gi = () => Object.create(Ki), Zi = e => Object.getPrototypeOf(e) === Ki; function hc(e, t, n, r = !1) { const s = {}, i = Gi(); e.propsDefaults = Object.create(null), Ji(e, t, s, i); for (const l in e.propsOptions[0]) l in s || (s[l] = void 0); n ? e.props = r ? s : Ma(s) : e.type.props ? e.props = s : e.props = i, e.attrs = i } function pc(e, t, n, r) { const { props: s, attrs: i, vnode: { patchFlag: l } } = e, o = te(s), [a] = e.propsOptions; let c = !1; if ((r || l > 0) && !(l & 16)) { if (l & 8) { const u = e.vnode.dynamicProps; for (let f = 0; f < u.length; f++) { let d = u[f]; if (or(e.emitsOptions, d)) continue; const m = t[d]; if (a) if (re(i, d)) m !== i[d] && (i[d] = m, c = !0); else { const x = ze(d); s[x] = rs(a, o, x, m, e, !1) } else m !== i[d] && (i[d] = m, c = !0) } } } else { Ji(e, t, s, i) && (c = !0); let u; for (const f in o) (!t || !re(t, f) && ((u = Ct(f)) === f || !re(t, u))) && (a ? n && (n[f] !== void 0 || n[u] !== void 0) && (s[f] = rs(a, o, f, void 0, e, !0)) : delete s[f]); if (i !== o) for (const f in i) (!t || !re(t, f)) && (delete i[f], c = !0) } c && Qe(e.attrs, "set", "") } function Ji(e, t, n, r) { const [s, i] = e.propsOptions; let l = !1, o; if (t) for (let a in t) { if (sn(a)) continue; const c = t[a]; let u; s && re(s, u = ze(a)) ? !i || !i.includes(u) ? n[u] = c : (o || (o = {}))[u] = c : or(e.emitsOptions, a) || (!(a in r) || c !== r[a]) && (r[a] = c, l = !0) } if (i) { const a = te(n), c = o || ce; for (let u = 0; u < i.length; u++) { const f = i[u]; n[f] = rs(s, a, f, c[f], e, !re(c, f)) } } return l } function rs(e, t, n, r, s, i) { const l = e[n]; if (l != null) { const o = re(l, "default"); if (o && r === void 0) { const a = l.default; if (l.type !== Function && !l.skipFactory && se(a)) { const { propsDefaults: c } = s; if (n in c) r = c[n]; else { const u = us(s); r = c[n] = a.call(null, t), u() } } else r = a; s.ce && s.ce._setProp(n, r) } l[0] && (i && !o ? r = !1 : l[1] && (r === "" || r === Ct(n)) && (r = !0)) } return r } function dc(e, t, n = !1) { const r = t.propsCache, s = r.get(e); if (s) return s; const i = e.props, l = {}, o = []; if (!i) return de(e) && r.set(e, Ft), Ft; if (K(i)) for (let c = 0; c < i.length; c++) { const u = ze(i[c]); Yi(u) && (l[u] = ce) } else if (i) for (const c in i) { const u = ze(c); if (Yi(u)) { const f = i[c], d = l[u] = K(f) || se(f) ? { type: f } : je({}, f), m = d.type; let x = !1, b = !0; if (K(m)) for (let E = 0; E < m.length; ++E) { const w = m[E], $ = se(w) && w.name; if ($ === "Boolean") { x = !0; break } else $ === "String" && (b = !1) } else x = se(m) && m.name === "Boolean"; d[0] = x, d[1] = b, (x || re(d, "default")) && o.push(u) } } const a = [l, o]; return de(e) && r.set(e, a), a } function Yi(e) { return e[0] !== "$" && !sn(e) } const ss = e => e[0] === "_" || e === "$stable", is = e => K(e) ? e.map(Ke) : [Ke(e)], gc = (e, t, n) => { if (t._n) return t; const r = Ya((...s) => is(t(...s)), n); return r._c = !1, r }, Qi = (e, t, n) => { const r = e._ctx; for (const s in e) { if (ss(s)) continue; const i = e[s]; if (se(i)) t[s] = gc(s, i, r); else if (i != null) { const l = is(i); t[s] = () => l } } }, Xi = (e, t) => { const n = is(t); e.slots.default = () => n }, el = (e, t, n) => { for (const r in t) (n || !ss(r)) && (e[r] = t[r]) }, mc = (e, t, n) => { const r = e.slots = Gi(); if (e.vnode.shapeFlag & 32) { const s = t.__; s && Fr(r, "__", s, !0); const i = t._; i ? (el(r, t, n), n && Fr(r, "_", i, !0)) : Qi(t, r) } else t && Xi(e, t) }, vc = (e, t, n) => { const { vnode: r, slots: s } = e; let i = !0, l = ce; if (r.shapeFlag & 32) { const o = t._; o ? n && o === 1 ? i = !1 : el(s, t, n) : (i = !t.$stable, Qi(t, s)), l = t } else t && (Xi(e, t), l = { default: 1 }); if (i) for (const o in s) !ss(o) && l[o] == null && delete s[o] }; function bc() { typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" && (ln().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1) } const Le = Lc; function yc(e) { return wc(e) } function wc(e, t) { bc(); const n = ln(); n.__VUE__ = !0; const { insert: r, remove: s, patchProp: i, createElement: l, createText: o, createComment: a, setText: c, setElementText: u, parentNode: f, nextSibling: d, setScopeId: m = $t, insertStaticContent: x } = e, b = (h, p, g, y = null, k = null, v = null, A = void 0, C = null, S = !!p.dynamicChildren) => { if (h === p) return; h && !_n(h, p) && (y = xt(h), Ue(h, k, v, !0), h = null), p.patchFlag === -2 && (S = !1, p.dynamicChildren = null); const { type: _, ref: D, shapeFlag: T } = p; switch (_) { case ar: E(h, p, g, y); break; case mt: w(h, p, g, y); break; case os: h == null && $(p, g, y, A); break; case pe: Y(h, p, g, y, k, v, A, C, S); break; default: T & 1 ? P(h, p, g, y, k, v, A, C, S) : T & 6 ? V(h, p, g, y, k, v, A, C, S) : (T & 64 || T & 128) && _.process(h, p, g, y, k, v, A, C, S, R) }D != null && k ? vn(D, h && h.ref, v, p || h, !p) : D == null && h && h.ref != null && vn(h.ref, null, v, h, !0) }, E = (h, p, g, y) => { if (h == null) r(p.el = o(p.children), g, y); else { const k = p.el = h.el; p.children !== h.children && c(k, p.children) } }, w = (h, p, g, y) => { h == null ? r(p.el = a(p.children || ""), g, y) : p.el = h.el }, $ = (h, p, g, y) => { [h.el, h.anchor] = x(h.children, p, g, y, h.el, h.anchor) }, H = ({ el: h, anchor: p }, g, y) => { let k; for (; h && h !== p;)k = d(h), r(h, g, y), h = k; r(p, g, y) }, I = ({ el: h, anchor: p }) => { let g; for (; h && h !== p;)g = d(h), s(h), h = g; s(p) }, P = (h, p, g, y, k, v, A, C, S) => { p.type === "svg" ? A = "svg" : p.type === "math" && (A = "mathml"), h == null ? W(p, g, y, k, v, A, C, S) : ke(h, p, k, v, A, C, S) }, W = (h, p, g, y, k, v, A, C) => { let S, _; const { props: D, shapeFlag: T, transition: j, dirs: B } = h; if (S = h.el = l(h.type, v, D && D.is, D), T & 8 ? u(S, h.children) : T & 16 && N(h.children, S, null, y, k, ls(h, v), A, C), B && Tt(h, null, y, "created"), Z(S, h, h.scopeId, A, y), D) { for (const oe in D) oe !== "value" && !sn(oe) && i(S, oe, null, D[oe], v, y); "value" in D && i(S, "value", null, D.value, v), (_ = D.onVnodeBeforeMount) && Ge(_, y, h) } B && Tt(h, null, y, "beforeMount"); const J = kc(k, j); J && j.beforeEnter(S), r(S, p, g), ((_ = D && D.onVnodeMounted) || J || B) && Le(() => { _ && Ge(_, y, h), J && j.enter(S), B && Tt(h, null, y, "mounted") }, k) }, Z = (h, p, g, y, k) => { if (g && m(h, g), y) for (let v = 0; v < y.length; v++)m(h, y[v]); if (k) { let v = k.subTree; if (p === v || al(v.type) && (v.ssContent === p || v.ssFallback === p)) { const A = k.vnode; Z(h, A, A.scopeId, A.slotScopeIds, k.parent) } } }, N = (h, p, g, y, k, v, A, C, S = 0) => { for (let _ = S; _ < h.length; _++) { const D = h[_] = C ? vt(h[_]) : Ke(h[_]); b(null, D, p, g, y, k, v, A, C) } }, ke = (h, p, g, y, k, v, A) => { const C = p.el = h.el; let { patchFlag: S, dynamicChildren: _, dirs: D } = p; S |= h.patchFlag & 16; const T = h.props || ce, j = p.props || ce; let B; if (g && It(g, !1), (B = j.onVnodeBeforeUpdate) && Ge(B, g, p, h), D && Tt(p, h, g, "beforeUpdate"), g && It(g, !0), (T.innerHTML && j.innerHTML == null || T.textContent && j.textContent == null) && u(C, ""), _ ? me(h.dynamicChildren, _, C, g, y, ls(p, k), v) : A || at(h, p, C, null, g, y, ls(p, k), v, !1), S > 0) { if (S & 16) U(C, T, j, g, k); else if (S & 2 && T.class !== j.class && i(C, "class", null, j.class, k), S & 4 && i(C, "style", T.style, j.style, k), S & 8) { const J = p.dynamicProps; for (let oe = 0; oe < J.length; oe++) { const fe = J[oe], Pe = T[fe], Ce = j[fe]; (Ce !== Pe || fe === "value") && i(C, fe, Pe, Ce, k, g) } } S & 1 && h.children !== p.children && u(C, p.children) } else !A && _ == null && U(C, T, j, g, k); ((B = j.onVnodeUpdated) || D) && Le(() => { B && Ge(B, g, p, h), D && Tt(p, h, g, "updated") }, y) }, me = (h, p, g, y, k, v, A) => { for (let C = 0; C < p.length; C++) { const S = h[C], _ = p[C], D = S.el && (S.type === pe || !_n(S, _) || S.shapeFlag & 198) ? f(S.el) : g; b(S, _, D, null, y, k, v, A, !0) } }, U = (h, p, g, y, k) => { if (p !== g) { if (p !== ce) for (const v in p) !sn(v) && !(v in g) && i(h, v, p[v], null, k, y); for (const v in g) { if (sn(v)) continue; const A = g[v], C = p[v]; A !== C && v !== "value" && i(h, v, C, A, k, y) } "value" in g && i(h, "value", p.value, g.value, k) } }, Y = (h, p, g, y, k, v, A, C, S) => { const _ = p.el = h ? h.el : o(""), D = p.anchor = h ? h.anchor : o(""); let { patchFlag: T, dynamicChildren: j, slotScopeIds: B } = p; B && (C = C ? C.concat(B) : B), h == null ? (r(_, g, y), r(D, g, y), N(p.children || [], g, D, k, v, A, C, S)) : T > 0 && T & 64 && j && h.dynamicChildren ? (me(h.dynamicChildren, j, g, k, v, A, C), (p.key != null || k && p === k.subTree) && tl(h, p, !0)) : at(h, p, g, D, k, v, A, C, S) }, V = (h, p, g, y, k, v, A, C, S) => { p.slotScopeIds = C, h == null ? p.shapeFlag & 512 ? k.ctx.activate(p, g, y, A, S) : F(p, g, y, k, v, A, S) : Q(h, p, S) }, F = (h, p, g, y, k, v, A) => { const C = h.component = Dc(h, y, k); if (tc(h) && (C.ctx.renderer = R), Hc(C, !1, A), C.asyncDep) { if (k && k.registerDep(C, ne, A), !h.el) { const S = C.subTree = ue(mt); w(null, S, p, g) } } else ne(C, h, p, g, k, v, A) }, Q = (h, p, g) => { const y = p.component = h.component; if (Tc(h, p, g)) if (y.asyncDep && !y.asyncResolved) { Je(y, p, g); return } else y.next = p, y.update(); else p.el = h.el, y.vnode = p }, ne = (h, p, g, y, k, v, A) => { const C = () => { if (h.isMounted) { let { next: T, bu: j, u: B, parent: J, vnode: oe } = h; { const Xt = nl(h); if (Xt) { T && (T.el = oe.el, Je(h, T, A)), Xt.asyncDep.then(() => { h.isUnmounted || C() }); return } } let fe = T, Pe; It(h, !1), T ? (T.el = oe.el, Je(h, T, A)) : T = oe, j && Bn(j), (Pe = T.props && T.props.onVnodeBeforeUpdate) && Ge(Pe, J, T, oe), It(h, !0); const Ce = ll(h), Oe = h.subTree; h.subTree = Ce, b(Oe, Ce, f(Oe.el), xt(Oe), h, k, v), T.el = Ce.el, fe === null && Ic(h, Ce.el), B && Le(B, k), (Pe = T.props && T.props.onVnodeUpdated) && Le(() => Ge(Pe, J, T, oe), k) } else { let T; const { props: j } = p, { bm: B, m: J, parent: oe, root: fe, type: Pe } = h, Ce = bn(p); It(h, !1), B && Bn(B), !Ce && (T = j && j.onVnodeBeforeMount) && Ge(T, oe, p), It(h, !0); { fe.ce && fe.ce._def.shadowRoot !== !1 && fe.ce._injectChildStyle(Pe); const Oe = h.subTree = ll(h); b(null, Oe, g, y, h, k, v), p.el = Oe.el } if (J && Le(J, k), !Ce && (T = j && j.onVnodeMounted)) { const Oe = p; Le(() => Ge(T, oe, Oe), k) } (p.shapeFlag & 256 || oe && bn(oe.vnode) && oe.vnode.shapeFlag & 256) && h.a && Le(h.a, k), h.isMounted = !0, p = g = y = null } }; h.scope.on(); const S = h.effect = new yi(C); h.scope.off(); const _ = h.update = S.run.bind(S), D = h.job = S.runIfDirty.bind(S); D.i = h, D.id = h.uid, S.scheduler = () => Yr(D), It(h, !0), _() }, Je = (h, p, g) => { p.component = h; const y = h.vnode.props; h.vnode = p, h.next = null, pc(h, p.props, y, g), vc(h, p.children, g), ut(), Ui(h), ft() }, at = (h, p, g, y, k, v, A, C, S = !1) => { const _ = h && h.children, D = h ? h.shapeFlag : 0, T = p.children, { patchFlag: j, shapeFlag: B } = p; if (j > 0) { if (j & 128) { Pn(_, T, g, y, k, v, A, C, S); return } else if (j & 256) { Qt(_, T, g, y, k, v, A, C, S); return } } B & 8 ? (D & 16 && kt(_, k, v), T !== _ && u(g, T)) : D & 16 ? B & 16 ? Pn(_, T, g, y, k, v, A, C, S) : kt(_, k, v, !0) : (D & 8 && u(g, ""), B & 16 && N(T, g, y, k, v, A, C, S)) }, Qt = (h, p, g, y, k, v, A, C, S) => { h = h || Ft, p = p || Ft; const _ = h.length, D = p.length, T = Math.min(_, D); let j; for (j = 0; j < T; j++) { const B = p[j] = S ? vt(p[j]) : Ke(p[j]); b(h[j], B, g, null, k, v, A, C, S) } _ > D ? kt(h, k, v, !0, !1, T) : N(p, g, y, k, v, A, C, S, T) }, Pn = (h, p, g, y, k, v, A, C, S) => { let _ = 0; const D = p.length; let T = h.length - 1, j = D - 1; for (; _ <= T && _ <= j;) { const B = h[_], J = p[_] = S ? vt(p[_]) : Ke(p[_]); if (_n(B, J)) b(B, J, g, null, k, v, A, C, S); else break; _++ } for (; _ <= T && _ <= j;) { const B = h[T], J = p[j] = S ? vt(p[j]) : Ke(p[j]); if (_n(B, J)) b(B, J, g, null, k, v, A, C, S); else break; T--, j-- } if (_ > T) { if (_ <= j) { const B = j + 1, J = B < D ? p[B].el : y; for (; _ <= j;)b(null, p[_] = S ? vt(p[_]) : Ke(p[_]), g, J, k, v, A, C, S), _++ } } else if (_ > j) for (; _ <= T;)Ue(h[_], k, v, !0), _++; else { const B = _, J = _, oe = new Map; for (_ = J; _ <= j; _++) { const Te = p[_] = S ? vt(p[_]) : Ke(p[_]); Te.key != null && oe.set(Te.key, _) } let fe, Pe = 0; const Ce = j - J + 1; let Oe = !1, Xt = 0; const en = new Array(Ce); for (_ = 0; _ < Ce; _++)en[_] = 0; for (_ = B; _ <= T; _++) { const Te = h[_]; if (Pe >= Ce) { Ue(Te, k, v, !0); continue } let Ve; if (Te.key != null) Ve = oe.get(Te.key); else for (fe = J; fe <= j; fe++)if (en[fe - J] === 0 && _n(Te, p[fe])) { Ve = fe; break } Ve === void 0 ? Ue(Te, k, v, !0) : (en[Ve - J] = _ + 1, Ve >= Xt ? Xt = Ve : Oe = !0, b(Te, p[Ve], g, null, k, v, A, C, S), Pe++) } const Ms = Oe ? xc(en) : Ft; for (fe = Ms.length - 1, _ = Ce - 1; _ >= 0; _--) { const Te = J + _, Ve = p[Te], Ps = Te + 1 < D ? p[Te + 1].el : y; en[_] === 0 ? b(null, Ve, g, Ps, k, v, A, C, S) : Oe && (fe < 0 || _ !== Ms[fe] ? Ot(Ve, g, Ps, 2) : fe--) } } }, Ot = (h, p, g, y, k = null) => { const { el: v, type: A, transition: C, children: S, shapeFlag: _ } = h; if (_ & 6) { Ot(h.component.subTree, p, g, y); return } if (_ & 128) { h.suspense.move(p, g, y); return } if (_ & 64) { A.move(h, p, g, R); return } if (A === pe) { r(v, p, g); for (let T = 0; T < S.length; T++)Ot(S[T], p, g, y); r(h.anchor, p, g); return } if (A === os) { H(h, p, g); return } if (y !== 2 && _ & 1 && C) if (y === 0) C.beforeEnter(v), r(v, p, g), Le(() => C.enter(v), k); else { const { leave: T, delayLeave: j, afterLeave: B } = C, J = () => { h.ctx.isUnmounted ? s(v) : r(v, p, g) }, oe = () => { T(v, () => { J(), B && B() }) }; j ? j(v, J, oe) : oe() } else r(v, p, g) }, Ue = (h, p, g, y = !1, k = !1) => { const { type: v, props: A, ref: C, children: S, dynamicChildren: _, shapeFlag: D, patchFlag: T, dirs: j, cacheIndex: B } = h; if (T === -2 && (k = !1), C != null && (ut(), vn(C, null, g, h, !0), ft()), B != null && (p.renderCache[B] = void 0), D & 256) { p.ctx.deactivate(h); return } const J = D & 1 && j, oe = !bn(h); let fe; if (oe && (fe = A && A.onVnodeBeforeUnmount) && Ge(fe, p, h), D & 6) jn(h.component, g, y); else { if (D & 128) { h.suspense.unmount(g, y); return } J && Tt(h, null, p, "beforeUnmount"), D & 64 ? h.type.remove(h, p, g, R, y) : _ && !_.hasOnce && (v !== pe || T > 0 && T & 64) ? kt(_, p, g, !1, !0) : (v === pe && T & 384 || !k && D & 16) && kt(S, p, g), y && On(h) } (oe && (fe = A && A.onVnodeUnmounted) || J) && Le(() => { fe && Ge(fe, p, h), J && Tt(h, null, p, "unmounted") }, g) }, On = h => { const { type: p, el: g, anchor: y, transition: k } = h; if (p === pe) { Er(g, y); return } if (p === os) { I(h); return } const v = () => { s(g), k && !k.persisted && k.afterLeave && k.afterLeave() }; if (h.shapeFlag & 1 && k && !k.persisted) { const { leave: A, delayLeave: C } = k, S = () => A(g, v); C ? C(h.el, v, S) : S() } else v() }, Er = (h, p) => { let g; for (; h !== p;)g = d(h), s(h), h = g; s(p) }, jn = (h, p, g) => { const { bum: y, scope: k, job: v, subTree: A, um: C, m: S, a: _, parent: D, slots: { __: T } } = h; rl(S), rl(_), y && Bn(y), D && K(T) && T.forEach(j => { D.renderCache[j] = void 0 }), k.stop(), v && (v.flags |= 8, Ue(A, h, p, g)), C && Le(C, p), Le(() => { h.isUnmounted = !0 }, p), p && p.pendingBranch && !p.isUnmounted && h.asyncDep && !h.asyncResolved && h.suspenseId === p.pendingId && (p.deps--, p.deps === 0 && p.resolve()) }, kt = (h, p, g, y = !1, k = !1, v = 0) => { for (let A = v; A < h.length; A++)Ue(h[A], p, g, y, k) }, xt = h => { if (h.shapeFlag & 6) return xt(h.component.subTree); if (h.shapeFlag & 128) return h.suspense.next(); const p = d(h.anchor || h.el), g = p && p[Qa]; return g ? d(g) : p }; let jt = !1; const O = (h, p, g) => { h == null ? p._vnode && Ue(p._vnode, null, null, !0) : b(p._vnode || null, h, p, null, null, null, g), p._vnode = h, jt || (jt = !0, Ui(), Ni(), jt = !1) }, R = { p: b, um: Ue, m: Ot, r: On, mt: F, mc: N, pc: at, pbc: me, n: xt, o: e }; return { render: O, hydrate: void 0, createApp: uc(O) } } function ls({ type: e, props: t }, n) { return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n } function It({ effect: e, job: t }, n) { n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function kc(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function tl(e, t, n = !1) { const r = e.children, s = t.children; if (K(r) && K(s)) for (let i = 0; i < r.length; i++) { const l = r[i]; let o = s[i]; o.shapeFlag & 1 && !o.dynamicChildren && ((o.patchFlag <= 0 || o.patchFlag === 32) && (o = s[i] = vt(s[i]), o.el = l.el), !n && o.patchFlag !== -2 && tl(l, o)), o.type === ar && (o.el = l.el), o.type === mt && !o.el && (o.el = l.el) } } function xc(e) { const t = e.slice(), n = [0]; let r, s, i, l, o; const a = e.length; for (r = 0; r < a; r++) { const c = e[r]; if (c !== 0) { if (s = n[n.length - 1], e[s] < c) { t[r] = s, n.push(r); continue } for (i = 0, l = n.length - 1; i < l;)o = i + l >> 1, e[n[o]] < c ? i = o + 1 : l = o; c < e[n[i]] && (i > 0 && (t[r] = n[i - 1]), n[i] = r) } } for (i = n.length, l = n[i - 1]; i-- > 0;)n[i] = l, l = t[l]; return n } function nl(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : nl(t) } function rl(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } const _c = Symbol.for("v-scx"), $c = () => lr(_c); function sl(e, t) { return il(e, null, t) } function gt(e, t, n) { return il(e, t, n) } function il(e, t, n = ce) { const { immediate: r, flush: s } = n, i = je({}, n), l = t && r || !t && s !== "post"; let o; if ($n) { if (s === "sync") { const f = $c(); o = f.__watcherHandles || (f.__watcherHandles = []) } else if (!l) { const f = () => { }; return f.stop = $t, f.resume = $t, f.pause = $t, f } } const a = Re; i.call = (f, d, m) => tt(f, a, d, m); let c = !1; s === "post" ? i.scheduler = f => { Le(f, a && a.suspense) } : s !== "sync" && (c = !0, i.scheduler = (f, d) => { d ? f() : Yr(f) }), i.augmentJob = f => { t && (f.flags |= 4), c && (f.flags |= 2, a && (f.id = a.uid, f.i = a)) }; const u = Ka(e, t, i); return $n && (o ? o.push(u) : l && u()), u } const Cc = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${ze(t)}Modifiers`] || e[`${Ct(t)}Modifiers`]; function Sc(e, t, ...n) { if (e.isUnmounted) return; const r = e.vnode.props || ce; let s = n; const i = t.startsWith("update:"), l = i && Cc(r, t.slice(7)); l && (l.trim && (s = n.map(u => we(u) ? u.trim() : u)), l.number && (s = n.map(Wn))); let o, a = r[o = zr(t)] || r[o = zr(ze(t))]; !a && i && (a = r[o = zr(Ct(t))]), a && tt(a, e, 6, s); const c = r[o + "Once"]; if (c) { if (!e.emitted) e.emitted = {}; else if (e.emitted[o]) return; e.emitted[o] = !0, tt(c, e, 6, s) } } function Rc(e, t, n = !1) { const r = t.emitsCache, s = r.get(e); if (s !== void 0) return s; const i = e.emits; let l = {}; return i ? (K(i) ? i.forEach(o => l[o] = null) : je(l, i), de(e) && r.set(e, l), l) : (de(e) && r.set(e, null), null) } function or(e, t) { return !e || !Un(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), re(e, t[0].toLowerCase() + t.slice(1)) || re(e, Ct(t)) || re(e, t)) } function ll(e) { const { type: t, vnode: n, proxy: r, withProxy: s, propsOptions: [i], slots: l, attrs: o, emit: a, render: c, renderCache: u, props: f, data: d, setupState: m, ctx: x, inheritAttrs: b } = e, E = sr(e); let w, $; try { if (n.shapeFlag & 4) { const I = s || r, P = I; w = Ke(c.call(P, I, u, f, m, d, x)), $ = o } else { const I = t; w = Ke(I.length > 1 ? I(f, { attrs: o, slots: l, emit: a }) : I(f, null)), $ = t.props ? o : Ac(o) } } catch (I) { kn.length = 0, nr(I, e, 1), w = ue(mt) } let H = w; if ($ && b !== !1) { const I = Object.keys($), { shapeFlag: P } = H; I.length && P & 7 && (i && I.some(Or) && ($ = Ec($, i)), H = Gt(H, $, !1, !0)) } return n.dirs && (H = Gt(H, null, !1, !0), H.dirs = H.dirs ? H.dirs.concat(n.dirs) : n.dirs), n.transition && Qr(H, n.transition), w = H, sr(E), w } const Ac = e => { let t; for (const n in e) (n === "class" || n === "style" || Un(n)) && ((t || (t = {}))[n] = e[n]); return t }, Ec = (e, t) => { const n = {}; for (const r in e) (!Or(r) || !(r.slice(9) in t)) && (n[r] = e[r]); return n }; function Tc(e, t, n) { const { props: r, children: s, component: i } = e, { props: l, children: o, patchFlag: a } = t, c = i.emitsOptions; if (t.dirs || t.transition) return !0; if (n && a >= 0) { if (a & 1024) return !0; if (a & 16) return r ? ol(r, l, c) : !!l; if (a & 8) { const u = t.dynamicProps; for (let f = 0; f < u.length; f++) { const d = u[f]; if (l[d] !== r[d] && !or(c, d)) return !0 } } } else return (s || o) && (!o || !o.$stable) ? !0 : r === l ? !1 : r ? l ? ol(r, l, c) : !0 : !!l; return !1 } function ol(e, t, n) { const r = Object.keys(t); if (r.length !== Object.keys(e).length) return !0; for (let s = 0; s < r.length; s++) { const i = r[s]; if (t[i] !== e[i] && !or(n, i)) return !0 } return !1 } function Ic({ vnode: e, parent: t }, n) { for (; t;) { const r = t.subTree; if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el), r === e) (e = t.vnode).el = n, t = t.parent; else break } } const al = e => e.__isSuspense; function Lc(e, t) { t && t.pendingBranch ? K(e) ? t.effects.push(...e) : t.effects.push(e) : Ja(e) } const pe = Symbol.for("v-fgt"), ar = Symbol.for("v-txt"), mt = Symbol.for("v-cmt"), os = Symbol.for("v-stc"), kn = []; let Me = null; function L(e = !1) { kn.push(Me = e ? null : []) } function Mc() { kn.pop(), Me = kn[kn.length - 1] || null } let xn = 1; function cl(e, t = !1) { xn += e, e < 0 && Me && t && (Me.hasOnce = !0) } function ul(e) { return e.dynamicChildren = xn > 0 ? Me || Ft : null, Mc(), xn > 0 && Me && Me.push(e), e } function M(e, t, n, r, s, i) { return ul(z(e, t, n, r, s, i, !0)) } function nt(e, t, n, r, s) { return ul(ue(e, t, n, r, s, !0)) } function cr(e) { return e ? e.__v_isVNode === !0 : !1 } function _n(e, t) { return e.type === t.type && e.key === t.key } const fl = ({ key: e }) => e ?? null, ur = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? we(e) || ye(e) || se(e) ? { i: Ee, r: e, k: t, f: !!n } : e : null); function z(e, t = null, n = null, r = 0, s = null, i = e === pe ? 0 : 1, l = !1, o = !1) { const a = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && fl(t), ref: t && ur(t), scopeId: Bi, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: i, patchFlag: r, dynamicProps: s, dynamicChildren: null, appContext: null, ctx: Ee }; return o ? (as(a, n), i & 128 && e.normalize(a)) : n && (a.shapeFlag |= we(n) ? 8 : 16), xn > 0 && !l && Me && (a.patchFlag > 0 || i & 6) && a.patchFlag !== 32 && Me.push(a), a } const ue = Pc; function Pc(e, t = null, n = null, r = 0, s = null, i = !1) { if ((!e || e === lc) && (e = mt), cr(e)) { const o = Gt(e, t, !0); return n && as(o, n), xn > 0 && !i && Me && (o.shapeFlag & 6 ? Me[Me.indexOf(e)] = o : Me.push(o)), o.patchFlag = -2, o } if (Wc(e) && (e = e.__vccOpts), t) { t = Oc(t); let { class: o, style: a } = t; o && !we(o) && (t.class = be(o)), de(a) && (Jr(a) && !K(a) && (a = je({}, a)), t.style = on(a)) } const l = we(e) ? 1 : al(e) ? 128 : Xa(e) ? 64 : de(e) ? 4 : se(e) ? 2 : 0; return z(e, t, n, r, s, l, i, !0) } function Oc(e) { return e ? Jr(e) || Zi(e) ? je({}, e) : e : null } function Gt(e, t, n = !1, r = !1) { const { props: s, ref: i, patchFlag: l, children: o, transition: a } = e, c = t ? jc(s || {}, t) : s, u = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: c, key: c && fl(c), ref: t && t.ref ? n && i ? K(i) ? i.concat(ur(t)) : [i, ur(t)] : ur(t) : i, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: o, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== pe ? l === -1 ? 16 : l | 16 : l, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: a, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Gt(e.ssContent), ssFallback: e.ssFallback && Gt(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return a && r && Qr(u, a.clone(u)), u } function rt(e = " ", t = 0) { return ue(ar, null, e, t) } function X(e = "", t = !1) { return t ? (L(), nt(mt, null, e)) : ue(mt, null, e) } function Ke(e) { return e == null || typeof e == "boolean" ? ue(mt) : K(e) ? ue(pe, null, e.slice()) : cr(e) ? vt(e) : ue(ar, null, String(e)) } function vt(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Gt(e) } function as(e, t) { let n = 0; const { shapeFlag: r } = e; if (t == null) t = null; else if (K(t)) n = 16; else if (typeof t == "object") if (r & 65) { const s = t.default; s && (s._c && (s._d = !1), as(e, s()), s._c && (s._d = !0)); return } else { n = 32; const s = t._; !s && !Zi(t) ? t._ctx = Ee : s === 3 && Ee && (Ee.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else se(t) ? (t = { default: t, _ctx: Ee }, n = 32) : (t = String(t), r & 64 ? (n = 16, t = [rt(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function jc(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n]; for (const s in r) if (s === "class") t.class !== r.class && (t.class = be([t.class, r.class])); else if (s === "style") t.style = on([t.style, r.style]); else if (Un(s)) { const i = t[s], l = r[s]; l && i !== l && !(K(i) && i.includes(l)) && (t[s] = i ? [].concat(i, l) : l) } else s !== "" && (t[s] = r[s]) } return t } function Ge(e, t, n, r = null) { tt(e, t, 7, [n, r]) } const zc = qi(); let Fc = 0; function Dc(e, t, n) { const r = e.type, s = (t ? t.appContext : e.appContext) || zc, i = { uid: Fc++, vnode: e, type: r, parent: t, appContext: s, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new ha(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(s.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: dc(r, s), emitsOptions: Rc(r, s), emit: null, emitted: null, propsDefaults: ce, inheritAttrs: r.inheritAttrs, ctx: ce, data: ce, props: ce, attrs: ce, slots: ce, refs: ce, setupState: ce, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return i.ctx = { _: i }, i.root = t ? t.root : i, i.emit = Sc.bind(null, i), e.ce && e.ce(i), i } let Re = null; const hl = () => Re || Ee; let fr, cs; { const e = ln(), t = (n, r) => { let s; return (s = e[n]) || (s = e[n] = []), s.push(r), i => { s.length > 1 ? s.forEach(l => l(i)) : s[0](i) } }; fr = t("__VUE_INSTANCE_SETTERS__", n => Re = n), cs = t("__VUE_SSR_SETTERS__", n => $n = n) } const us = e => { const t = Re; return fr(e), e.scope.on(), () => { e.scope.off(), fr(t) } }, pl = () => { Re && Re.scope.off(), fr(null) }; function dl(e) { return e.vnode.shapeFlag & 4 } let $n = !1; function Hc(e, t = !1, n = !1) { t && cs(t); const { props: r, children: s } = e.vnode, i = dl(e); hc(e, r, i, t), mc(e, s, n || t); const l = i ? Uc(e, t) : void 0; return t && cs(!1), l } function Uc(e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, ac); const { setup: r } = n; if (r) { ut(); const s = e.setupContext = r.length > 1 ? Vc(e) : null, i = us(e), l = dn(r, e, 0, [e.props, s]), o = fi(l); if (ft(), i(), (o || e.sp) && !bn(e) && ec(e), o) { if (l.then(pl, pl), t) return l.then(a => { gl(e, a, t) }).catch(a => { nr(a, e, 0) }); e.asyncDep = l } else gl(e, l, t) } else vl(e, t) } function gl(e, t, n) { se(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : de(t) && (e.setupState = Fi(t)), vl(e, n) } let ml; function vl(e, t, n) { const r = e.type; if (!e.render) { if (!t && ml && !r.render) { const s = r.template || !1; if (s) { const { isCustomElement: i, compilerOptions: l } = e.appContext.config, { delimiters: o, compilerOptions: a } = r, c = je(je({ isCustomElement: i, delimiters: o }, l), a); r.render = ml(s, c) } } e.render = r.render || $t } } const Nc = { get(e, t) { return $e(e, "get", ""), e[t] } }; function Vc(e) { const t = n => { e.exposed = n || {} }; return { attrs: new Proxy(e.attrs, Nc), slots: e.slots, emit: e.emit, expose: t } } function hr(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Fi(Oa(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in wn) return wn[n](e) }, has(t, n) { return n in t || n in wn } })) : e.proxy } function Bc(e, t = !0) { return se(e) ? e.displayName || e.name : e.name || t && e.__name } function Wc(e) { return se(e) && "__vccOpts" in e } const ve = (e, t) => Wa(e, t, $n); function ie(e, t, n) { const r = arguments.length; return r === 2 ? de(t) && !K(t) ? cr(t) ? ue(e, null, [t]) : ue(e, t) : ue(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && cr(n) && (n = [n]), ue(e, t, n)) } const qc = "3.5.17";/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let fs; const bl = typeof window < "u" && window.trustedTypes; if (bl) try { fs = bl.createPolicy("vue", { createHTML: e => e }) } catch { } const yl = fs ? e => fs.createHTML(e) : e => e, Kc = "http://www.w3.org/2000/svg", Gc = "http://www.w3.org/1998/Math/MathML", st = typeof document < "u" ? document : null, wl = st && st.createElement("template"), Zc = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, r) => { const s = t === "svg" ? st.createElementNS(Kc, e) : t === "mathml" ? st.createElementNS(Gc, e) : n ? st.createElement(e, { is: n }) : st.createElement(e); return e === "select" && r && r.multiple != null && s.setAttribute("multiple", r.multiple), s }, createText: e => st.createTextNode(e), createComment: e => st.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => st.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, r, s, i) { const l = n ? n.previousSibling : t.lastChild; if (s && (s === i || s.nextSibling)) for (; t.insertBefore(s.cloneNode(!0), n), !(s === i || !(s = s.nextSibling));); else { wl.innerHTML = yl(r === "svg" ? `<svg>${e}</svg>` : r === "mathml" ? `<math>${e}</math>` : e); const o = wl.content; if (r === "svg" || r === "mathml") { const a = o.firstChild; for (; a.firstChild;)o.appendChild(a.firstChild); o.removeChild(a) } t.insertBefore(o, n) } return [l ? l.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }, Jc = Symbol("_vtc"); function Yc(e, t, n) { const r = e[Jc]; r && (t = (t ? [t, ...r] : [...r]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } const pr = Symbol("_vod"), kl = Symbol("_vsh"), xl = { beforeMount(e, { value: t }, { transition: n }) { e[pr] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Cn(e, t) }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e) }, updated(e, { value: t, oldValue: n }, { transition: r }) { !t != !n && (r ? t ? (r.beforeEnter(e), Cn(e, !0), r.enter(e)) : r.leave(e, () => { Cn(e, !1) }) : Cn(e, t)) }, beforeUnmount(e, { value: t }) { Cn(e, t) } }; function Cn(e, t) { e.style.display = t ? e[pr] : "none", e[kl] = !t } const Qc = Symbol(""), Xc = /(^|;)\s*display\s*:/; function eu(e, t, n) { const r = e.style, s = we(n); let i = !1; if (n && !s) { if (t) if (we(t)) for (const l of t.split(";")) { const o = l.slice(0, l.indexOf(":")).trim(); n[o] == null && dr(r, o, "") } else for (const l in t) n[l] == null && dr(r, l, ""); for (const l in n) l === "display" && (i = !0), dr(r, l, n[l]) } else if (s) { if (t !== n) { const l = r[Qc]; l && (n += ";" + l), r.cssText = n, i = Xc.test(n) } } else t && e.removeAttribute("style"); pr in e && (e[pr] = i ? r.display : "", e[kl] && (r.display = "none")) } const _l = /\s*!important$/; function dr(e, t, n) { if (K(n)) n.forEach(r => dr(e, t, r)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { const r = tu(e, t); _l.test(n) ? e.setProperty(Ct(r), n.replace(_l, ""), "important") : e[r] = n } } const $l = ["Webkit", "Moz", "ms"], hs = {}; function tu(e, t) { const n = hs[t]; if (n) return n; let r = ze(t); if (r !== "filter" && r in e) return hs[t] = r; r = Vn(r); for (let s = 0; s < $l.length; s++) { const i = $l[s] + r; if (i in e) return hs[t] = i } return t } const Cl = "http://www.w3.org/1999/xlink"; function Sl(e, t, n, r, s, i = ua(t)) { r && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(Cl, t.slice(6, t.length)) : e.setAttributeNS(Cl, t, n) : n == null || i && !gi(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : We(n) ? String(n) : n) } function Rl(e, t, n, r, s) { if (t === "innerHTML" || t === "textContent") { n != null && (e[t] = t === "innerHTML" ? yl(n) : n); return } const i = e.tagName; if (t === "value" && i !== "PROGRESS" && !i.includes("-")) { const o = i === "OPTION" ? e.getAttribute("value") || "" : e.value, a = n == null ? e.type === "checkbox" ? "on" : "" : String(n); (o !== a || !("_value" in e)) && (e.value = a), n == null && e.removeAttribute(t), e._value = n; return } let l = !1; if (n === "" || n == null) { const o = typeof e[t]; o === "boolean" ? n = gi(n) : n == null && o === "string" ? (n = "", l = !0) : o === "number" && (n = 0, l = !0) } try { e[t] = n } catch { } l && e.removeAttribute(s || t) } function it(e, t, n, r) { e.addEventListener(t, n, r) } function nu(e, t, n, r) { e.removeEventListener(t, n, r) } const Al = Symbol("_vei"); function ru(e, t, n, r, s = null) { const i = e[Al] || (e[Al] = {}), l = i[t]; if (r && l) l.value = r; else { const [o, a] = su(t); if (r) { const c = i[t] = ou(r, s); it(e, o, c, a) } else l && (nu(e, o, l, a), i[t] = void 0) } } const El = /(?:Once|Passive|Capture)$/; function su(e) { let t; if (El.test(e)) { t = {}; let r; for (; r = e.match(El);)e = e.slice(0, e.length - r[0].length), t[r[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : Ct(e.slice(2)), t] } let ps = 0; const iu = Promise.resolve(), lu = () => ps || (iu.then(() => ps = 0), ps = Date.now()); function ou(e, t) { const n = r => { if (!r._vts) r._vts = Date.now(); else if (r._vts <= n.attached) return; tt(au(r, n.value), t, 5, [r]) }; return n.value = e, n.attached = lu(), n } function au(e, t) { if (K(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(r => s => !s._stopped && r && r(s)) } else return t } const Tl = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, cu = (e, t, n, r, s, i) => { const l = s === "svg"; t === "class" ? Yc(e, r, l) : t === "style" ? eu(e, n, r) : Un(t) ? Or(t) || ru(e, t, n, r, i) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : uu(e, t, r, l)) ? (Rl(e, t, r), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && Sl(e, t, r, l, i, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !we(r)) ? Rl(e, ze(t), r, i, t) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r), Sl(e, t, r, l)) }; function uu(e, t, n, r) { if (r) return !!(t === "innerHTML" || t === "textContent" || t in e && Tl(t) && se(n)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const s = e.tagName; if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE") return !1 } return Tl(t) && we(n) ? !1 : t in e } const bt = e => { const t = e.props["onUpdate:modelValue"] || !1; return K(t) ? n => Bn(t, n) : t }; function fu(e) { e.target.composing = !0 } function Il(e) { const t = e.target; t.composing && (t.composing = !1, t.dispatchEvent(new Event("input"))) } const He = Symbol("_assign"), ds = { created(e, { modifiers: { lazy: t, trim: n, number: r } }, s) { e[He] = bt(s); const i = r || s.props && s.props.type === "number"; it(e, t ? "change" : "input", l => { if (l.target.composing) return; let o = e.value; n && (o = o.trim()), i && (o = Wn(o)), e[He](o) }), n && it(e, "change", () => { e.value = e.value.trim() }), t || (it(e, "compositionstart", fu), it(e, "compositionend", Il), it(e, "change", Il)) }, mounted(e, { value: t }) { e.value = t ?? "" }, beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: r, trim: s, number: i } }, l) { if (e[He] = bt(l), e.composing) return; const o = (i || e.type === "number") && !/^0\d/.test(e.value) ? Wn(e.value) : e.value, a = t ?? ""; o !== a && (document.activeElement === e && e.type !== "range" && (r && t === n || s && e.value.trim() === a) || (e.value = a)) } }, hu = { deep: !0, created(e, t, n) { e[He] = bt(n), it(e, "change", () => { const r = e._modelValue, s = Zt(e), i = e.checked, l = e[He]; if (K(r)) { const o = Dr(r, s), a = o !== -1; if (i && !a) l(r.concat(s)); else if (!i && a) { const c = [...r]; c.splice(o, 1), l(c) } } else if (Ht(r)) { const o = new Set(r); i ? o.add(s) : o.delete(s), l(o) } else l(Pl(e, i)) }) }, mounted: Ll, beforeUpdate(e, t, n) { e[He] = bt(n), Ll(e, t, n) } }; function Ll(e, { value: t, oldValue: n }, r) { e._modelValue = t; let s; if (K(t)) s = Dr(t, r.props.value) > -1; else if (Ht(t)) s = t.has(r.props.value); else { if (t === n) return; s = St(t, Pl(e, !0)) } e.checked !== s && (e.checked = s) } const pu = { created(e, { value: t }, n) { e.checked = St(t, n.props.value), e[He] = bt(n), it(e, "change", () => { e[He](Zt(e)) }) }, beforeUpdate(e, { value: t, oldValue: n }, r) { e[He] = bt(r), t !== n && (e.checked = St(t, r.props.value)) } }, du = { deep: !0, created(e, { value: t, modifiers: { number: n } }, r) { const s = Ht(t); it(e, "change", () => { const i = Array.prototype.filter.call(e.options, l => l.selected).map(l => n ? Wn(Zt(l)) : Zt(l)); e[He](e.multiple ? s ? new Set(i) : i : i[0]), e._assigning = !0, qt(() => { e._assigning = !1 }) }), e[He] = bt(r) }, mounted(e, { value: t }) { Ml(e, t) }, beforeUpdate(e, t, n) { e[He] = bt(n) }, updated(e, { value: t }) { e._assigning || Ml(e, t) } }; function Ml(e, t) { const n = e.multiple, r = K(t); if (!(n && !r && !Ht(t))) { for (let s = 0, i = e.options.length; s < i; s++) { const l = e.options[s], o = Zt(l); if (n) if (r) { const a = typeof o; a === "string" || a === "number" ? l.selected = t.some(c => String(c) === String(o)) : l.selected = Dr(t, o) > -1 } else l.selected = t.has(o); else if (St(Zt(l), t)) { e.selectedIndex !== s && (e.selectedIndex = s); return } } !n && e.selectedIndex !== -1 && (e.selectedIndex = -1) } } function Zt(e) { return "_value" in e ? e._value : e.value } function Pl(e, t) { const n = t ? "_trueValue" : "_falseValue"; return n in e ? e[n] : t } const gu = { created(e, t, n) { gr(e, t, n, null, "created") }, mounted(e, t, n) { gr(e, t, n, null, "mounted") }, beforeUpdate(e, t, n, r) { gr(e, t, n, r, "beforeUpdate") }, updated(e, t, n, r) { gr(e, t, n, r, "updated") } }; function mu(e, t) { switch (e) { case "SELECT": return du; case "TEXTAREA": return ds; default: switch (t) { case "checkbox": return hu; case "radio": return pu; default: return ds } } } function gr(e, t, n, r, s) { const l = mu(e.tagName, n.props && n.props.type)[s]; l && l(e, t, n, r) } const vu = je({ patchProp: cu }, Zc); let Ol; function bu() { return Ol || (Ol = yc(vu)) } const yu = (...e) => { const t = bu().createApp(...e), { mount: n } = t; return t.mount = r => { const s = ku(r); if (!s) return; const i = t._component; !se(i) && !i.render && !i.template && (i.template = s.innerHTML), s.nodeType === 1 && (s.textContent = ""); const l = n(s, !1, wu(s)); return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), l }, t }; function wu(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function ku(e) { return we(e) ? document.querySelector(e) : e } function Sn(e) { return bi() ? (pa(e), !0) : !1 } const mr = typeof window < "u" && typeof document < "u", xu = Object.prototype.toString, _u = e => xu.call(e) === "[object Object]", vr = () => { }; function $u(...e) { if (e.length !== 1) return Na(...e); const t = e[0]; return typeof t == "function" ? Nt(Da(() => ({ get: t, set: vr }))) : ae(t) } function jl(e, t) { function n(...r) { return new Promise((s, i) => { Promise.resolve(e(() => t.apply(this, r), { fn: t, thisArg: this, args: r })).then(s).catch(i) }) } return n } const zl = e => e(); function Cu(e, t = {}) { let n, r, s = vr; const i = a => { clearTimeout(a), s(), s = vr }; let l; return a => { const c = Ie(e), u = Ie(t.maxWait); return n && i(n), c <= 0 || u !== void 0 && u <= 0 ? (r && (i(r), r = void 0), Promise.resolve(a())) : new Promise((f, d) => { s = t.rejectOnCancel ? d : f, l = a, u && !r && (r = setTimeout(() => { n && i(n), r = void 0, f(l()) }, u)), n = setTimeout(() => { r && i(r), r = void 0, f(a()) }, c) }) } } function Su(e = zl, t = {}) { const { initialState: n = "active" } = t, r = $u(n === "active"); function s() { r.value = !1 } function i() { r.value = !0 } const l = (...o) => { r.value && e(...o) }; return { isActive: Nt(r), pause: s, resume: i, eventFilter: l } } function gs(e) { return Array.isArray(e) ? e : [e] } function Fl(e) { return hl() } function Ru(e, t = 200, n = {}) { return jl(Cu(t, n), e) } function Au(e, t, n = {}) { const { eventFilter: r = zl, ...s } = n; return gt(e, jl(r, t), s) } function Eu(e, t, n = {}) { const { eventFilter: r, initialState: s = "active", ...i } = n, { eventFilter: l, pause: o, resume: a, isActive: c } = Su(r, { initialState: s }); return { stop: Au(e, t, { ...i, eventFilter: l }), pause: o, resume: a, isActive: c } } function ms(e, t = !0, n) { Fl() ? yn(e, n) : t ? e() : qt(e) } function Tu(e, t) { Fl() && es(e, t) } function Iu(e, t = 1e3, n = {}) { const { immediate: r = !0, immediateCallback: s = !1 } = n; let i = null; const l = At(!1); function o() { i && (clearInterval(i), i = null) } function a() { l.value = !1, o() } function c() { const u = Ie(t); u <= 0 || (l.value = !0, s && e(), o(), l.value && (i = setInterval(e, u))) } if (r && mr && c(), ye(t) || typeof t == "function") { const u = gt(t, () => { l.value && mr && c() }); Sn(u) } return Sn(a), { isActive: Pa(l), pause: a, resume: c } } function Jt(e, t, n) { return gt(e, t, { ...n, immediate: !0 }) } const br = mr ? window : void 0, Dl = mr ? window.document : void 0; function Lu(e) { var t; const n = Ie(e); return (t = n == null ? void 0 : n.$el) != null ? t : n } function Lt(...e) { const t = [], n = () => { t.forEach(o => o()), t.length = 0 }, r = (o, a, c, u) => (o.addEventListener(a, c, u), () => o.removeEventListener(a, c, u)), s = ve(() => { const o = gs(Ie(e[0])).filter(a => a != null); return o.every(a => typeof a != "string") ? o : void 0 }), i = Jt(() => { var o, a; return [(a = (o = s.value) == null ? void 0 : o.map(c => Lu(c))) != null ? a : [br].filter(c => c != null), gs(Ie(s.value ? e[1] : e[0])), gs(G(s.value ? e[2] : e[1])), Ie(s.value ? e[3] : e[2])] }, ([o, a, c, u]) => { if (n(), !(o != null && o.length) || !(a != null && a.length) || !(c != null && c.length)) return; const f = _u(u) ? { ...u } : u; t.push(...o.flatMap(d => a.flatMap(m => c.map(x => r(d, m, x, f))))) }, { flush: "post" }), l = () => { i(), n() }; return Sn(n), l } function Mu(e, t = {}) { const { immediate: n = !0, fpsLimit: r = void 0, window: s = br, once: i = !1 } = t, l = At(!1), o = ve(() => r ? 1e3 / Ie(r) : null); let a = 0, c = null; function u(m) { if (!l.value || !s) return; a || (a = m); const x = m - a; if (o.value && x < o.value) { c = s.requestAnimationFrame(u); return } if (a = m, e({ delta: x, timestamp: m }), i) { l.value = !1, c = null; return } c = s.requestAnimationFrame(u) } function f() { !l.value && s && (l.value = !0, a = 0, c = s.requestAnimationFrame(u)) } function d() { l.value = !1, c != null && s && (s.cancelAnimationFrame(c), c = null) } return n && f(), Sn(d), { isActive: Nt(l), pause: d, resume: f } } const yr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, wr = "__vueuse_ssr_handlers__", Pu = Ou(); function Ou() { return wr in yr || (yr[wr] = yr[wr] || {}), yr[wr] } function ju(e, t) { return Pu[e] || t } function zu(e) { return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number" } const Fu = { boolean: { read: e => e === "true", write: e => String(e) }, object: { read: e => JSON.parse(e), write: e => JSON.stringify(e) }, number: { read: e => Number.parseFloat(e), write: e => String(e) }, any: { read: e => e, write: e => String(e) }, string: { read: e => e, write: e => String(e) }, map: { read: e => new Map(JSON.parse(e)), write: e => JSON.stringify(Array.from(e.entries())) }, set: { read: e => new Set(JSON.parse(e)), write: e => JSON.stringify(Array.from(e)) }, date: { read: e => new Date(e), write: e => e.toISOString() } }, Hl = "vueuse-storage"; function Yt(e, t, n, r = {}) { var s; const { flush: i = "pre", deep: l = !0, listenToStorageChanges: o = !0, writeDefaults: a = !0, mergeDefaults: c = !1, shallow: u, window: f = br, eventFilter: d, onError: m = F => { console.error(F) }, initOnMounted: x } = r, b = (u ? At : ae)(typeof t == "function" ? t() : t), E = ve(() => Ie(e)); if (!n) try { n = ju("getDefaultStorage", () => { var F; return (F = br) == null ? void 0 : F.localStorage })() } catch (F) { m(F) } if (!n) return b; const w = Ie(t), $ = zu(w), H = (s = r.serializer) != null ? s : Fu[$], { pause: I, resume: P } = Eu(b, () => me(b.value), { flush: i, deep: l, eventFilter: d }); gt(E, () => Y(), { flush: i }); let W = !1; const Z = F => { x && !W || Y(F) }, N = F => { x && !W || V(F) }; f && o && (n instanceof Storage ? Lt(f, "storage", Z, { passive: !0 }) : Lt(f, Hl, N)), x ? ms(() => { W = !0, Y() }) : Y(); function ke(F, Q) { if (f) { const ne = { key: E.value, oldValue: F, newValue: Q, storageArea: n }; f.dispatchEvent(n instanceof Storage ? new StorageEvent("storage", ne) : new CustomEvent(Hl, { detail: ne })) } } function me(F) { try { const Q = n.getItem(E.value); if (F == null) ke(Q, null), n.removeItem(E.value); else { const ne = H.write(F); Q !== ne && (n.setItem(E.value, ne), ke(Q, ne)) } } catch (Q) { m(Q) } } function U(F) { const Q = F ? F.newValue : n.getItem(E.value); if (Q == null) return a && w != null && n.setItem(E.value, H.write(w)), w; if (!F && c) { const ne = H.read(Q); return typeof c == "function" ? c(ne, w) : $ === "object" && !Array.isArray(ne) ? { ...w, ...ne } : ne } else return typeof Q != "string" ? Q : H.read(Q) } function Y(F) { if (!(F && F.storageArea !== n)) { if (F && F.key == null) { b.value = w; return } if (!(F && F.key !== E.value)) { I(); try { (F == null ? void 0 : F.newValue) !== H.write(b.value) && (b.value = U(F)) } catch (Q) { m(Q) } finally { F ? qt(P) : P() } } } } function V(F) { Y(F.detail) } return b } function Du(e = {}) { const { controls: t = !1, interval: n = "requestAnimationFrame", immediate: r = !0 } = e, s = ae(new Date), i = () => s.value = new Date, l = n === "requestAnimationFrame" ? Mu(i, { immediate: r }) : Iu(i, n, { immediate: r }); return t ? { now: s, ...l } : s } function Hu(e, t = vr, n = {}) { const { immediate: r = !0, manual: s = !1, type: i = "text/javascript", async: l = !0, crossOrigin: o, referrerPolicy: a, noModule: c, defer: u, document: f = Dl, attrs: d = {}, nonce: m = void 0 } = n, x = At(null); let b = null; const E = H => new Promise((I, P) => { const W = me => (x.value = me, I(me), me); if (!f) { I(!1); return } let Z = !1, N = f.querySelector(`script[src="${Ie(e)}"]`); N ? N.hasAttribute("data-loaded") && W(N) : (N = f.createElement("script"), N.type = i, N.async = l, N.src = Ie(e), u && (N.defer = u), o && (N.crossOrigin = o), c && (N.noModule = c), a && (N.referrerPolicy = a), m && (N.nonce = m), Object.entries(d).forEach(([me, U]) => N == null ? void 0 : N.setAttribute(me, U)), Z = !0); const ke = { passive: !0 }; Lt(N, "error", me => P(me), ke), Lt(N, "abort", me => P(me), ke), Lt(N, "load", () => { N.setAttribute("data-loaded", "true"), t(N), W(N) }, ke), Z && (N = f.head.appendChild(N)), H || W(N) }), w = (H = !0) => (b || (b = E(H)), b), $ = () => { if (!f) return; b = null, x.value && (x.value = null); const H = f.querySelector(`script[src="${Ie(e)}"]`); H && f.head.removeChild(H) }; return r && !s && ms(w), s || Tu($), { scriptTag: x, load: w, unload: $ } } let Uu = 0; function Nu(e, t = {}) { const n = At(!1), { document: r = Dl, immediate: s = !0, manual: i = !1, id: l = `vueuse_styletag_${++Uu}` } = t, o = At(e); let a = () => { }; const c = () => { if (!r) return; const f = r.getElementById(l) || r.createElement("style"); f.isConnected || (f.id = l, t.nonce && (f.nonce = t.nonce), t.media && (f.media = t.media), r.head.appendChild(f)), !n.value && (a = gt(o, d => { f.textContent = d }, { immediate: !0 }), n.value = !0) }, u = () => { !r || !n.value || (a(), r.head.removeChild(r.getElementById(l)), n.value = !1) }; return s && !i && ms(c), i || Sn(u), { id: l, css: o, unload: u, load: c, isLoaded: Nt(n) } } const Vu = "WALINE_EMOJI", Ul = Yt(Vu, {}), Bu = e => !!/@[0-9]+\.[0-9]+\.[0-9]+/.test(e), Wu = e => { const t = Bu(e); if (t) { const n = Ul.value[e]; if (n) return Promise.resolve(n) } return fetch(`${e}/info.json`).then(n => n.json()).then(n => { const r = { folder: e, ...n }; return t && (Ul.value[e] = r), r }) }, Nl = (e, t = "", n = "", r = "") => `${t ? `${t}/` : ""}${n}${e}${r ? `.${r}` : ""}`, qu = e => Promise.all(e ? e.map(t => zt(t) ? Wu(oi(t)) : Promise.resolve(t)) : []).then(t => { const n = { tabs: [], map: {} }; return t.forEach(r => { const { name: s, folder: i, icon: l, prefix: o = "", type: a, items: c } = r; n.tabs.push({ name: s, icon: Nl(l, i, o, a), items: c.map(u => { const f = `${o}${u}`; return n.map[f] = Nl(u, i, o, a), f }) }) }), n }), Vl = e => { e.name !== "AbortError" && console.error(e.message) }, vs = e => e instanceof HTMLElement ? e : zt(e) ? document.querySelector(e) : null, Ku = e => e.type.includes("image"), Bl = e => { const t = Array.from(e).find(Ku); return t ? t.getAsFile() : null }; function bs() { return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null } } var Mt = bs(); function Wl(e) { Mt = e } var Rn = { exec: () => null }; function le(e, t = "") { let n = typeof e == "string" ? e : e.source, r = { replace: (s, i) => { let l = typeof i == "string" ? i : i.source; return l = l.replace(Ae.caret, "$1"), n = n.replace(s, l), r }, getRegex: () => new RegExp(n, t) }; return r } var Ae = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: e => new RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: e => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: e => new RegExp(`^ {0,${Math.min(3, e - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: e => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: e => new RegExp(`^ {0,${Math.min(3, e - 1)}}#`), htmlBeginRegex: e => new RegExp(`^ {0,${Math.min(3, e - 1)}}<(?:[a-z].*>|!--)`, "i") }, Gu = /^(?:[ \t]*(?:\n|$))+/, Zu = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Ju = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, An = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Yu = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, ys = /(?:[*+-]|\d{1,9}[.)])/, ql = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, Kl = le(ql).replace(/bull/g, ys).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Qu = le(ql).replace(/bull/g, ys).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), ws = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Xu = /^[^\n]+/, ks = /(?!\s*\])(?:\\.|[^\[\]\\])+/, ef = le(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", ks).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), tf = le(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, ys).getRegex(), kr = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", xs = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, nf = le("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", xs).replace("tag", kr).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), Gl = le(ws).replace("hr", An).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", kr).getRegex(), rf = le(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", Gl).getRegex(), _s = { blockquote: rf, code: Zu, def: ef, fences: Ju, heading: Yu, hr: An, html: nf, lheading: Kl, list: tf, newline: Gu, paragraph: Gl, table: Rn, text: Xu }, Zl = le("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", An).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", kr).getRegex(), sf = { ..._s, lheading: Qu, table: Zl, paragraph: le(ws).replace("hr", An).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", Zl).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", kr).getRegex() }, lf = {
    ..._s, html: le(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", xs).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: Rn, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: le(ws).replace("hr", An).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Kl).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, of = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, af = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, Jl = /^( {2,}|\\)\n(?!\s*$)/, cf = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, xr = /[\p{P}\p{S}]/u, $s = /[\s\p{P}\p{S}]/u, Yl = /[^\s\p{P}\p{S}]/u, uf = le(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, $s).getRegex(), Ql = /(?!~)[\p{P}\p{S}]/u, ff = /(?!~)[\s\p{P}\p{S}]/u, hf = /(?:[^\s\p{P}\p{S}]|~)/u, pf = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g, Xl = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, df = le(Xl, "u").replace(/punct/g, xr).getRegex(), gf = le(Xl, "u").replace(/punct/g, Ql).getRegex(), eo = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", mf = le(eo, "gu").replace(/notPunctSpace/g, Yl).replace(/punctSpace/g, $s).replace(/punct/g, xr).getRegex(), vf = le(eo, "gu").replace(/notPunctSpace/g, hf).replace(/punctSpace/g, ff).replace(/punct/g, Ql).getRegex(), bf = le("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, Yl).replace(/punctSpace/g, $s).replace(/punct/g, xr).getRegex(), yf = le(/\\(punct)/, "gu").replace(/punct/g, xr).getRegex(), wf = le(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), kf = le(xs).replace("(?:-->|$)", "-->").getRegex(), xf = le("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", kf).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), _r = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, _f = le(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", _r).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), to = le(/^!?\[(label)\]\[(ref)\]/).replace("label", _r).replace("ref", ks).getRegex(), no = le(/^!?\[(ref)\](?:\[\])?/).replace("ref", ks).getRegex(), $f = le("reflink|nolink(?!\\()", "g").replace("reflink", to).replace("nolink", no).getRegex(), Cs = { _backpedal: Rn, anyPunctuation: yf, autolink: wf, blockSkip: pf, br: Jl, code: af, del: Rn, emStrongLDelim: df, emStrongRDelimAst: mf, emStrongRDelimUnd: bf, escape: of, link: _f, nolink: no, punctuation: uf, reflink: to, reflinkSearch: $f, tag: xf, text: cf, url: Rn }, Cf = { ...Cs, link: le(/^!?\[(label)\]\((.*?)\)/).replace("label", _r).getRegex(), reflink: le(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _r).getRegex() }, Ss = { ...Cs, emStrongRDelimAst: vf, emStrongLDelim: gf, url: le(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }, Sf = { ...Ss, br: le(Jl).replace("{2,}", "*").getRegex(), text: le(Ss.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, $r = { normal: _s, gfm: sf, pedantic: lf }, En = { normal: Cs, gfm: Ss, breaks: Sf, pedantic: Cf }, Rf = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, ro = e => Rf[e]; function Ze(e, t) { if (t) { if (Ae.escapeTest.test(e)) return e.replace(Ae.escapeReplace, ro) } else if (Ae.escapeTestNoEncode.test(e)) return e.replace(Ae.escapeReplaceNoEncode, ro); return e } function so(e) { try { e = encodeURI(e).replace(Ae.percentDecode, "%") } catch { return null } return e } function io(e, t) { var i; let n = e.replace(Ae.findPipe, (l, o, a) => { let c = !1, u = o; for (; --u >= 0 && a[u] === "\\";)c = !c; return c ? "|" : " |" }), r = n.split(Ae.splitPipe), s = 0; if (r[0].trim() || r.shift(), r.length > 0 && !((i = r.at(-1)) != null && i.trim()) && r.pop(), t) if (r.length > t) r.splice(t); else for (; r.length < t;)r.push(""); for (; s < r.length; s++)r[s] = r[s].trim().replace(Ae.slashPipe, "|"); return r } function Tn(e, t, n) { let r = e.length; if (r === 0) return ""; let s = 0; for (; s < r && e.charAt(r - s - 1) === t;)s++; return e.slice(0, r - s) } function Af(e, t) { if (e.indexOf(t[1]) === -1) return -1; let n = 0; for (let r = 0; r < e.length; r++)if (e[r] === "\\") r++; else if (e[r] === t[0]) n++; else if (e[r] === t[1] && (n--, n < 0)) return r; return n > 0 ? -2 : -1 } function lo(e, t, n, r, s) { let i = t.href, l = t.title || null, o = e[1].replace(s.other.outputLinkReplace, "$1"); r.state.inLink = !0; let a = { type: e[0].charAt(0) === "!" ? "image" : "link", raw: n, href: i, title: l, text: o, tokens: r.inlineTokens(o) }; return r.state.inLink = !1, a } function Ef(e, t, n) {
    let r = e.match(n.other.indentCodeCompensation); if (r === null) return t; let s = r[1]; return t.split(`
`).map(i => { let l = i.match(n.other.beginningSpace); if (l === null) return i; let [o] = l; return o.length >= s.length ? i.slice(s.length) : i }).join(`
`)
} var Cr = class {
    options; rules; lexer; constructor(t) { this.options = t || Mt } space(t) { let n = this.rules.block.newline.exec(t); if (n && n[0].length > 0) return { type: "space", raw: n[0] } } code(t) {
        let n = this.rules.block.code.exec(t); if (n) {
            let r = n[0].replace(this.rules.other.codeRemoveIndent, ""); return {
                type: "code", raw: n[0], codeBlockStyle: "indented", text: this.options.pedantic ? r : Tn(r, `
`)
            }
        }
    } fences(t) { let n = this.rules.block.fences.exec(t); if (n) { let r = n[0], s = Ef(r, n[3] || "", this.rules); return { type: "code", raw: r, lang: n[2] ? n[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : n[2], text: s } } } heading(t) { let n = this.rules.block.heading.exec(t); if (n) { let r = n[2].trim(); if (this.rules.other.endingHash.test(r)) { let s = Tn(r, "#"); (this.options.pedantic || !s || this.rules.other.endingSpaceChar.test(s)) && (r = s.trim()) } return { type: "heading", raw: n[0], depth: n[1].length, text: r, tokens: this.lexer.inline(r) } } } hr(t) {
        let n = this.rules.block.hr.exec(t); if (n) return {
            type: "hr", raw: Tn(n[0], `
`)
        }
    } blockquote(t) {
        let n = this.rules.block.blockquote.exec(t); if (n) {
            let r = Tn(n[0], `
`).split(`
`), s = "", i = "", l = []; for (; r.length > 0;) {
                let o = !1, a = [], c; for (c = 0; c < r.length; c++)if (this.rules.other.blockquoteStart.test(r[c])) a.push(r[c]), o = !0; else if (!o) a.push(r[c]); else break; r = r.slice(c); let u = a.join(`
`), f = u.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, ""); s = s ? `${s}
${u}` : u, i = i ? `${i}
${f}` : f; let d = this.lexer.state.top; if (this.lexer.state.top = !0, this.lexer.blockTokens(f, l, !0), this.lexer.state.top = d, r.length === 0) break; let m = l.at(-1); if ((m == null ? void 0 : m.type) === "code") break; if ((m == null ? void 0 : m.type) === "blockquote") {
                    let x = m, b = x.raw + `
`+ r.join(`
`), E = this.blockquote(b); l[l.length - 1] = E, s = s.substring(0, s.length - x.raw.length) + E.raw, i = i.substring(0, i.length - x.text.length) + E.text; break
                } else if ((m == null ? void 0 : m.type) === "list") {
                    let x = m, b = x.raw + `
`+ r.join(`
`), E = this.list(b); l[l.length - 1] = E, s = s.substring(0, s.length - m.raw.length) + E.raw, i = i.substring(0, i.length - x.raw.length) + E.raw, r = b.substring(l.at(-1).raw.length).split(`
`); continue
                }
            } return { type: "blockquote", raw: s, tokens: l, text: i }
        }
    } list(t) {
        let n = this.rules.block.list.exec(t); if (n) {
            let r = n[1].trim(), s = r.length > 1, i = { type: "list", raw: "", ordered: s, start: s ? +r.slice(0, -1) : "", loose: !1, items: [] }; r = s ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`, this.options.pedantic && (r = s ? r : "[*+-]"); let l = this.rules.other.listItemRegex(r), o = !1; for (; t;) {
                let c = !1, u = "", f = ""; if (!(n = l.exec(t)) || this.rules.block.hr.test(t)) break; u = n[0], t = t.substring(u.length); let d = n[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, $ => " ".repeat(3 * $.length)), m = t.split(`
`, 1)[0], x = !d.trim(), b = 0; if (this.options.pedantic ? (b = 2, f = d.trimStart()) : x ? b = n[1].length + 1 : (b = n[2].search(this.rules.other.nonSpaceChar), b = b > 4 ? 1 : b, f = d.slice(b), b += n[1].length), x && this.rules.other.blankLine.test(m) && (u += m + `
`, t = t.substring(m.length + 1), c = !0), !c) {
                    let $ = this.rules.other.nextBulletRegex(b), H = this.rules.other.hrRegex(b), I = this.rules.other.fencesBeginRegex(b), P = this.rules.other.headingBeginRegex(b), W = this.rules.other.htmlBeginRegex(b); for (; t;) {
                        let Z = t.split(`
`, 1)[0], N; if (m = Z, this.options.pedantic ? (m = m.replace(this.rules.other.listReplaceNesting, "  "), N = m) : N = m.replace(this.rules.other.tabCharGlobal, "    "), I.test(m) || P.test(m) || W.test(m) || $.test(m) || H.test(m)) break; if (N.search(this.rules.other.nonSpaceChar) >= b || !m.trim()) f += `
`+ N.slice(b); else {
                            if (x || d.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || I.test(d) || P.test(d) || H.test(d)) break; f += `
`+ m
                        } !x && !m.trim() && (x = !0), u += Z + `
`, t = t.substring(Z.length + 1), d = N.slice(b)
                    }
                } i.loose || (o ? i.loose = !0 : this.rules.other.doubleBlankLine.test(u) && (o = !0)); let E = null, w; this.options.gfm && (E = this.rules.other.listIsTask.exec(f), E && (w = E[0] !== "[ ] ", f = f.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: u, task: !!E, checked: w, loose: !1, text: f, tokens: [] }), i.raw += u
            } let a = i.items.at(-1); if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd(); else return; i.raw = i.raw.trimEnd(); for (let c = 0; c < i.items.length; c++)if (this.lexer.state.top = !1, i.items[c].tokens = this.lexer.blockTokens(i.items[c].text, []), !i.loose) { let u = i.items[c].tokens.filter(d => d.type === "space"), f = u.length > 0 && u.some(d => this.rules.other.anyLine.test(d.raw)); i.loose = f } if (i.loose) for (let c = 0; c < i.items.length; c++)i.items[c].loose = !0; return i
        }
    } html(t) { let n = this.rules.block.html.exec(t); if (n) return { type: "html", block: !0, raw: n[0], pre: n[1] === "pre" || n[1] === "script" || n[1] === "style", text: n[0] } } def(t) { let n = this.rules.block.def.exec(t); if (n) { let r = n[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), s = n[2] ? n[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = n[3] ? n[3].substring(1, n[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : n[3]; return { type: "def", tag: r, raw: n[0], href: s, title: i } } } table(t) {
        var o; let n = this.rules.block.table.exec(t); if (!n || !this.rules.other.tableDelimiter.test(n[2])) return; let r = io(n[1]), s = n[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = (o = n[3]) != null && o.trim() ? n[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], l = { type: "table", raw: n[0], header: [], align: [], rows: [] }; if (r.length === s.length) { for (let a of s) this.rules.other.tableAlignRight.test(a) ? l.align.push("right") : this.rules.other.tableAlignCenter.test(a) ? l.align.push("center") : this.rules.other.tableAlignLeft.test(a) ? l.align.push("left") : l.align.push(null); for (let a = 0; a < r.length; a++)l.header.push({ text: r[a], tokens: this.lexer.inline(r[a]), header: !0, align: l.align[a] }); for (let a of i) l.rows.push(io(a, l.header.length).map((c, u) => ({ text: c, tokens: this.lexer.inline(c), header: !1, align: l.align[u] }))); return l }
    } lheading(t) { let n = this.rules.block.lheading.exec(t); if (n) return { type: "heading", raw: n[0], depth: n[2].charAt(0) === "=" ? 1 : 2, text: n[1], tokens: this.lexer.inline(n[1]) } } paragraph(t) {
        let n = this.rules.block.paragraph.exec(t); if (n) {
            let r = n[1].charAt(n[1].length - 1) === `
`? n[1].slice(0, -1) : n[1]; return { type: "paragraph", raw: n[0], text: r, tokens: this.lexer.inline(r) }
        }
    } text(t) { let n = this.rules.block.text.exec(t); if (n) return { type: "text", raw: n[0], text: n[0], tokens: this.lexer.inline(n[0]) } } escape(t) { let n = this.rules.inline.escape.exec(t); if (n) return { type: "escape", raw: n[0], text: n[1] } } tag(t) { let n = this.rules.inline.tag.exec(t); if (n) return !this.lexer.state.inLink && this.rules.other.startATag.test(n[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(n[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(n[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(n[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: n[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: n[0] } } link(t) { let n = this.rules.inline.link.exec(t); if (n) { let r = n[2].trim(); if (!this.options.pedantic && this.rules.other.startAngleBracket.test(r)) { if (!this.rules.other.endAngleBracket.test(r)) return; let l = Tn(r.slice(0, -1), "\\"); if ((r.length - l.length) % 2 === 0) return } else { let l = Af(n[2], "()"); if (l === -2) return; if (l > -1) { let o = (n[0].indexOf("!") === 0 ? 5 : 4) + n[1].length + l; n[2] = n[2].substring(0, l), n[0] = n[0].substring(0, o).trim(), n[3] = "" } } let s = n[2], i = ""; if (this.options.pedantic) { let l = this.rules.other.pedanticHrefTitle.exec(s); l && (s = l[1], i = l[3]) } else i = n[3] ? n[3].slice(1, -1) : ""; return s = s.trim(), this.rules.other.startAngleBracket.test(s) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(r) ? s = s.slice(1) : s = s.slice(1, -1)), lo(n, { href: s && s.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, n[0], this.lexer, this.rules) } } reflink(t, n) { let r; if ((r = this.rules.inline.reflink.exec(t)) || (r = this.rules.inline.nolink.exec(t))) { let s = (r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = n[s.toLowerCase()]; if (!i) { let l = r[0].charAt(0); return { type: "text", raw: l, text: l } } return lo(r, i, r[0], this.lexer, this.rules) } } emStrong(t, n, r = "") { let s = this.rules.inline.emStrongLDelim.exec(t); if (!(!s || s[3] && r.match(this.rules.other.unicodeAlphaNumeric)) && (!(s[1] || s[2]) || !r || this.rules.inline.punctuation.exec(r))) { let i = [...s[0]].length - 1, l, o, a = i, c = 0, u = s[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd; for (u.lastIndex = 0, n = n.slice(-1 * t.length + i); (s = u.exec(n)) != null;) { if (l = s[1] || s[2] || s[3] || s[4] || s[5] || s[6], !l) continue; if (o = [...l].length, s[3] || s[4]) { a += o; continue } else if ((s[5] || s[6]) && i % 3 && !((i + o) % 3)) { c += o; continue } if (a -= o, a > 0) continue; o = Math.min(o, o + a + c); let f = [...s[0]][0].length, d = t.slice(0, i + s.index + f + o); if (Math.min(i, o) % 2) { let x = d.slice(1, -1); return { type: "em", raw: d, text: x, tokens: this.lexer.inlineTokens(x) } } let m = d.slice(2, -2); return { type: "strong", raw: d, text: m, tokens: this.lexer.inlineTokens(m) } } } } codespan(t) { let n = this.rules.inline.code.exec(t); if (n) { let r = n[2].replace(this.rules.other.newLineCharGlobal, " "), s = this.rules.other.nonSpaceChar.test(r), i = this.rules.other.startingSpaceChar.test(r) && this.rules.other.endingSpaceChar.test(r); return s && i && (r = r.substring(1, r.length - 1)), { type: "codespan", raw: n[0], text: r } } } br(t) { let n = this.rules.inline.br.exec(t); if (n) return { type: "br", raw: n[0] } } del(t) { let n = this.rules.inline.del.exec(t); if (n) return { type: "del", raw: n[0], text: n[2], tokens: this.lexer.inlineTokens(n[2]) } } autolink(t) { let n = this.rules.inline.autolink.exec(t); if (n) { let r, s; return n[2] === "@" ? (r = n[1], s = "mailto:" + r) : (r = n[1], s = r), { type: "link", raw: n[0], text: r, href: s, tokens: [{ type: "text", raw: r, text: r }] } } } url(t) { var r; let n; if (n = this.rules.inline.url.exec(t)) { let s, i; if (n[2] === "@") s = n[0], i = "mailto:" + s; else { let l; do l = n[0], n[0] = ((r = this.rules.inline._backpedal.exec(n[0])) == null ? void 0 : r[0]) ?? ""; while (l !== n[0]); s = n[0], n[1] === "www." ? i = "http://" + n[0] : i = n[0] } return { type: "link", raw: n[0], text: s, href: i, tokens: [{ type: "text", raw: s, text: s }] } } } inlineText(t) { let n = this.rules.inline.text.exec(t); if (n) { let r = this.lexer.state.inRawBlock; return { type: "text", raw: n[0], text: n[0], escaped: r } } }
}, yt = class Is {
    tokens; options; state; tokenizer; inlineQueue; constructor(t) { this.tokens = [], this.tokens.links = Object.create(null), this.options = t || Mt, this.options.tokenizer = this.options.tokenizer || new Cr, this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 }; let n = { other: Ae, block: $r.normal, inline: En.normal }; this.options.pedantic ? (n.block = $r.pedantic, n.inline = En.pedantic) : this.options.gfm && (n.block = $r.gfm, this.options.breaks ? n.inline = En.breaks : n.inline = En.gfm), this.tokenizer.rules = n } static get rules() { return { block: $r, inline: En } } static lex(t, n) { return new Is(n).lex(t) } static lexInline(t, n) { return new Is(n).inlineTokens(t) } lex(t) {
        t = t.replace(Ae.carriageReturn, `
`), this.blockTokens(t, this.tokens); for (let n = 0; n < this.inlineQueue.length; n++) { let r = this.inlineQueue[n]; this.inlineTokens(r.src, r.tokens) } return this.inlineQueue = [], this.tokens
    } blockTokens(t, n = [], r = !1) {
        var s, i, l; for (this.options.pedantic && (t = t.replace(Ae.tabCharGlobal, "    ").replace(Ae.spaceLine, "")); t;) {
            let o; if ((i = (s = this.options.extensions) == null ? void 0 : s.block) != null && i.some(c => (o = c.call({ lexer: this }, t, n)) ? (t = t.substring(o.raw.length), n.push(o), !0) : !1)) continue; if (o = this.tokenizer.space(t)) {
                t = t.substring(o.raw.length); let c = n.at(-1); o.raw.length === 1 && c !== void 0 ? c.raw += `
`: n.push(o); continue
            } if (o = this.tokenizer.code(t)) {
                t = t.substring(o.raw.length); let c = n.at(-1); (c == null ? void 0 : c.type) === "paragraph" || (c == null ? void 0 : c.type) === "text" ? (c.raw += `
`+ o.raw, c.text += `
`+ o.text, this.inlineQueue.at(-1).src = c.text) : n.push(o); continue
            } if (o = this.tokenizer.fences(t)) { t = t.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.heading(t)) { t = t.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.hr(t)) { t = t.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.blockquote(t)) { t = t.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.list(t)) { t = t.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.html(t)) { t = t.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.def(t)) {
                t = t.substring(o.raw.length); let c = n.at(-1); (c == null ? void 0 : c.type) === "paragraph" || (c == null ? void 0 : c.type) === "text" ? (c.raw += `
`+ o.raw, c.text += `
`+ o.raw, this.inlineQueue.at(-1).src = c.text) : this.tokens.links[o.tag] || (this.tokens.links[o.tag] = { href: o.href, title: o.title }); continue
            } if (o = this.tokenizer.table(t)) { t = t.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.lheading(t)) { t = t.substring(o.raw.length), n.push(o); continue } let a = t; if ((l = this.options.extensions) != null && l.startBlock) { let c = 1 / 0, u = t.slice(1), f; this.options.extensions.startBlock.forEach(d => { f = d.call({ lexer: this }, u), typeof f == "number" && f >= 0 && (c = Math.min(c, f)) }), c < 1 / 0 && c >= 0 && (a = t.substring(0, c + 1)) } if (this.state.top && (o = this.tokenizer.paragraph(a))) {
                let c = n.at(-1); r && (c == null ? void 0 : c.type) === "paragraph" ? (c.raw += `
`+ o.raw, c.text += `
`+ o.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = c.text) : n.push(o), r = a.length !== t.length, t = t.substring(o.raw.length); continue
            } if (o = this.tokenizer.text(t)) {
                t = t.substring(o.raw.length); let c = n.at(-1); (c == null ? void 0 : c.type) === "text" ? (c.raw += `
`+ o.raw, c.text += `
`+ o.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = c.text) : n.push(o); continue
            } if (t) { let c = "Infinite loop on byte: " + t.charCodeAt(0); if (this.options.silent) { console.error(c); break } else throw new Error(c) }
        } return this.state.top = !0, n
    } inline(t, n = []) { return this.inlineQueue.push({ src: t, tokens: n }), n } inlineTokens(t, n = []) { var o, a, c; let r = t, s = null; if (this.tokens.links) { let u = Object.keys(this.tokens.links); if (u.length > 0) for (; (s = this.tokenizer.rules.inline.reflinkSearch.exec(r)) != null;)u.includes(s[0].slice(s[0].lastIndexOf("[") + 1, -1)) && (r = r.slice(0, s.index) + "[" + "a".repeat(s[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex)) } for (; (s = this.tokenizer.rules.inline.anyPunctuation.exec(r)) != null;)r = r.slice(0, s.index) + "++" + r.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex); for (; (s = this.tokenizer.rules.inline.blockSkip.exec(r)) != null;)r = r.slice(0, s.index) + "[" + "a".repeat(s[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex); let i = !1, l = ""; for (; t;) { i || (l = ""), i = !1; let u; if ((a = (o = this.options.extensions) == null ? void 0 : o.inline) != null && a.some(d => (u = d.call({ lexer: this }, t, n)) ? (t = t.substring(u.raw.length), n.push(u), !0) : !1)) continue; if (u = this.tokenizer.escape(t)) { t = t.substring(u.raw.length), n.push(u); continue } if (u = this.tokenizer.tag(t)) { t = t.substring(u.raw.length), n.push(u); continue } if (u = this.tokenizer.link(t)) { t = t.substring(u.raw.length), n.push(u); continue } if (u = this.tokenizer.reflink(t, this.tokens.links)) { t = t.substring(u.raw.length); let d = n.at(-1); u.type === "text" && (d == null ? void 0 : d.type) === "text" ? (d.raw += u.raw, d.text += u.text) : n.push(u); continue } if (u = this.tokenizer.emStrong(t, r, l)) { t = t.substring(u.raw.length), n.push(u); continue } if (u = this.tokenizer.codespan(t)) { t = t.substring(u.raw.length), n.push(u); continue } if (u = this.tokenizer.br(t)) { t = t.substring(u.raw.length), n.push(u); continue } if (u = this.tokenizer.del(t)) { t = t.substring(u.raw.length), n.push(u); continue } if (u = this.tokenizer.autolink(t)) { t = t.substring(u.raw.length), n.push(u); continue } if (!this.state.inLink && (u = this.tokenizer.url(t))) { t = t.substring(u.raw.length), n.push(u); continue } let f = t; if ((c = this.options.extensions) != null && c.startInline) { let d = 1 / 0, m = t.slice(1), x; this.options.extensions.startInline.forEach(b => { x = b.call({ lexer: this }, m), typeof x == "number" && x >= 0 && (d = Math.min(d, x)) }), d < 1 / 0 && d >= 0 && (f = t.substring(0, d + 1)) } if (u = this.tokenizer.inlineText(f)) { t = t.substring(u.raw.length), u.raw.slice(-1) !== "_" && (l = u.raw.slice(-1)), i = !0; let d = n.at(-1); (d == null ? void 0 : d.type) === "text" ? (d.raw += u.raw, d.text += u.text) : n.push(u); continue } if (t) { let d = "Infinite loop on byte: " + t.charCodeAt(0); if (this.options.silent) { console.error(d); break } else throw new Error(d) } } return n }
}, Sr = class {
    options; parser; constructor(e) { this.options = e || Mt } space(e) { return "" } code({ text: e, lang: t, escaped: n }) {
        var i; let r = (i = (t || "").match(Ae.notSpaceStart)) == null ? void 0 : i[0], s = e.replace(Ae.endingNewline, "") + `
`; return r ? '<pre><code class="language-' + Ze(r) + '">' + (n ? s : Ze(s, !0)) + `</code></pre>
`: "<pre><code>" + (n ? s : Ze(s, !0)) + `</code></pre>
`} blockquote({ tokens: e }) {
        return `<blockquote>
${this.parser.parse(e)}</blockquote>
`} html({ text: e }) { return e } heading({ tokens: e, depth: t }) {
        return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`} hr(e) {
        return `<hr>
`} list(e) {
        let t = e.ordered, n = e.start, r = ""; for (let l = 0; l < e.items.length; l++) { let o = e.items[l]; r += this.listitem(o) } let s = t ? "ol" : "ul", i = t && n !== 1 ? ' start="' + n + '"' : ""; return "<" + s + i + `>
`+ r + "</" + s + `>
`} listitem(e) {
        var n; let t = ""; if (e.task) { let r = this.checkbox({ checked: !!e.checked }); e.loose ? ((n = e.tokens[0]) == null ? void 0 : n.type) === "paragraph" ? (e.tokens[0].text = r + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = r + " " + Ze(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = !0)) : e.tokens.unshift({ type: "text", raw: r + " ", text: r + " ", escaped: !0 }) : t += r + " " } return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`} checkbox({ checked: e }) { return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">' } paragraph({ tokens: e }) {
        return `<p>${this.parser.parseInline(e)}</p>
`} table(e) {
        let t = "", n = ""; for (let s = 0; s < e.header.length; s++)n += this.tablecell(e.header[s]); t += this.tablerow({ text: n }); let r = ""; for (let s = 0; s < e.rows.length; s++) { let i = e.rows[s]; n = ""; for (let l = 0; l < i.length; l++)n += this.tablecell(i[l]); r += this.tablerow({ text: n }) } return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
`+ t + `</thead>
`+ r + `</table>
`} tablerow({ text: e }) {
        return `<tr>
${e}</tr>
`} tablecell(e) {
        let t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td"; return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t + `</${n}>
`} strong({ tokens: e }) { return `<strong>${this.parser.parseInline(e)}</strong>` } em({ tokens: e }) { return `<em>${this.parser.parseInline(e)}</em>` } codespan({ text: e }) { return `<code>${Ze(e, !0)}</code>` } br(e) { return "<br>" } del({ tokens: e }) { return `<del>${this.parser.parseInline(e)}</del>` } link({ href: e, title: t, tokens: n }) { let r = this.parser.parseInline(n), s = so(e); if (s === null) return r; e = s; let i = '<a href="' + e + '"'; return t && (i += ' title="' + Ze(t) + '"'), i += ">" + r + "</a>", i } image({ href: e, title: t, text: n, tokens: r }) { r && (n = this.parser.parseInline(r, this.parser.textRenderer)); let s = so(e); if (s === null) return Ze(n); e = s; let i = `<img src="${e}" alt="${n}"`; return t && (i += ` title="${Ze(t)}"`), i += ">", i } text(e) { return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : Ze(e.text) }
}, Rs = class { strong({ text: t }) { return t } em({ text: t }) { return t } codespan({ text: t }) { return t } del({ text: t }) { return t } html({ text: t }) { return t } text({ text: t }) { return t } link({ text: t }) { return "" + t } image({ text: t }) { return "" + t } br() { return "" } }, wt = class Ls {
    options; renderer; textRenderer; constructor(t) { this.options = t || Mt, this.options.renderer = this.options.renderer || new Sr, this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new Rs } static parse(t, n) { return new Ls(n).parse(t) } static parseInline(t, n) { return new Ls(n).parseInline(t) } parse(t, n = !0) {
        var s, i; let r = ""; for (let l = 0; l < t.length; l++) {
            let o = t[l]; if ((i = (s = this.options.extensions) == null ? void 0 : s.renderers) != null && i[o.type]) { let c = o, u = this.options.extensions.renderers[c.type].call({ parser: this }, c); if (u !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(c.type)) { r += u || ""; continue } } let a = o; switch (a.type) {
                case "space": { r += this.renderer.space(a); continue } case "hr": { r += this.renderer.hr(a); continue } case "heading": { r += this.renderer.heading(a); continue } case "code": { r += this.renderer.code(a); continue } case "table": { r += this.renderer.table(a); continue } case "blockquote": { r += this.renderer.blockquote(a); continue } case "list": { r += this.renderer.list(a); continue } case "html": { r += this.renderer.html(a); continue } case "paragraph": { r += this.renderer.paragraph(a); continue } case "text": {
                    let c = a, u = this.renderer.text(c); for (; l + 1 < t.length && t[l + 1].type === "text";)c = t[++l], u += `
`+ this.renderer.text(c); n ? r += this.renderer.paragraph({ type: "paragraph", raw: u, text: u, tokens: [{ type: "text", raw: u, text: u, escaped: !0 }] }) : r += u; continue
                } default: { let c = 'Token with "' + a.type + '" type was not found.'; if (this.options.silent) return console.error(c), ""; throw new Error(c) }
            }
        } return r
    } parseInline(t, n = this.renderer) { var s, i; let r = ""; for (let l = 0; l < t.length; l++) { let o = t[l]; if ((i = (s = this.options.extensions) == null ? void 0 : s.renderers) != null && i[o.type]) { let c = this.options.extensions.renderers[o.type].call({ parser: this }, o); if (c !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(o.type)) { r += c || ""; continue } } let a = o; switch (a.type) { case "escape": { r += n.text(a); break } case "html": { r += n.html(a); break } case "link": { r += n.link(a); break } case "image": { r += n.image(a); break } case "strong": { r += n.strong(a); break } case "em": { r += n.em(a); break } case "codespan": { r += n.codespan(a); break } case "br": { r += n.br(a); break } case "del": { r += n.del(a); break } case "text": { r += n.text(a); break } default: { let c = 'Token with "' + a.type + '" type was not found.'; if (this.options.silent) return console.error(c), ""; throw new Error(c) } } } return r }
}, Rr = (Ts = class { options; block; constructor(e) { this.options = e || Mt } preprocess(e) { return e } postprocess(e) { return e } processAllTokens(e) { return e } provideLexer() { return this.block ? yt.lex : yt.lexInline } provideParser() { return this.block ? wt.parse : wt.parseInline } }, Os(Ts, "passThroughHooks", new Set(["preprocess", "postprocess", "processAllTokens"])), Ts), oo = class {
    defaults = bs(); options = this.setOptions; parse = this.parseMarkdown(!0); parseInline = this.parseMarkdown(!1); Parser = wt; Renderer = Sr; TextRenderer = Rs; Lexer = yt; Tokenizer = Cr; Hooks = Rr; constructor(...e) { this.use(...e) } walkTokens(e, t) { var r, s; let n = []; for (let i of e) switch (n = n.concat(t.call(this, i)), i.type) { case "table": { let l = i; for (let o of l.header) n = n.concat(this.walkTokens(o.tokens, t)); for (let o of l.rows) for (let a of o) n = n.concat(this.walkTokens(a.tokens, t)); break } case "list": { let l = i; n = n.concat(this.walkTokens(l.items, t)); break } default: { let l = i; (s = (r = this.defaults.extensions) == null ? void 0 : r.childTokens) != null && s[l.type] ? this.defaults.extensions.childTokens[l.type].forEach(o => { let a = l[o].flat(1 / 0); n = n.concat(this.walkTokens(a, t)) }) : l.tokens && (n = n.concat(this.walkTokens(l.tokens, t))) } }return n } use(...e) { let t = this.defaults.extensions || { renderers: {}, childTokens: {} }; return e.forEach(n => { let r = { ...n }; if (r.async = this.defaults.async || r.async || !1, n.extensions && (n.extensions.forEach(s => { if (!s.name) throw new Error("extension name required"); if ("renderer" in s) { let i = t.renderers[s.name]; i ? t.renderers[s.name] = function (...l) { let o = s.renderer.apply(this, l); return o === !1 && (o = i.apply(this, l)), o } : t.renderers[s.name] = s.renderer } if ("tokenizer" in s) { if (!s.level || s.level !== "block" && s.level !== "inline") throw new Error("extension level must be 'block' or 'inline'"); let i = t[s.level]; i ? i.unshift(s.tokenizer) : t[s.level] = [s.tokenizer], s.start && (s.level === "block" ? t.startBlock ? t.startBlock.push(s.start) : t.startBlock = [s.start] : s.level === "inline" && (t.startInline ? t.startInline.push(s.start) : t.startInline = [s.start])) } "childTokens" in s && s.childTokens && (t.childTokens[s.name] = s.childTokens) }), r.extensions = t), n.renderer) { let s = this.defaults.renderer || new Sr(this.defaults); for (let i in n.renderer) { if (!(i in s)) throw new Error(`renderer '${i}' does not exist`); if (["options", "parser"].includes(i)) continue; let l = i, o = n.renderer[l], a = s[l]; s[l] = (...c) => { let u = o.apply(s, c); return u === !1 && (u = a.apply(s, c)), u || "" } } r.renderer = s } if (n.tokenizer) { let s = this.defaults.tokenizer || new Cr(this.defaults); for (let i in n.tokenizer) { if (!(i in s)) throw new Error(`tokenizer '${i}' does not exist`); if (["options", "rules", "lexer"].includes(i)) continue; let l = i, o = n.tokenizer[l], a = s[l]; s[l] = (...c) => { let u = o.apply(s, c); return u === !1 && (u = a.apply(s, c)), u } } r.tokenizer = s } if (n.hooks) { let s = this.defaults.hooks || new Rr; for (let i in n.hooks) { if (!(i in s)) throw new Error(`hook '${i}' does not exist`); if (["options", "block"].includes(i)) continue; let l = i, o = n.hooks[l], a = s[l]; Rr.passThroughHooks.has(i) ? s[l] = c => { if (this.defaults.async) return Promise.resolve(o.call(s, c)).then(f => a.call(s, f)); let u = o.call(s, c); return a.call(s, u) } : s[l] = (...c) => { let u = o.apply(s, c); return u === !1 && (u = a.apply(s, c)), u } } r.hooks = s } if (n.walkTokens) { let s = this.defaults.walkTokens, i = n.walkTokens; r.walkTokens = function (l) { let o = []; return o.push(i.call(this, l)), s && (o = o.concat(s.call(this, l))), o } } this.defaults = { ...this.defaults, ...r } }), this } setOptions(e) { return this.defaults = { ...this.defaults, ...e }, this } lexer(e, t) { return yt.lex(e, t ?? this.defaults) } parser(e, t) { return wt.parse(e, t ?? this.defaults) } parseMarkdown(e) { return (t, n) => { let r = { ...n }, s = { ...this.defaults, ...r }, i = this.onError(!!s.silent, !!s.async); if (this.defaults.async === !0 && r.async === !1) return i(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.")); if (typeof t > "u" || t === null) return i(new Error("marked(): input parameter is undefined or null")); if (typeof t != "string") return i(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(t) + ", string expected")); s.hooks && (s.hooks.options = s, s.hooks.block = e); let l = s.hooks ? s.hooks.provideLexer() : e ? yt.lex : yt.lexInline, o = s.hooks ? s.hooks.provideParser() : e ? wt.parse : wt.parseInline; if (s.async) return Promise.resolve(s.hooks ? s.hooks.preprocess(t) : t).then(a => l(a, s)).then(a => s.hooks ? s.hooks.processAllTokens(a) : a).then(a => s.walkTokens ? Promise.all(this.walkTokens(a, s.walkTokens)).then(() => a) : a).then(a => o(a, s)).then(a => s.hooks ? s.hooks.postprocess(a) : a).catch(i); try { s.hooks && (t = s.hooks.preprocess(t)); let a = l(t, s); s.hooks && (a = s.hooks.processAllTokens(a)), s.walkTokens && this.walkTokens(a, s.walkTokens); let c = o(a, s); return s.hooks && (c = s.hooks.postprocess(c)), c } catch (a) { return i(a) } } } onError(e, t) {
        return n => {
            if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) { let r = "<p>An error occurred:</p><pre>" + Ze(n.message + "", !0) + "</pre>"; return t ? Promise.resolve(r) : r } if (t) return Promise.reject(n); throw n
        }
    }
}, Pt = new oo; function ge(e, t) { return Pt.parse(e, t) } ge.options = ge.setOptions = function (e) { return Pt.setOptions(e), ge.defaults = Pt.defaults, Wl(ge.defaults), ge }, ge.getDefaults = bs, ge.defaults = Mt, ge.use = function (...e) { return Pt.use(...e), ge.defaults = Pt.defaults, Wl(ge.defaults), ge }, ge.walkTokens = function (e, t) { return Pt.walkTokens(e, t) }, ge.parseInline = Pt.parseInline, ge.Parser = wt, ge.parser = wt.parse, ge.Renderer = Sr, ge.TextRenderer = Rs, ge.Lexer = yt, ge.lexer = yt.lex, ge.Tokenizer = Cr, ge.Hooks = Rr, ge.parse = ge; function Tf(e) {
    if (typeof e == "function" && (e = { highlight: e }), !e || typeof e.highlight != "function") throw new Error("Must provide highlight function"); return typeof e.langPrefix != "string" && (e.langPrefix = "language-"), typeof e.emptyLangClass != "string" && (e.emptyLangClass = ""), {
        async: !!e.async, walkTokens(t) { if (t.type !== "code") return; const n = ao(t.lang); if (e.async) return Promise.resolve(e.highlight(t.text, n, t.lang || "")).then(co(t)); const r = e.highlight(t.text, n, t.lang || ""); if (r instanceof Promise) throw new Error("markedHighlight is not set to async but the highlight function is async. Set the async option to true on markedHighlight to await the async highlight function."); co(t)(r) }, useNewRenderer: !0, renderer: {
            code(t, n, r) {
                typeof t == "object" && (r = t.escaped, n = t.lang, t = t.text); const s = ao(n), i = s ? e.langPrefix + po(s) : e.emptyLangClass, l = i ? ` class="${i}"` : ""; return t = t.replace(/\n$/, ""), `<pre><code${l}>${r ? t : po(t, !0)}
</code></pre>`}
        }
    }
} function ao(e) { return (e || "").match(/\S*/)[0] } function co(e) { return t => { typeof t == "string" && t !== e.text && (e.escaped = !0, e.text = t) } } const uo = /[&<>"']/, If = new RegExp(uo.source, "g"), fo = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, Lf = new RegExp(fo.source, "g"), Mf = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, ho = e => Mf[e]; function po(e, t) { if (t) { if (uo.test(e)) return e.replace(If, ho) } else if (fo.test(e)) return e.replace(Lf, ho); return e } const Pf = /\$.*?\$/, Of = /^\$(.*?)\$/, jf = /^(?:\s{0,3})\$\$((?:[^\n]|\n[^\n])+?)\n{0,1}\$\$/, zf = e => [{ name: "blockMath", level: "block", tokenizer(t) { const n = jf.exec(t); if (n !== null) return { type: "html", raw: n[0], text: e(!0, n[1]) } } }, { name: "inlineMath", level: "inline", start(t) { const n = t.search(Pf); return n !== -1 ? n : t.length }, tokenizer(t) { const n = Of.exec(t); if (n !== null) return { type: "html", raw: n[0], text: e(!1, n[1]) } } }], go = (e = "", t = {}) => e.replace(/:(.+?):/g, (n, r) => t[r] ? `<img class="wl-emoji" src="${t[r]}" alt="${r}">` : n), Ff = (e, { emojiMap: t, highlighter: n, texRenderer: r }) => { const s = new oo; if (s.setOptions({ breaks: !0 }), n && s.use(Tf({ highlight: n })), r) { const i = zf(r); s.use({ extensions: i }) } return s.parse(go(e, t)) }, As = e => { const { path: t } = e.dataset; return t != null && t.length ? t : null }, Df = e => e.match(/[\w\d\s,.\u00C0-\u024F\u0400-\u04FF]+/giu), Hf = e => e.match(/[\u4E00-\u9FD5]/gu), Uf = e => { var t, n; return (((t = Df(e)) == null ? void 0 : t.reduce((r, s) => r + (["", ",", "."].includes(s.trim()) ? 0 : s.trim().split(/\s+/u).length), 0)) ?? 0) + (((n = Hf(e)) == null ? void 0 : n.length) ?? 0) }, Nf = async () => { const { userAgentData: e } = navigator; let t = navigator.userAgent; if (!e || e.platform !== "Windows") return t; const { platformVersion: n } = await e.getHighEntropyValues(["platformVersion"]); return n && parseInt(n.split(".")[0]) >= 13 && (t = t.replace("Windows NT 10.0", "Windows NT 11.0")), t }, mo = ({ serverURL: e, path: t = window.location.pathname, selector: n = ".waline-comment-count", lang: r = navigator.language }) => { const s = new AbortController, i = document.querySelectorAll(n); return i.length && Hs({ serverURL: Hn(e), paths: Array.from(i).map(l => li(As(l) ?? t)), lang: r, signal: s.signal }).then(l => { i.forEach((o, a) => { o.innerText = l[a].toString() }) }).catch(Vl), s.abort.bind(s) }, vo = ({ size: e }) => ie("svg", { class: "wl-close-icon", viewBox: "0 0 1024 1024", width: e, height: e }, [ie("path", { d: "M697.173 85.333h-369.92c-144.64 0-241.92 101.547-241.92 252.587v348.587c0 150.613 97.28 252.16 241.92 252.16h369.92c144.64 0 241.494-101.547 241.494-252.16V337.92c0-151.04-96.854-252.587-241.494-252.587z", fill: "currentColor" }), ie("path", { d: "m640.683 587.52-75.947-75.861 75.904-75.862a37.29 37.29 0 0 0 0-52.778 37.205 37.205 0 0 0-52.779 0l-75.946 75.818-75.862-75.946a37.419 37.419 0 0 0-52.821 0 37.419 37.419 0 0 0 0 52.821l75.947 75.947-75.776 75.733a37.29 37.29 0 1 0 52.778 52.821l75.776-75.776 75.947 75.947a37.376 37.376 0 0 0 52.779-52.821z", fill: "#888" })]), Vf = () => ie("svg", { viewBox: "0 0 1024 1024", width: "24", height: "24" }, ie("path", { d: "m341.013 394.667 27.755 393.45h271.83l27.733-393.45h64.106l-28.01 397.952a64 64 0 0 1-63.83 59.498H368.768a64 64 0 0 1-63.83-59.52l-28.053-397.93h64.128zm139.307 19.818v298.667h-64V414.485h64zm117.013 0v298.667h-64V414.485h64zM181.333 288h640v64h-640v-64zm453.483-106.667v64h-256v-64h256z", fill: "red" })), Bf = () => ie("svg", { viewBox: "0 0 1024 1024", width: "24", height: "24" }, ie("path", { d: "M563.2 463.3 677 540c1.7 1.2 3.7 1.8 5.8 1.8.7 0 1.4-.1 2-.2 2.7-.5 5.1-2.1 6.6-4.4l25.3-37.8c1.5-2.3 2.1-5.1 1.6-7.8s-2.1-5.1-4.4-6.6l-73.6-49.1 73.6-49.1c2.3-1.5 3.9-3.9 4.4-6.6.5-2.7 0-5.5-1.6-7.8l-25.3-37.8a10.1 10.1 0 0 0-6.6-4.4c-.7-.1-1.3-.2-2-.2-2.1 0-4.1.6-5.8 1.8l-113.8 76.6c-9.2 6.2-14.7 16.4-14.7 27.5.1 11 5.5 21.3 14.7 27.4zM387 348.8h-45.5c-5.7 0-10.4 4.7-10.4 10.4v153.3c0 5.7 4.7 10.4 10.4 10.4H387c5.7 0 10.4-4.7 10.4-10.4V359.2c0-5.7-4.7-10.4-10.4-10.4zm333.8 241.3-41-20a10.3 10.3 0 0 0-8.1-.5c-2.6.9-4.8 2.9-5.9 5.4-30.1 64.9-93.1 109.1-164.4 115.2-5.7.5-9.9 5.5-9.5 11.2l3.9 45.5c.5 5.3 5 9.5 10.3 9.5h.9c94.8-8 178.5-66.5 218.6-152.7 2.4-5 .3-11.2-4.8-13.6zm186-186.1c-11.9-42-30.5-81.4-55.2-117.1-24.1-34.9-53.5-65.6-87.5-91.2-33.9-25.6-71.5-45.5-111.6-59.2-41.2-14-84.1-21.1-127.8-21.1h-1.2c-75.4 0-148.8 21.4-212.5 61.7-63.7 40.3-114.3 97.6-146.5 165.8-32.2 68.1-44.3 143.6-35.1 218.4 9.3 74.8 39.4 145 87.3 203.3.1.2.3.3.4.5l36.2 38.4c1.1 1.2 2.5 2.1 3.9 2.6 73.3 66.7 168.2 103.5 267.5 103.5 73.3 0 145.2-20.3 207.7-58.7 37.3-22.9 70.3-51.5 98.1-85 27.1-32.7 48.7-69.5 64.2-109.1 15.5-39.7 24.4-81.3 26.6-123.8 2.4-43.6-2.5-87-14.5-129zm-60.5 181.1c-8.3 37-22.8 72-43 104-19.7 31.1-44.3 58.6-73.1 81.7-28.8 23.1-61 41-95.7 53.4-35.6 12.7-72.9 19.1-110.9 19.1-82.6 0-161.7-30.6-222.8-86.2l-34.1-35.8c-23.9-29.3-42.4-62.2-55.1-97.7-12.4-34.7-18.8-71-19.2-107.9-.4-36.9 5.4-73.3 17.1-108.2 12-35.8 30-69.2 53.4-99.1 31.7-40.4 71.1-72 117.2-94.1 44.5-21.3 94-32.6 143.4-32.6 49.3 0 97 10.8 141.8 32 34.3 16.3 65.3 38.1 92 64.8 26.1 26 47.5 56 63.6 89.2 16.2 33.2 26.6 68.5 31 105.1 4.6 37.5 2.7 75.3-5.6 112.3z", fill: "currentColor" })), Wf = () => ie("svg", { viewBox: "0 0 1024 1024", width: "24", height: "24" }, [ie("path", { d: "M784 112H240c-88 0-160 72-160 160v480c0 88 72 160 160 160h544c88 0 160-72 160-160V272c0-88-72-160-160-160zm96 640c0 52.8-43.2 96-96 96H240c-52.8 0-96-43.2-96-96V272c0-52.8 43.2-96 96-96h544c52.8 0 96 43.2 96 96v480z", fill: "currentColor" }), ie("path", { d: "M352 480c52.8 0 96-43.2 96-96s-43.2-96-96-96-96 43.2-96 96 43.2 96 96 96zm0-128c17.6 0 32 14.4 32 32s-14.4 32-32 32-32-14.4-32-32 14.4-32 32-32zm462.4 379.2-3.2-3.2-177.6-177.6c-25.6-25.6-65.6-25.6-91.2 0l-80 80-36.8-36.8c-25.6-25.6-65.6-25.6-91.2 0L200 728c-4.8 6.4-8 14.4-8 24 0 17.6 14.4 32 32 32 9.6 0 16-3.2 22.4-9.6L380.8 640l134.4 134.4c6.4 6.4 14.4 9.6 24 9.6 17.6 0 32-14.4 32-32 0-9.6-4.8-17.6-9.6-24l-52.8-52.8 80-80L769.6 776c6.4 4.8 12.8 8 20.8 8 17.6 0 32-14.4 32-32 0-8-3.2-16-8-20.8z", fill: "currentColor" })]), qf = ({ active: e = !1 }) => ie("svg", { viewBox: "0 0 1024 1024", width: "24", height: "24" }, [ie("path", { d: `M850.654 323.804c-11.042-25.625-26.862-48.532-46.885-68.225-20.022-19.61-43.258-34.936-69.213-45.73-26.78-11.124-55.124-16.727-84.375-16.727-40.622 0-80.256 11.123-114.698 32.135A214.79 214.79 0 0 0 512 241.819a214.79 214.79 0 0 0-23.483-16.562c-34.442-21.012-74.076-32.135-114.698-32.135-29.25 0-57.595 5.603-84.375 16.727-25.872 10.711-49.19 26.12-69.213 45.73-20.105 19.693-35.843 42.6-46.885 68.225-11.453 26.615-17.303 54.877-17.303 83.963 0 27.439 5.603 56.03 16.727 85.117 9.31 24.307 22.659 49.52 39.715 74.981 27.027 40.293 64.188 82.316 110.33 124.915 76.465 70.615 152.189 119.394 155.402 121.371l19.528 12.525c8.652 5.52 19.776 5.52 28.427 0l19.529-12.525c3.213-2.06 78.854-50.756 155.401-121.371 46.143-42.6 83.304-84.622 110.33-124.915 17.057-25.46 30.487-50.674 39.716-74.981 11.124-29.087 16.727-57.678 16.727-85.117.082-29.086-5.768-57.348-17.221-83.963z${e ? "" : "M512 761.5S218.665 573.55 218.665 407.767c0-83.963 69.461-152.023 155.154-152.023 60.233 0 112.473 33.618 138.181 82.727 25.708-49.109 77.948-82.727 138.18-82.727 85.694 0 155.155 68.06 155.155 152.023C805.335 573.551 512 761.5 512 761.5z"}`, fill: e ? "red" : "currentColor" })]), Kf = () => ie("svg", { viewBox: "0 0 1024 1024", width: "24", height: "24" }, [ie("path", { d: "M710.816 654.301c70.323-96.639 61.084-230.578-23.705-314.843-46.098-46.098-107.183-71.109-172.28-71.109-65.008 0-126.092 25.444-172.28 71.109-45.227 46.098-70.756 107.183-70.756 172.106 0 64.923 25.444 126.007 71.194 172.106 46.099 46.098 107.184 71.109 172.28 71.109 51.414 0 100.648-16.212 142.824-47.404l126.53 126.006c7.058 7.06 16.297 10.979 26.406 10.979 10.105 0 19.343-3.919 26.402-10.979 14.467-14.467 14.467-38.172 0-52.723L710.816 654.301zm-315.107-23.265c-65.88-65.88-65.88-172.54 0-238.42 32.069-32.07 74.245-49.149 119.471-49.149 45.227 0 87.407 17.603 119.472 49.149 65.88 65.879 65.88 172.539 0 238.42-63.612 63.178-175.242 63.178-238.943 0zm0 0", fill: "currentColor" }), ie("path", { d: "M703.319 121.603H321.03c-109.8 0-199.469 89.146-199.469 199.38v382.034c0 109.796 89.236 199.38 199.469 199.38h207.397c20.653 0 37.384-16.645 37.384-37.299 0-20.649-16.731-37.296-37.384-37.296H321.03c-68.582 0-124.352-55.77-124.352-124.267V321.421c0-68.496 55.77-124.267 124.352-124.267h382.289c68.582 0 124.352 55.771 124.352 124.267V524.72c0 20.654 16.736 37.299 37.385 37.299 20.654 0 37.384-16.645 37.384-37.299V320.549c-.085-109.8-89.321-198.946-199.121-198.946zm0 0", fill: "currentColor" })]), Gf = () => ie("svg", { width: "24", height: "24", viewBox: "-4 -5 24 24", ariaHidden: "true" }, ie("path", { d: "M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z", fill: "currentColor" })), Zf = () => ie("svg", { viewBox: "0 0 1024 1024", width: "24", height: "24" }, ie("path", { d: "M810.667 213.333a64 64 0 0 1 64 64V704a64 64 0 0 1-64 64H478.336l-146.645 96.107a21.333 21.333 0 0 1-33.024-17.856V768h-85.334a64 64 0 0 1-64-64V277.333a64 64 0 0 1 64-64h597.334zm0 64H213.333V704h149.334v63.296L459.243 704h351.424V277.333zm-271.36 213.334v64h-176.64v-64h176.64zm122.026-128v64H362.667v-64h298.666z", fill: "currentColor" })), Jf = () => ie("svg", { viewBox: "0 0 1024 1024", width: "24", height: "24" }, ie("path", { d: "M813.039 318.772L480.53 651.278H360.718V531.463L693.227 198.961C697.904 194.284 704.027 192 710.157 192C716.302 192 722.436 194.284 727.114 198.961L813.039 284.88C817.72 289.561 820 295.684 820 301.825C820 307.95 817.72 314.093 813.039 318.772ZM710.172 261.888L420.624 551.431V591.376H460.561L750.109 301.825L710.172 261.888ZM490.517 291.845H240.906V771.09H720.156V521.479C720.156 504.947 733.559 491.529 750.109 491.529C766.653 491.529 780.063 504.947 780.063 521.479V791.059C780.063 813.118 762.18 831 740.125 831H220.937C198.882 831 181 813.118 181 791.059V271.872C181 249.817 198.882 231.935 220.937 231.935H490.517C507.06 231.935 520.47 245.352 520.47 261.888C520.47 278.424 507.06 291.845 490.517 291.845Z", fill: "currentColor" })), Yf = () => ie("svg", { class: "verified-icon", viewBox: "0 0 1024 1024", width: "14", height: "14" }, ie("path", { d: "m894.4 461.56-54.4-63.2c-10.4-12-18.8-34.4-18.8-50.4v-68c0-42.4-34.8-77.2-77.2-77.2h-68c-15.6 0-38.4-8.4-50.4-18.8l-63.2-54.4c-27.6-23.6-72.8-23.6-100.8 0l-62.8 54.8c-12 10-34.8 18.4-50.4 18.4h-69.2c-42.4 0-77.2 34.8-77.2 77.2v68.4c0 15.6-8.4 38-18.4 50l-54 63.6c-23.2 27.6-23.2 72.4 0 100l54 63.6c10 12 18.4 34.4 18.4 50v68.4c0 42.4 34.8 77.2 77.2 77.2h69.2c15.6 0 38.4 8.4 50.4 18.8l63.2 54.4c27.6 23.6 72.8 23.6 100.8 0l63.2-54.4c12-10.4 34.4-18.8 50.4-18.8h68c42.4 0 77.2-34.8 77.2-77.2v-68c0-15.6 8.4-38.4 18.8-50.4l54.4-63.2c23.2-27.6 23.2-73.2-.4-100.8zm-216-25.2-193.2 193.2a30 30 0 0 1-42.4 0l-96.8-96.8a30.16 30.16 0 0 1 0-42.4c11.6-11.6 30.8-11.6 42.4 0l75.6 75.6 172-172c11.6-11.6 30.8-11.6 42.4 0 11.6 11.6 11.6 30.8 0 42.4z", fill: "#27ae60" })), In = ({ size: e = 100 }) => ie("svg", { width: e, height: e, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid" }, ie("circle", { cx: 50, cy: 50, fill: "none", stroke: "currentColor", strokeWidth: "4", r: "40", "stroke-dasharray": "85 30" }, ie("animateTransform", { attributeName: "transform", type: "rotate", repeatCount: "indefinite", dur: "1s", values: "0 50 50;360 50 50", keyTimes: "0;1" }))), Qf = () => ie("svg", { width: 24, height: 24, fill: "currentcolor", viewBox: "0 0 24 24" }, [ie("path", { style: "transform: translateY(0.5px)", d: "M18.968 10.5H15.968V11.484H17.984V12.984H15.968V15H14.468V9H18.968V10.5V10.5ZM8.984 9C9.26533 9 9.49967 9.09367 9.687 9.281C9.87433 9.46833 9.968 9.70267 9.968 9.984V10.5H6.499V13.5H8.468V12H9.968V14.016C9.968 14.2973 9.87433 14.5317 9.687 14.719C9.49967 14.9063 9.26533 15 8.984 15H5.984C5.70267 15 5.46833 14.9063 5.281 14.719C5.09367 14.5317 5 14.2973 5 14.016V9.985C5 9.70367 5.09367 9.46933 5.281 9.282C5.46833 9.09467 5.70267 9.001 5.984 9.001H8.984V9ZM11.468 9H12.968V15H11.468V9V9Z" }), ie("path", { d: "M18.5 3H5.75C3.6875 3 2 4.6875 2 6.75V18C2 20.0625 3.6875 21.75 5.75 21.75H18.5C20.5625 21.75 22.25 20.0625 22.25 18V6.75C22.25 4.6875 20.5625 3 18.5 3ZM20.75 18C20.75 19.2375 19.7375 20.25 18.5 20.25H5.75C4.5125 20.25 3.5 19.2375 3.5 18V6.75C3.5 5.5125 4.5125 4.5 5.75 4.5H18.5C19.7375 4.5 20.75 5.5125 20.75 6.75V18Z" })]), Xf = () => Yt("WALINE_USER_META", { nick: "", mail: "", link: "" }), eh = () => Yt("WALINE_COMMENT_BOX_EDITOR", ""), th = "WALINE_LIKE", nh = Yt(th, []), bo = () => nh, rh = "WALINE_REACTION", sh = Yt(rh, {}), ih = () => sh; var Es = {}, lt = {}, ot = {}, yo; function wo() { if (yo) return ot; yo = 1; var e = ot && ot.__awaiter || function (r, s, i, l) { function o(a) { return a instanceof i ? a : new i(function (c) { c(a) }) } return new (i || (i = Promise))(function (a, c) { function u(m) { try { d(l.next(m)) } catch (x) { c(x) } } function f(m) { try { d(l.throw(m)) } catch (x) { c(x) } } function d(m) { m.done ? a(m.value) : o(m.value).then(u, f) } d((l = l.apply(r, s || [])).next()) }) }, t = ot && ot.__generator || function (r, s) { var i = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, l, o, a, c; return c = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (c[Symbol.iterator] = function () { return this }), c; function u(d) { return function (m) { return f([d, m]) } } function f(d) { if (l) throw new TypeError("Generator is already executing."); for (; c && (c = 0, d[0] && (i = 0)), i;)try { if (l = 1, o && (a = d[0] & 2 ? o.return : d[0] ? o.throw || ((a = o.return) && a.call(o), 0) : o.next) && !(a = a.call(o, d[1])).done) return a; switch (o = 0, a && (d = [d[0] & 2, a.value]), d[0]) { case 0: case 1: a = d; break; case 4: return i.label++, { value: d[1], done: !1 }; case 5: i.label++, o = d[1], d = [0]; continue; case 7: d = i.ops.pop(), i.trys.pop(); continue; default: if (a = i.trys, !(a = a.length > 0 && a[a.length - 1]) && (d[0] === 6 || d[0] === 2)) { i = 0; continue } if (d[0] === 3 && (!a || d[1] > a[0] && d[1] < a[3])) { i.label = d[1]; break } if (d[0] === 6 && i.label < a[1]) { i.label = a[1], a = d; break } if (a && i.label < a[2]) { i.label = a[2], i.ops.push(d); break } a[2] && i.ops.pop(), i.trys.pop(); continue }d = s.call(r, i) } catch (m) { d = [6, m], o = 0 } finally { l = a = 0 } if (d[0] & 5) throw d[1]; return { value: d[0] ? d[1] : void 0, done: !0 } } }; Object.defineProperty(ot, "__esModule", { value: !0 }), ot.ReCaptchaInstance = void 0; var n = function () { function r(s, i, l) { this.siteKey = s, this.recaptchaID = i, this.recaptcha = l, this.styleContainer = null } return r.prototype.execute = function (s) { return e(this, void 0, void 0, function () { var i; return t(this, function (l) { switch (l.label) { case 0: return this.recaptcha.enterprise ? [4, this.recaptcha.enterprise.execute(this.recaptchaID, { action: s })] : [3, 2]; case 1: return i = l.sent(), [3, 4]; case 2: return [4, this.recaptcha.execute(this.recaptchaID, { action: s })]; case 3: i = l.sent(), l.label = 4; case 4: return [2, i] } }) }) }, r.prototype.getSiteKey = function () { return this.siteKey }, r.prototype.hideBadge = function () { this.styleContainer === null && (this.styleContainer = document.createElement("style"), this.styleContainer.innerHTML = ".grecaptcha-badge{visibility:hidden !important;}", document.head.appendChild(this.styleContainer)) }, r.prototype.showBadge = function () { this.styleContainer !== null && (document.head.removeChild(this.styleContainer), this.styleContainer = null) }, r }(); return ot.ReCaptchaInstance = n, ot } var ko; function lh() { if (ko) return lt; ko = 1; var e = lt && lt.__assign || function () { return e = Object.assign || function (s) { for (var i, l = 1, o = arguments.length; l < o; l++) { i = arguments[l]; for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (s[a] = i[a]) } return s }, e.apply(this, arguments) }; Object.defineProperty(lt, "__esModule", { value: !0 }), lt.getInstance = lt.load = void 0; var t = wo(), n; (function (s) { s[s.NOT_LOADED = 0] = "NOT_LOADED", s[s.LOADING = 1] = "LOADING", s[s.LOADED = 2] = "LOADED" })(n || (n = {})); var r = function () { function s() { } return s.load = function (i, l) { if (l === void 0 && (l = {}), typeof document > "u") return Promise.reject(new Error("This is a library for the browser!")); if (s.getLoadingState() === n.LOADED) return s.instance.getSiteKey() === i ? Promise.resolve(s.instance) : Promise.reject(new Error("reCAPTCHA already loaded with different site key!")); if (s.getLoadingState() === n.LOADING) return i !== s.instanceSiteKey ? Promise.reject(new Error("reCAPTCHA already loaded with different site key!")) : new Promise(function (a, c) { s.successfulLoadingConsumers.push(function (u) { return a(u) }), s.errorLoadingRunnable.push(function (u) { return c(u) }) }); s.instanceSiteKey = i, s.setLoadingState(n.LOADING); var o = new s; return new Promise(function (a, c) { o.loadScript(i, l.useRecaptchaNet || !1, l.useEnterprise || !1, l.renderParameters ? l.renderParameters : {}, l.customUrl).then(function () { s.setLoadingState(n.LOADED); var u = o.doExplicitRender(grecaptcha, i, l.explicitRenderParameters ? l.explicitRenderParameters : {}, l.useEnterprise || !1), f = new t.ReCaptchaInstance(i, u, grecaptcha); s.successfulLoadingConsumers.forEach(function (d) { return d(f) }), s.successfulLoadingConsumers = [], l.autoHideBadge && f.hideBadge(), s.instance = f, a(f) }).catch(function (u) { s.errorLoadingRunnable.forEach(function (f) { return f(u) }), s.errorLoadingRunnable = [], c(u) }) }) }, s.getInstance = function () { return s.instance }, s.setLoadingState = function (i) { s.loadingState = i }, s.getLoadingState = function () { return s.loadingState === null ? n.NOT_LOADED : s.loadingState }, s.prototype.loadScript = function (i, l, o, a, c) { var u = this; l === void 0 && (l = !1), o === void 0 && (o = !1), a === void 0 && (a = {}), c === void 0 && (c = ""); var f = document.createElement("script"); f.setAttribute("recaptcha-v3-script", ""), f.setAttribute("async", ""), f.setAttribute("defer", ""); var d = "https://www.google.com/recaptcha/api.js"; l ? o ? d = "https://recaptcha.net/recaptcha/enterprise.js" : d = "https://recaptcha.net/recaptcha/api.js" : o && (d = "https://www.google.com/recaptcha/enterprise.js"), c && (d = c), a.render && (a.render = void 0); var m = this.buildQueryString(a); return f.src = d + "?render=explicit" + m, new Promise(function (x, b) { f.addEventListener("load", u.waitForScriptToLoad(function () { x(f) }, o), !1), f.onerror = function (E) { s.setLoadingState(n.NOT_LOADED), b(E) }, document.head.appendChild(f) }) }, s.prototype.buildQueryString = function (i) { var l = Object.keys(i); return l.length < 1 ? "" : "&" + Object.keys(i).filter(function (o) { return !!i[o] }).map(function (o) { return o + "=" + i[o] }).join("&") }, s.prototype.waitForScriptToLoad = function (i, l) { var o = this; return function () { window.grecaptcha === void 0 ? setTimeout(function () { o.waitForScriptToLoad(i, l) }, s.SCRIPT_LOAD_DELAY) : l ? window.grecaptcha.enterprise.ready(function () { i() }) : window.grecaptcha.ready(function () { i() }) } }, s.prototype.doExplicitRender = function (i, l, o, a) { var c = e({ sitekey: l }, o); return o.container ? a ? i.enterprise.render(o.container, c) : i.render(o.container, c) : a ? i.enterprise.render(c) : i.render(c) }, s.loadingState = null, s.instance = null, s.instanceSiteKey = null, s.successfulLoadingConsumers = [], s.errorLoadingRunnable = [], s.SCRIPT_LOAD_DELAY = 25, s }(); return lt.load = r.load, lt.getInstance = r.getInstance, lt } var xo; function oh() { return xo || (xo = 1, function (e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.ReCaptchaInstance = e.getInstance = e.load = void 0; var t = lh(); Object.defineProperty(e, "load", { enumerable: !0, get: function () { return t.load } }), Object.defineProperty(e, "getInstance", { enumerable: !0, get: function () { return t.getInstance } }); var n = wo(); Object.defineProperty(e, "ReCaptchaInstance", { enumerable: !0, get: function () { return n.ReCaptchaInstance } }) }(Es)), Es } var ah = oh(); const _o = {}, ch = e => { const t = _o[e] ?? (_o[e] = ah.load(e, { useRecaptchaNet: !0, autoHideBadge: !0 })); return { execute: n => t.then(r => r.execute(n)) } }, uh = e => ({ execute: async t => { const { load: n } = Hu("https://challenges.cloudflare.com/turnstile/v0/api.js", void 0, { async: !1 }); await n(); const r = window.turnstile; return new Promise(s => { r == null || r.ready(() => { r.render(".wl-captcha-container", { sitekey: e, action: t, size: "compact", callback: s }) }) }) } }), fh = "WALINE_USER", hh = Yt(fh, {}), Ar = () => hh, ph = { key: 0, class: "wl-reaction" }, dh = ["textContent"], gh = { class: "wl-reaction-list" }, mh = ["onClick"], vh = { class: "wl-reaction-img" }, bh = ["src", "alt"], yh = ["textContent"], wh = ["textContent"]; var kh = mn({ __name: "ArticleReaction", setup(e) { const t = ih(), n = lr(Dn), r = ae(-1), s = ae([]), i = ve(() => n.value.locale), l = ve(() => { const { reaction: f } = n.value; return f != null && f.length ? f : null }), o = ve(() => { var f; const { path: d } = n.value; return ((f = l.value) == null ? void 0 : f.map((m, x) => ({ icon: m, desc: i.value[`reaction${x}`], active: t.value[d] === x }))) ?? null }); let a; const c = async () => { const { serverURL: f, lang: d, path: m } = n.value; if (!l.value) return; const x = new AbortController; a = x.abort.bind(x); const [b] = await Tr({ serverURL: f, lang: d, paths: [m], type: l.value.map((E, w) => `reaction${w}`), signal: x.signal }); s.value = l.value.map((E, w) => b[`reaction${w}`]) }, u = async f => { if (r.value !== -1) return; const { serverURL: d, lang: m, path: x } = n.value, b = t.value[x]; r.value = f, b !== void 0 && (await zn({ serverURL: d, lang: m, path: x, type: `reaction${b}`, action: "desc" }), s.value[b] = Math.max(s.value[b] - 1, 0)), b !== f && (await zn({ serverURL: d, lang: m, path: x, type: `reaction${f}` }), s.value[f] = (s.value[f] || 0) + 1), b === f ? delete t.value[x] : t.value[x] = f, r.value = -1 }; return yn(() => { Jt(() => [n.value.serverURL, n.value.path], () => c()) }), es(() => { a == null || a() }), (f, d) => o.value ? (L(), M("div", ph, [z("div", { class: "wl-reaction-title", textContent: ee(i.value.reactionTitle) }, null, 8, dh), z("ul", gh, [(L(!0), M(pe, null, De(o.value, ({ active: m, icon: x, desc: b }, E) => (L(), M("li", { key: E, class: be(["wl-reaction-item", { active: m }]), onClick: w => u(E) }, [z("div", vh, [z("img", { src: x, alt: b }, null, 8, bh), r.value === E ? (L(), nt(G(In), { key: 0, class: "wl-reaction-loading" })) : (L(), M("div", { key: 1, class: "wl-reaction-votes", textContent: ee(s.value[E] || 0) }, null, 8, yh))]), z("div", { class: "wl-reaction-text", textContent: ee(b) }, null, 8, wh)], 10, mh))), 128))])])) : X("v-if", !0) } }), Ln = new Map; function xh(e) { var t = Ln.get(e); t && t.destroy() } function _h(e) { var t = Ln.get(e); t && t.update() } var Mn = null; typeof window > "u" ? ((Mn = function (e) { return e }).destroy = function (e) { return e }, Mn.update = function (e) { return e }) : ((Mn = function (e, t) { return e && Array.prototype.forEach.call(e.length ? e : [e], function (n) { return function (r) { if (r && r.nodeName && r.nodeName === "TEXTAREA" && !Ln.has(r)) { var s, i = null, l = window.getComputedStyle(r), o = (s = r.value, function () { c({ testForHeightReduction: s === "" || !r.value.startsWith(s), restoreTextAlign: null }), s = r.value }), a = (function (f) { r.removeEventListener("autosize:destroy", a), r.removeEventListener("autosize:update", u), r.removeEventListener("input", o), window.removeEventListener("resize", u), Object.keys(f).forEach(function (d) { return r.style[d] = f[d] }), Ln.delete(r) }).bind(r, { height: r.style.height, resize: r.style.resize, textAlign: r.style.textAlign, overflowY: r.style.overflowY, overflowX: r.style.overflowX, wordWrap: r.style.wordWrap }); r.addEventListener("autosize:destroy", a), r.addEventListener("autosize:update", u), r.addEventListener("input", o), window.addEventListener("resize", u), r.style.overflowX = "hidden", r.style.wordWrap = "break-word", Ln.set(r, { destroy: a, update: u }), u() } function c(f) { var d, m, x = f.restoreTextAlign, b = x === void 0 ? null : x, E = f.testForHeightReduction, w = E === void 0 || E, $ = l.overflowY; if (r.scrollHeight !== 0 && (l.resize === "vertical" ? r.style.resize = "none" : l.resize === "both" && (r.style.resize = "horizontal"), w && (d = function (I) { for (var P = []; I && I.parentNode && I.parentNode instanceof Element;)I.parentNode.scrollTop && P.push([I.parentNode, I.parentNode.scrollTop]), I = I.parentNode; return function () { return P.forEach(function (W) { var Z = W[0], N = W[1]; Z.style.scrollBehavior = "auto", Z.scrollTop = N, Z.style.scrollBehavior = null }) } }(r), r.style.height = ""), m = l.boxSizing === "content-box" ? r.scrollHeight - (parseFloat(l.paddingTop) + parseFloat(l.paddingBottom)) : r.scrollHeight + parseFloat(l.borderTopWidth) + parseFloat(l.borderBottomWidth), l.maxHeight !== "none" && m > parseFloat(l.maxHeight) ? (l.overflowY === "hidden" && (r.style.overflow = "scroll"), m = parseFloat(l.maxHeight)) : l.overflowY !== "hidden" && (r.style.overflow = "hidden"), r.style.height = m + "px", b && (r.style.textAlign = b), d && d(), i !== m && (r.dispatchEvent(new Event("autosize:resized", { bubbles: !0 })), i = m), $ !== l.overflow && !b)) { var H = l.textAlign; l.overflow === "hidden" && (r.style.textAlign = H === "start" ? "end" : "start"), c({ restoreTextAlign: H, testForHeightReduction: !0 }) } } function u() { c({ testForHeightReduction: !0, restoreTextAlign: null }) } }(n) }), e }).destroy = function (e) { return e && Array.prototype.forEach.call(e.length ? e : [e], xh), e }, Mn.update = function (e) { return e && Array.prototype.forEach.call(e.length ? e : [e], _h), e }); var $o = Mn; const $h = ["data-index"], Ch = ["src", "title", "onClick"]; var Sh = mn({ __name: "ImageWall", props: { items: { default: () => [] }, columnWidth: { default: 300 }, gap: { default: 0 } }, emits: ["insert"], setup(e) { const t = e; let n = null; const r = dt("wall"), s = ae({}), i = ae([]), l = () => { const f = Math.floor((r.value.getBoundingClientRect().width + t.gap) / (t.columnWidth + t.gap)); return f > 0 ? f : 1 }, o = f => new Array(f).fill(null).map(() => []), a = async f => { var d; if (f >= t.items.length) return; await qt(); const m = Array.from(((d = r.value) == null ? void 0 : d.children) ?? []).reduce((x, b) => b.getBoundingClientRect().height < x.getBoundingClientRect().height ? b : x); i.value[Number(m.dataset.index)].push(f), await a(f + 1) }, c = async (f = !1) => { if (i.value.length === l() && !f) return; i.value = o(l()); const d = window.scrollY; await a(0), window.scrollTo({ top: d }) }, u = f => { s.value[f.target.src] = !0 }; return yn(() => { c(!0), n = new ResizeObserver(() => { c() }), n.observe(r.value), gt(() => [t.items], () => { s.value = {}, c(!0) }), gt(() => [t.columnWidth, t.gap], () => { c() }) }), rc(() => { n.unobserve(r.value) }), (f, d) => (L(), M("div", { ref_key: "wall", ref: r, class: "wl-gallery", style: on({ gap: `${f.gap}px` }) }, [(L(!0), M(pe, null, De(i.value, (m, x) => (L(), M("div", { key: x, class: "wl-gallery-column", "data-index": x, style: on({ gap: `${f.gap}px` }) }, [(L(!0), M(pe, null, De(m, b => (L(), M(pe, { key: b }, [s.value[f.items[b].src] ? X("v-if", !0) : (L(), nt(G(In), { key: 0, size: 36, style: { margin: "20px auto" } })), z("img", { class: "wl-gallery-item", src: f.items[b].src, title: f.items[b].title, loading: "lazy", onLoad: u, onClick: E => f.$emit("insert", `![](${f.items[b].src})`) }, null, 40, Ch)], 64))), 128))], 12, $h))), 128))], 4)) } }); const Rh = { key: 0, class: "wl-login-info" }, Ah = { class: "wl-avatar" }, Eh = ["title"], Th = ["title"], Ih = ["src"], Lh = ["title", "textContent"], Mh = { class: "wl-panel" }, Ph = ["for", "textContent"], Oh = ["id", "onUpdate:modelValue", "name", "type"], jh = ["placeholder"], zh = { class: "wl-preview" }, Fh = ["innerHTML"], Dh = { class: "wl-footer" }, Hh = { class: "wl-actions" }, Uh = { href: "https://guides.github.com/features/mastering-markdown/", title: "Markdown Guide", "aria-label": "Markdown is supported", class: "wl-action", target: "_blank", rel: "noopener noreferrer" }, Nh = ["title"], Vh = ["title"], Bh = ["title", "aria-label"], Wh = ["title"], qh = { class: "wl-info" }, Kh = { class: "wl-text-number" }, Gh = { key: 0 }, Zh = ["textContent"], Jh = ["textContent"], Yh = ["disabled"], Qh = ["placeholder"], Xh = { key: 1, class: "wl-loading" }, ep = { key: 0, class: "wl-tab-wrapper" }, tp = ["title", "onClick"], np = ["src", "alt"], rp = { key: 0, class: "wl-tabs" }, sp = ["onClick"], ip = ["src", "alt", "title"], lp = ["title"]; var Co = mn({
    __name: "CommentBox", props: { edit: {}, rootId: {}, replyId: {}, replyUser: {} }, emits: ["log", "cancelEdit", "cancelReply", "submit"], setup(e, { emit: t }) {
        const n = e, r = t, s = lr(Dn), i = eh(), l = Xf(), o = Ar(), a = ae({}), c = dt("textarea"), u = dt("image-uploader"), f = dt("emoji-button"), d = dt("emoji-popup"), m = dt("gif-button"), x = dt("gif-popup"), b = dt("gif-search"), E = ae({ tabs: [], map: {} }), w = ae(0), $ = ae(!1), H = ae(!1), I = ae(!1), P = ae(""), W = ae(0), Z = pn({ loading: !0, list: [] }), N = ae(0), ke = ae(!1), me = ae(""), U = ae(!1), Y = ae(!1), V = ve(() => s.value.locale), F = ve(() => !!o.value.token), Q = ve(() => s.value.imageUploader !== null), ne = O => { const R = c.value, q = R.selectionStart, h = R.selectionEnd || 0, p = R.scrollTop; i.value = R.value.substring(0, q) + O + R.value.substring(h, R.value.length), R.focus(), R.selectionStart = q + O.length, R.selectionEnd = q + O.length, R.scrollTop = p }, Je = ({ key: O, ctrlKey: R, metaKey: q }) => { U.value || (R || q) && O === "Enter" && Ue() }, at = async O => {
            const R = `![${s.value.locale.uploading} ${O.name}]()`; ne(R), U.value = !0; try {
                const q = await s.value.imageUploader(O); i.value = i.value.replace(R, `\r
![${O.name}](${q})`)
            } catch (q) { alert(q.message), i.value = i.value.replace(R, "") } finally { U.value = !1 }
        }, Qt = O => { var R; if ((R = O.dataTransfer) != null && R.items) { const q = Bl(O.dataTransfer.items); q && Q.value && (at(q), O.preventDefault()) } }, Pn = O => { if (O.clipboardData) { const R = Bl(O.clipboardData.items); R && Q.value && at(R) } }, Ot = () => { const O = u.value; O.files && Q.value && at(O.files[0]).then(() => { O.value = "" }) }, Ue = async () => { var O; const { serverURL: R, lang: q, login: h, wordLimit: p, requiredMeta: g, recaptchaV3Key: y, turnstileKey: k } = s.value, v = { comment: me.value, nick: l.value.nick, mail: l.value.mail, link: l.value.link, url: s.value.path, ua: await Nf() }; if (!n.edit) if (o.value.token) v.nick = o.value.display_name, v.mail = o.value.email, v.link = o.value.url; else { if (h === "force") return; if (g.includes("nick") && !v.nick) { a.value.nick.focus(), alert(V.value.nickError); return } if (g.includes("mail") && !v.mail || v.mail && !Xo(v.mail)) { a.value.mail.focus(), alert(V.value.mailError); return } v.nick || (v.nick = V.value.anonymous) } if (!v.comment) { c.value.focus(); return } if (!ke.value) { alert(V.value.wordHint.replace("$0", p[0].toString()).replace("$1", p[1].toString()).replace("$2", W.value.toString())); return } v.comment = go(v.comment, E.value.map), n.replyId && n.rootId && (v.pid = n.replyId, v.rid = n.rootId, v.at = n.replyUser), U.value = !0; try { y && (v.recaptchaV3 = await ch(y).execute("social")), k && (v.turnstile = await uh(k).execute("social")); const A = { serverURL: R, lang: q, token: o.value.token, comment: v }, C = await (n.edit ? tn({ objectId: n.edit.objectId, ...A }) : Fs(A)); if (U.value = !1, C.errmsg) { alert(C.errmsg); return } r("submit", C.data), i.value = "", P.value = "", await qt(), n.replyId && r("cancelReply"), (O = n.edit) != null && O.objectId && r("cancelEdit") } catch (A) { U.value = !1, alert(A.message) } }, On = O => { O.preventDefault(); const { lang: R, serverURL: q } = s.value; Us({ serverURL: q, lang: R }).then(h => { o.value = h, (h.remember ? localStorage : sessionStorage).setItem("WALINE_USER", JSON.stringify(h)), r("log") }) }, Er = () => { o.value = {}, localStorage.setItem("WALINE_USER", "null"), sessionStorage.setItem("WALINE_USER", "null"), r("log") }, jn = O => { O.preventDefault(); const { lang: R, serverURL: q } = s.value, h = 800, p = 800, g = (window.innerWidth - h) / 2, y = (window.innerHeight - p) / 2, k = new URLSearchParams({ lng: R, token: o.value.token }), v = window.open(`${q}/ui/profile?${k.toString()}`, "_blank", `width=${h},height=${p},left=${g},top=${y},scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no`); v == null || v.postMessage({ type: "TOKEN", data: o.value.token }, "*") }, kt = O => { var R, q, h, p; !((R = f.value) != null && R.contains(O.target)) && !((q = d.value) != null && q.contains(O.target)) && ($.value = !1), !((h = m.value) != null && h.contains(O.target)) && !((p = x.value) != null && p.contains(O.target)) && (H.value = !1) }, xt = async O => { var R; const { scrollTop: q, clientHeight: h, scrollHeight: p } = O.target, g = (h + q) / p, y = s.value.search, k = ((R = b.value) == null ? void 0 : R.value) ?? ""; g < .9 || Z.loading || Y.value || (Z.loading = !0, (y.more && Z.list.length ? await y.more(k, Z.list.length) : await y.search(k)).length ? Z.list = [...Z.list, ...y.more && Z.list.length ? await y.more(k, Z.list.length) : await y.search(k)] : Y.value = !0, Z.loading = !1, setTimeout(() => { O.target.scrollTop = q }, 50)) }, jt = Ru(O => { Z.list = [], Y.value = !1, xt(O) }, 300); return Lt("click", kt), Lt("message", ({ data: O }) => { !O || O.type !== "profile" || (o.value = { ...o.value, ...O.data }, [localStorage, sessionStorage].filter(R => R.getItem("WALINE_USER")).forEach(R => { R.setItem("WALINE_USER", JSON.stringify(o)) })) }), Jt([s, W], ([O, R]) => { const { wordLimit: q } = O; q ? R < q[0] && q[0] !== 0 ? (N.value = q[0], ke.value = !1) : R > q[1] ? (N.value = q[1], ke.value = !1) : (N.value = q[1], ke.value = !0) : (N.value = 0, ke.value = !0) }), gt(H, async O => { var R; if (!O) return; const q = s.value.search; b.value && (b.value.value = ""), Z.loading = !0, Z.list = await (((R = q.default) == null ? void 0 : R.call(q)) ?? q.search("")), Z.loading = !1 }), yn(() => { var O; (O = n.edit) != null && O.objectId && (i.value = n.edit.orig), Jt(() => i.value, R => { const { highlighter: q, texRenderer: h } = s.value; me.value = R, P.value = Ff(R, { emojiMap: E.value.map, highlighter: q, texRenderer: h }), W.value = Uf(R), R ? $o(c.value) : $o.destroy(c.value) }), Jt(() => s.value.emoji, async R => { E.value = await qu(R) }) }), (O, R) => { var q, h; return L(), M("div", { key: G(o).token, class: "wl-comment" }, [G(s).login !== "disable" && F.value && !((q = O.edit) != null && q.objectId) ? (L(), M("div", Rh, [z("div", Ah, [z("button", { type: "submit", class: "wl-logout-btn", title: V.value.logout, onClick: Er }, [ue(G(vo), { size: 14 })], 8, Eh), z("a", { href: "#", class: "wl-login-nick", "aria-label": "Profile", title: V.value.profile, onClick: jn }, [z("img", { src: G(o).avatar, alt: "avatar" }, null, 8, Ih)], 8, Th)]), z("a", { href: "#", class: "wl-login-nick", "aria-label": "Profile", title: V.value.profile, onClick: jn, textContent: ee(G(o).display_name) }, null, 8, Lh)])) : X("v-if", !0), z("div", Mh, [G(s).login !== "force" && G(s).meta.length && !F.value ? (L(), M("div", { key: 0, class: be(["wl-header", `item${G(s).meta.length}`]) }, [(L(!0), M(pe, null, De(G(s).meta, p => (L(), M("div", { key: p, class: "wl-header-item" }, [z("label", { for: `wl-${p}`, textContent: ee(V.value[p] + (G(s).requiredMeta.includes(p) || !G(s).requiredMeta.length ? "" : `(${V.value.optional})`)) }, null, 8, Ph), ir(z("input", { id: `wl-${p}`, ref_for: !0, ref: g => { g && (a.value[p] = g) }, "onUpdate:modelValue": g => G(l)[p] = g, class: be(["wl-input", `wl-${p}`]), name: p, type: p === "mail" ? "email" : "text" }, null, 10, Oh), [[gu, G(l)[p]]])]))), 128))], 2)) : X("v-if", !0), ir(z("textarea", { id: "wl-edit", ref: "textarea", "onUpdate:modelValue": R[0] || (R[0] = p => ye(i) ? i.value = p : null), class: "wl-editor", placeholder: O.replyUser ? `@${O.replyUser}` : V.value.placeholder, onKeydown: Je, onDrop: Qt, onPaste: Pn }, null, 40, jh), [[ds, G(i)]]), ir(z("div", zh, [R[7] || (R[7] = z("hr", null, null, -1)), z("h4", null, ee(V.value.preview) + ":", 1), z("div", { class: "wl-content", innerHTML: P.value }, null, 8, Fh)], 512), [[xl, I.value]]), z("div", Dh, [z("div", Hh, [z("a", Uh, [ue(G(Gf))]), ir(z("button", { ref: "emoji-button", type: "button", class: be(["wl-action", { active: $.value }]), title: V.value.emoji, onClick: R[1] || (R[1] = p => $.value = !$.value) }, [ue(G(Bf))], 10, Nh), [[xl, E.value.tabs.length]]), G(s).search ? (L(), M("button", { key: 0, ref: "gif-button", type: "button", class: be(["wl-action", { active: H.value }]), title: V.value.gif, onClick: R[2] || (R[2] = p => H.value = !H.value) }, [ue(G(Qf))], 10, Vh)) : X("v-if", !0), z("input", { id: "wl-image-upload", ref: "image-uploader", class: "upload", "aria-hidden": "true", type: "file", accept: ".png,.jpg,.jpeg,.webp,.bmp,.gif", onChange: Ot }, null, 544), Q.value ? (L(), M("label", { key: 1, for: "wl-image-upload", class: "wl-action", title: V.value.uploadImage, "aria-label": V.value.uploadImage }, [ue(G(Wf))], 8, Bh)) : X("v-if", !0), z("button", { type: "button", class: be(["wl-action", { active: I.value }]), title: V.value.preview, onClick: R[3] || (R[3] = p => I.value = !I.value) }, [ue(G(Kf))], 10, Wh)]), z("div", qh, [R[9] || (R[9] = z("div", { class: "wl-captcha-container" }, null, -1)), z("div", Kh, [rt(ee(W.value) + " ", 1), G(s).wordLimit ? (L(), M("span", Gh, [R[8] || (R[8] = rt("  /  ")), z("span", { class: be({ illegal: !ke.value }), textContent: ee(N.value) }, null, 10, Zh)])) : X("v-if", !0), rt("  " + ee(V.value.word), 1)]), G(s).login !== "disable" && !F.value ? (L(), M("button", { key: 0, type: "button", class: "wl-btn", onClick: On, textContent: ee(V.value.login) }, null, 8, Jh)) : X("v-if", !0), G(s).login !== "force" || F.value ? (L(), M("button", { key: 1, type: "submit", class: "primary wl-btn", title: "Cmd|Ctrl + Enter", disabled: U.value, onClick: Ue }, [U.value ? (L(), nt(G(In), { key: 0, size: 16 })) : (L(), M(pe, { key: 1 }, [rt(ee(V.value.submit), 1)], 64))], 8, Yh)) : X("v-if", !0)]), z("div", { ref: "gif-popup", class: be(["wl-gif-popup", { display: H.value }]) }, [z("input", { ref: "gif-search", type: "text", placeholder: V.value.gifSearchPlaceholder, onInput: R[4] || (R[4] = (...p) => G(jt) && G(jt)(...p)) }, null, 40, Qh), Z.list.length ? (L(), nt(Sh, { key: 0, items: Z.list, "column-width": 200, gap: 6, onInsert: R[5] || (R[5] = p => ne(p)), onScroll: xt }, null, 8, ["items"])) : X("v-if", !0), Z.loading ? (L(), M("div", Xh, [ue(G(In), { size: 30 })])) : X("v-if", !0)], 2), z("div", { ref: "emoji-popup", class: be(["wl-emoji-popup", { display: $.value }]) }, [(L(!0), M(pe, null, De(E.value.tabs, (p, g) => (L(), M(pe, { key: p.name }, [g === w.value ? (L(), M("div", ep, [(L(!0), M(pe, null, De(p.items, y => (L(), M("button", { key: y, type: "button", title: y, onClick: k => ne(`:${y}:`) }, [$.value ? (L(), M("img", { key: 0, class: "wl-emoji", src: E.value.map[y], alt: y, loading: "lazy", referrerPolicy: "no-referrer" }, null, 8, np)) : X("v-if", !0)], 8, tp))), 128))])) : X("v-if", !0)], 64))), 128)), E.value.tabs.length > 1 ? (L(), M("div", rp, [(L(!0), M(pe, null, De(E.value.tabs, (p, g) => (L(), M("button", { key: p.name, type: "button", class: be(["wl-tab", { active: w.value === g }]), onClick: y => w.value = g }, [z("img", { class: "wl-emoji", src: p.icon, alt: p.name, title: p.name, loading: "lazy", referrerPolicy: "no-referrer" }, null, 8, ip)], 10, sp))), 128))])) : X("v-if", !0)], 2)])]), O.replyId || (h = O.edit) != null && h.objectId ? (L(), M("button", { key: 1, type: "button", class: "wl-close", title: V.value.cancelReply, onClick: R[6] || (R[6] = p => O.replyId ? r("cancelReply") : r("cancelEdit")) }, [ue(G(vo), { size: 24 })], 8, lp)) : X("v-if", !0)]) }
    }
}); const op = ["id"], ap = { class: "wl-user", "aria-hidden": "true" }, cp = ["src"], up = { class: "wl-card" }, fp = { class: "wl-head" }, hp = ["href"], pp = { key: 1, class: "wl-nick" }, dp = ["textContent"], gp = ["textContent"], mp = ["textContent"], vp = ["textContent"], bp = ["textContent"], yp = { class: "wl-comment-actions" }, wp = ["title"], kp = ["title"], xp = { class: "wl-meta", "aria-hidden": "true" }, _p = ["data-value", "textContent"], $p = { key: 0, class: "wl-content" }, Cp = { key: 0 }, Sp = ["href"], Rp = ["innerHTML"], Ap = { key: 1, class: "wl-admin-actions" }, Ep = { class: "wl-comment-status" }, Tp = ["disabled", "onClick", "textContent"], Ip = { key: 3, class: "wl-quote" }; var Lp = mn({ __name: "CommentCard", props: { comment: {}, edit: {}, rootId: {}, reply: {} }, emits: ["log", "submit", "delete", "like", "sticky", "edit", "reply", "status"], setup(e, { emit: t }) { const n = e, r = t, s = ["approved", "waiting", "spam"], i = lr(Dn), l = bo(), o = Du(), a = Ar(), c = ve(() => i.value.locale), u = ve(() => { const { link: w } = n.comment; return w ? ai(w) ? w : `https://${w}` : "" }), f = ve(() => l.value.includes(n.comment.objectId)), d = ve(() => Yo(new Date(n.comment.time), o.value, c.value)), m = ve(() => a.value.type === "administrator"), x = ve(() => n.comment.user_id && a.value.objectId === n.comment.user_id), b = ve(() => { var w; return n.comment.objectId === ((w = n.reply) == null ? void 0 : w.objectId) }), E = ve(() => { var w; return n.comment.objectId === ((w = n.edit) == null ? void 0 : w.objectId) }); return (w, $) => { var H; const I = ic("CommentCard", !0); return L(), M("div", { id: w.comment.objectId.toString(), class: "wl-card-item" }, [z("div", ap, [w.comment.avatar ? (L(), M("img", { key: 0, class: "wl-user-avatar", src: w.comment.avatar, alt: "" }, null, 8, cp)) : X("v-if", !0), w.comment.type ? (L(), nt(G(Yf), { key: 1 })) : X("v-if", !0)]), z("div", up, [z("div", fp, [u.value ? (L(), M("a", { key: 0, class: "wl-nick", href: u.value, target: "_blank", rel: "nofollow noopener noreferrer" }, ee(w.comment.nick), 9, hp)) : (L(), M("span", pp, ee(w.comment.nick), 1)), w.comment.type === "administrator" ? (L(), M("span", { key: 2, class: "wl-badge", textContent: ee(c.value.admin) }, null, 8, dp)) : X("v-if", !0), w.comment.label ? (L(), M("span", { key: 3, class: "wl-badge", textContent: ee(w.comment.label) }, null, 8, gp)) : X("v-if", !0), w.comment.sticky ? (L(), M("span", { key: 4, class: "wl-badge", textContent: ee(c.value.sticky) }, null, 8, mp)) : X("v-if", !0), typeof w.comment.level == "number" ? (L(), M("span", { key: 5, class: be(`wl-badge level${w.comment.level}`), textContent: ee(c.value[`level${w.comment.level}`] || `Level ${w.comment.level}`) }, null, 10, vp)) : X("v-if", !0), z("span", { class: "wl-time", textContent: ee(d.value) }, null, 8, bp), z("div", yp, [m.value || x.value ? (L(), M(pe, { key: 0 }, [z("button", { type: "button", class: "wl-edit", onClick: $[0] || ($[0] = P => r("edit", w.comment)) }, [ue(G(Jf))]), z("button", { type: "button", class: "wl-delete", onClick: $[1] || ($[1] = P => r("delete", w.comment)) }, [ue(G(Vf))])], 64)) : X("v-if", !0), z("button", { type: "button", class: "wl-like", title: f.value ? c.value.cancelLike : c.value.like, onClick: $[2] || ($[2] = P => r("like", w.comment)) }, [ue(G(qf), { active: f.value }, null, 8, ["active"]), rt(" " + ee("like" in w.comment ? w.comment.like : ""), 1)], 8, wp), z("button", { type: "button", class: be(["wl-reply", { active: b.value }]), title: b.value ? c.value.cancelReply : c.value.reply, onClick: $[3] || ($[3] = P => r("reply", b.value ? null : w.comment)) }, [ue(G(Zf))], 10, kp)])]), z("div", xp, [(L(), M(pe, null, De(["addr", "browser", "os"], P => (L(), M(pe, null, [w.comment[P] ? (L(), M("span", { key: P, class: be(`wl-${P}`), "data-value": w.comment[P], textContent: ee(w.comment[P]) }, null, 10, _p)) : X("v-if", !0)], 64))), 64))]), E.value ? X("v-if", !0) : (L(), M("div", $p, ["reply_user" in w.comment && w.comment.reply_user ? (L(), M("p", Cp, [z("a", { href: "#" + w.comment.pid }, "@" + ee(w.comment.reply_user.nick), 9, Sp), $[17] || ($[17] = z("span", null, ": ", -1))])) : X("v-if", !0), z("div", { innerHTML: w.comment.comment }, null, 8, Rp)])), m.value && !E.value ? (L(), M("div", Ap, [z("span", Ep, [(L(), M(pe, null, De(s, P => z("button", { key: P, type: "submit", class: be(`wl-btn wl-${P}`), disabled: w.comment.status === P, onClick: W => r("status", { status: P, comment: w.comment }), textContent: ee(c.value[P]) }, null, 10, Tp)), 64))]), m.value && !("rid" in w.comment) ? (L(), M("button", { key: 0, type: "submit", class: "wl-btn wl-sticky", onClick: $[4] || ($[4] = P => r("sticky", w.comment)) }, ee(w.comment.sticky ? c.value.unsticky : c.value.sticky), 1)) : X("v-if", !0)])) : X("v-if", !0), b.value || E.value ? (L(), M("div", { key: 2, class: be({ "wl-reply-wrapper": b.value, "wl-edit-wrapper": E.value }) }, [ue(Co, { edit: w.edit, "reply-id": (H = w.reply) == null ? void 0 : H.objectId, "reply-user": w.comment.nick, "root-id": w.rootId, onLog: $[5] || ($[5] = P => r("log")), onCancelReply: $[6] || ($[6] = P => r("reply", null)), onCancelEdit: $[7] || ($[7] = P => r("edit", null)), onSubmit: $[8] || ($[8] = P => r("submit", P)) }, null, 8, ["edit", "reply-id", "reply-user", "root-id"])], 2)) : X("v-if", !0), "children" in w.comment ? (L(), M("div", Ip, [(L(!0), M(pe, null, De(w.comment.children, P => (L(), nt(I, { key: P.objectId, comment: P, reply: w.reply, edit: w.edit, "root-id": w.rootId, onLog: $[9] || ($[9] = W => r("log")), onDelete: $[10] || ($[10] = W => r("delete", W)), onEdit: $[11] || ($[11] = W => r("edit", W)), onLike: $[12] || ($[12] = W => r("like", W)), onReply: $[13] || ($[13] = W => r("reply", W)), onStatus: $[14] || ($[14] = W => r("status", W)), onSticky: $[15] || ($[15] = W => r("sticky", W)), onSubmit: $[16] || ($[16] = W => r("submit", W)) }, null, 8, ["comment", "reply", "edit", "root-id"]))), 128))])) : X("v-if", !0)])], 8, op) } } }); const So = "3.6.0", Mp = { "data-waline": "" }, Pp = { class: "wl-meta-head" }, Op = { class: "wl-count" }, jp = ["textContent"], zp = { class: "wl-sort" }, Fp = ["onClick"], Dp = { class: "wl-cards" }, Hp = { key: 1, class: "wl-operation" }, Up = ["textContent"], Np = { key: 2, class: "wl-loading" }, Vp = ["textContent"], Bp = { key: 4, class: "wl-operation" }, Wp = ["textContent"], qp = { key: 5, class: "wl-power" }; var Kp = mn({ __name: "WalineComment", props: { serverURL: {}, path: {}, meta: {}, requiredMeta: {}, wordLimit: {}, pageSize: {}, lang: {}, locale: {}, commentSorting: {}, dark: { type: [String, Boolean] }, login: {}, noCopyright: { type: Boolean }, recaptchaV3Key: {}, turnstileKey: {}, reaction: { type: [Array, Boolean] }, emoji: {}, search: {}, highlighter: { type: Function }, imageUploader: { type: Function }, texRenderer: { type: Function } }, setup(e) { const t = e, n = Ar(), r = bo(), s = ae("loading"), i = ae(0), l = ae(1), o = ae(0), a = ve(() => Go(t)), c = ae(a.value.commentSorting), u = ae([]), f = ae(null), d = ae(null), m = ve(() => Zo(a.value.dark)), x = ve(() => a.value.locale); Nu(m, { id: "waline-darkmode" }); let b = null; const E = U => { const { serverURL: Y, path: V, pageSize: F } = a.value, Q = new AbortController; s.value = "loading", b == null || b(), zs({ serverURL: Y, lang: a.value.lang, path: V, pageSize: F, sortBy: ii[c.value], page: U, signal: Q.signal, token: n.value.token }).then(ne => { s.value = "success", i.value = ne.count, u.value.push(...ne.data), l.value = U, o.value = ne.totalPages }).catch(ne => { ne.name !== "AbortError" && (console.error(ne.message), s.value = "error") }), b = Q.abort.bind(Q) }, w = () => { E(l.value + 1) }, $ = () => { i.value = 0, u.value = [], E(1) }, H = U => { c.value !== U && (c.value = U, $()) }, I = U => { f.value = U }, P = U => { d.value = U }, W = U => { if (d.value) d.value.comment = U.comment, d.value.orig = U.orig; else if ("rid" in U) { const Y = u.value.find(({ objectId: V }) => V === U.rid); if (!Y) return; Array.isArray(Y.children) || (Y.children = []), Y.children.push(U) } else u.value.unshift(U), i.value += 1 }, Z = async ({ comment: U, status: Y }) => { if (U.status === Y) return; const { serverURL: V, lang: F } = a.value; await tn({ serverURL: V, lang: F, token: n.value.token, objectId: U.objectId, comment: { status: Y } }), U.status = Y }, N = async U => { if ("rid" in U) return; const { serverURL: Y, lang: V } = a.value; await tn({ serverURL: Y, lang: V, token: n.value.token, objectId: U.objectId, comment: { sticky: U.sticky ? 0 : 1 } }), U.sticky = !U.sticky }, ke = async ({ objectId: U }) => { if (!confirm("Are you sure you want to delete this comment?")) return; const { serverURL: Y, lang: V } = a.value; await Ds({ serverURL: Y, lang: V, token: n.value.token, objectId: U }), u.value.some((F, Q) => F.objectId === U ? (u.value = u.value.filter((ne, Je) => Je !== Q), !0) : F.children.some((ne, Je) => ne.objectId === U ? (u.value[Q].children = F.children.filter((at, Qt) => Qt !== Je), !0) : !1)) }, me = async U => { const { serverURL: Y, lang: V } = a.value, { objectId: F } = U, Q = r.value.includes(F); await tn({ serverURL: Y, lang: V, objectId: F, token: n.value.token, comment: { like: !Q } }), Q ? r.value = r.value.filter(ne => ne !== F) : (r.value = [...r.value, F], r.value.length > 50 && (r.value = r.value.slice(-50))), U.like = Math.max(0, (U.like || 0) + (Q ? -1 : 1)) }; return fc(Dn, a), yn(() => { Jt(() => [t.serverURL, t.path], () => { $() }) }), es(() => { b == null || b() }), (U, Y) => (L(), M("div", Mp, [ue(kh), !f.value && !d.value ? (L(), nt(Co, { key: 0, onLog: $, onSubmit: W })) : X("v-if", !0), z("div", Pp, [z("div", Op, [i.value ? (L(), M("span", { key: 0, class: "wl-num", textContent: ee(i.value) }, null, 8, jp)) : X("v-if", !0), rt(" " + ee(x.value.comment), 1)]), z("ul", zp, [(L(!0), M(pe, null, De(G(qo), V => (L(), M("li", { key: V, class: be([V === c.value ? "active" : ""]), onClick: F => H(V) }, ee(x.value[V]), 11, Fp))), 128))])]), z("div", Dp, [(L(!0), M(pe, null, De(u.value, V => (L(), nt(Lp, { key: V.objectId, "root-id": V.objectId, comment: V, reply: f.value, edit: d.value, onLog: $, onReply: I, onEdit: P, onSubmit: W, onStatus: Z, onDelete: ke, onSticky: N, onLike: me }, null, 8, ["root-id", "comment", "reply", "edit"]))), 128))]), s.value === "error" ? (L(), M("div", Hp, [z("button", { type: "button", class: "wl-btn", onClick: $, textContent: ee(x.value.refresh) }, null, 8, Up)])) : s.value === "loading" ? (L(), M("div", Np, [ue(G(In), { size: 30 })])) : u.value.length ? l.value < o.value ? (L(), M("div", Bp, [z("button", { type: "button", class: "wl-btn", onClick: w, textContent: ee(x.value.more) }, null, 8, Wp)])) : X("v-if", !0) : (L(), M("div", { key: 3, class: "wl-empty", textContent: ee(x.value.sofa) }, null, 8, Vp)), a.value.noCopyright ? X("v-if", !0) : (L(), M("div", qp, [Y[0] || (Y[0] = rt(" Powered by ")), Y[1] || (Y[1] = z("a", { href: "https://github.com/walinejs/waline", target: "_blank", rel: "noopener noreferrer" }, " Waline ", -1)), rt(" v" + ee(G(So)), 1)]))])) } }); const Ro = (e, t) => { t.forEach((n, r) => { const s = e[r].time; typeof s == "number" && (n.innerText = s.toString()) }) }, Ao = ({ serverURL: e, path: t = window.location.pathname, selector: n = ".waline-pageview-count", update: r = !0, lang: s = navigator.language }) => { const i = new AbortController, l = Array.from(document.querySelectorAll(n)), o = c => { const u = As(c); return u !== null && t !== u }, a = c => Ns({ serverURL: Hn(e), paths: c.map(u => As(u) ?? t), lang: s, signal: i.signal }).then(u => Ro(u, c)).catch(Vl); if (r) { const c = l.filter(f => !o(f)), u = l.filter(o); Vs({ serverURL: Hn(e), path: t, lang: s }).then(f => Ro(f, c)), u.length && a(u) } else a(l); return i.abort.bind(i) }, Gp = ({ el: e = "#waline", path: t = window.location.pathname, comment: n = !1, pageview: r = !1, ...s }) => { const i = e ? vs(e) : null; if (e && !i) throw new Error("Option 'el' do not match any domElement!"); if (!s.serverURL) throw new Error("Option 'serverURL' is missing!"); const l = pn({ ...s }), o = pn({ comment: n, pageview: r, path: t }), a = () => { o.comment && mo({ serverURL: l.serverURL, path: o.path, ...zt(o.comment) ? { selector: o.comment } : {} }) }, c = () => { o.pageview && Ao({ serverURL: l.serverURL, path: o.path, ...zt(o.pageview) ? { selector: o.pageview } : {} }) }; let u = null; i && (u = yu(() => ie(Kp, { path: o.path, ...l })), u.mount(i)); const f = sl(a), d = sl(c); return { el: i, update: ({ comment: m, pageview: x, path: b = window.location.pathname, ...E } = {}) => { Object.entries(E).forEach(([w, $]) => { l[w] = $ }), o.path = b, m !== void 0 && (o.comment = m), x !== void 0 && (o.pageview = x) }, destroy: () => { u == null || u.unmount(), f(), d() } } }, Zp = ({ el: e, serverURL: t, count: n, lang: r = navigator.language }) => { const s = Ar(), i = vs(e), l = new AbortController; return Bs({ serverURL: t, count: n, lang: r, signal: l.signal, token: s.value.token }).then(o => i && o.length ? (i.innerHTML = `<ul class="wl-recent-list">${o.map(a => `<li class="wl-recent-item"><a href="${a.url}">${a.nick}</a>：${a.comment}</li>`).join("")}</ul>`, { comments: o, destroy: () => { l.abort(), i.innerHTML = "" } }) : { comments: o, destroy: () => l.abort() }) }, Jp = ({ el: e, serverURL: t, count: n, locale: r, lang: s = navigator.language, mode: i = "list" }) => { const l = vs(e), o = new AbortController; return Ws({ serverURL: t, pageSize: n, lang: s, signal: o.signal }).then(a => !l || !a.length ? { users: a, destroy: () => o.abort() } : (r = { ...ri(s), ...typeof r == "object" ? r : {} }, l.innerHTML = `<ul class="wl-user-${i}">${a.map((c, u) => [`<li class="wl-user-item" aria-label="${c.nick}">`, c.link && `<a href="${c.link}" target="_blank">`, '<div class="wl-user-avatar">', `<img src="${c.avatar}" alt="${c.nick}">`, `<span class="wl-user-badge">${u + 1}</span>`, "</div>", '<div class="wl-user-meta">', '<div class="wl-user-name">', c.nick, c.level && `<span class="wl-badge">${r ? r[`level${c.level}`] : `Level ${c.level}`}</span>`, c.label && `<span class="wl-badge">${c.label}</span>`, "</div>", c.link && c.link, "</div>", c.link && "</a>", "</li>"].filter(f => f).join("")).join("")}</ul>`, { users: a, destroy: () => { o.abort(), l.innerHTML = "" } })) }; export { Zp as RecentComments, Jp as UserList, Fs as addComment, mo as commentCount, Fn as defaultLocales, Ds as deleteComment, Hs as fetchCommentCount, Tr as getArticleCounter, zs as getComment, Ns as getPageview, Bs as getRecentComment, Ws as getUserList, Gp as init, Us as login, Ao as pageviewCount, zn as updateArticleCounter, tn as updateComment, Vs as updatePageview, So as version };
//# sourceMappingURL=waline.js.map
