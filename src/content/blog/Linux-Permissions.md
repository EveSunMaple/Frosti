---
draft: true
title: "[Linux] Linux用户权限、文件权限、权限操作相关介绍"
pubDate: "2022-07-09"
description: "Linux下有两种用户: 超级用户(root)、普通用户"
image: https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306251758851.webp
categories:
    - Blogs
tags:
    - Linux系统
---

# Linux 权限的概念

## Linux 用户

**Linux下有两种用户: 超级用户(root)、普通用户**

其中, **root用户的权限** 在Linux中可以看作是 **不受任何管控** 的, 就像 **Windows中的管理员**: 

![|medium](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707210706574.webp)

而除了 **root 之外的其他的所有用户都只是 普通用户**, 普通用户的权限是 **受到管控** 的

> **root 和 所有普通用户 都是需要设置密码的**, 且root和其他用户的密码最好不要设置为相同的, 因为有时输入密码用户可能无法区分 系统所需要的是什么密码

**`whoami`** 是一句指令, 可以显示的当前用户是谁: 

![|medium](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707203154013.webp)

**`su 用户名`** 可以切换用户, `su -` 和 `su` 默认切换为 `root`, 登录到其他用户之后, 可以使用 `exit` 指令退出 : 

![ |large](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707203745164.webp)

**root用户** 的命令提示符是 `#` , 而 **普通用户** 的命令提示符是`$`: 

![|large](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707204101500.webp)

> 虽然 **普通用户** 的权限是受限制的, 但是其实 普通用户 在执行命令时可以, 可以 **通过 `sudo` 来临时提升权限** 为超级用户权限（需要在信任列表中配置）

## Linux 权限

在理解 Linux权限 之前, 先理解一下 **生活中什么是权限？**

通俗来讲生活中的权限就是: 对于一件事物, 人可以对其做什么, 不能对其做什么
**举个例子**: 你的好友有一本书, 他让你看这本书, 但是不让你在书上乱涂乱画, 也不让你带走这本书, 更不让你毁坏这本书。这样, 你对这本书的权限就是: 可看、不可画、不可带走、不可毁坏；而你的朋友对这本书的权限(如果没有更高层次的约束: 比如父母 doge)就是: 可看、可画、可带走、可毁坏, 只是他愿不愿意罢了。并且, 两人都不能用这本书炒菜, 因为这本书本来就没这种功能。这种事物本身不具有的不能成为权限。

而 **Linux权限** 也是如此, 不过在 Linux系统 中, **你和朋友及其他人 都被称为用户, 这些用户对文件可以做什么, 不可以做什么, 就是 Linux权限**

## Linux 文件访问者

首先, 在上面介绍权限时, 提到了 **用户**

在 Linux系统 中存在不同的用户: root 和 其他。**Linux系统中的文件, 也是由用户访问的, 而对于每个文件的访问用户又可以被分为三种**

1. 文件和文件目录的所有者: **`u---User`**

    什么是所有者？顾名思义就是 **文件当前的所有者`User`**

    在上一篇Linux文章中介绍 `ls` 指令时, 介绍了 `-l` 选项, 可以将文件详细属性列出来: 

    ![ |large](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707210225645.webp)

    默认情况下, 谁创建的文件谁就是文件的拥有者, 但是**拥有者是可以更改的**

2. 文件和文件目录的所有者所在的组的用户: **`g---Grouper`**

    什么是组？在日常生活中, 无论是上学还是公司, 都有非常的大的概率会进行分组

    **Linux 系统中也是如此**, Linux中的 **用户可以进行分组`Group`**, 当前用户所属组的其他用户, 就是`Grouper`

    ![ |large](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707211121412.webp)

3. 其它用户: **`o---Others`**

    **除文件的所有者和其所在组的用户之外的用户, 统称为其他用户**

    也就是说, 如果文件的**所有者是普通用户**, 其所在的**组用户也都是普通用户**, **即便是root 也得称为其他用户**

    由于 对一个文件来说, 它的访问者的身份都是相对的, 所有者和其所在的组用户和相对的其他用户, 所以 **文件的详细属性是不显示其他用户的, 也无法显示完全**

    > 为什么说: **对与一个文件, 它的访问者的身份都是相对的**
    >
    > 因为当这个文件的所有者是 root 时, 此文件的其他用户就是其他的普通用户
    >
    > 当这个文件的所有者是 普通用户时, 如果root没在此用户组内, root也只能是此文件的其他用户
    >
    > 即, 文件访问者只是一种身份

也可以说 **`Linux权限就是围绕着用户和文件属性展开的`**

# Linux 权限管理

## Linux 文件类型、访问权限

在 `ls -l` 列出文件详细属性时, 有一列由 `d` `-` `r` `w` `x` 等组成的内容, 这些内容都是什么意思呢？

![|large](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707213335537.webp)

这些东西, 其实表示的是 **文件的类型和访问权限**

**Linux系统 是 不以文件后缀来区分文件类型的, 而是通过详细属性中第一个字符来区分文件类型的**

![|large](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707213843826.webp)

Linux系统规定: 

| 符号    | 类型                               |
| ------- | ---------------------------------- |
| **`d`** | 目录文件                           |
| **`-`** | 普通文件                           |
| **`l`** | 软链接（类似Windows的快捷方式）    |
| **`b`** | 块设备文件（例如硬盘、光驱等）     |
| **`p`** | 管道文件                           |
| **`c`** | 字符设备文件（例如屏幕等串口设备） |
| **`s`** | 套接口文件                         |

而在Linux系统中 一般接触到的文件, **90%** 都是 `d 目录文件` 和 `- 普通文件` 的

**`d 目录文件`**不必多说, 那么什么是**`- 普通文件`**呢？
其实, **Linux系统中的 文本文件, 源代码文件, 可执行程序, 第三方动、静态库等 都是普通文件**, 把握不准的可以 `ll 或 ls -l` 查看详细属性区分

> `ll` 和 `ls -l` 作用基本一样, 单位区别
>
> ![ |large](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707214554669.webp)

> 注意: **不以文件后缀来区分文件类型的是 Linux系统, 而不是系统上的其他软件**
>
> 比如: 
>
> 使用**gcc编译一个非`.c`后缀的文件会报错**: 
>
> ![ |large](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707220304354.webp)
>
> 这就说明了, gcc这个软件是需要检测到文件的后缀是`.c`的

那串符号中的第一个字符, 已经知道是啥意思了, 那后面的 9个字符呢？

后面的 其实**表示`此文件的访问权限`**: 

![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707214923020.webp)

文件详细属性的第一列的后 9位字符, **以 每3位 为一部份, 分别表示 所有者权限、所在组权限、其他成员权限** : 

![ |large](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707223459480.webp)

这 9 位字符只由 `r` `w` `x` `-` 组成, 且 3个 为一组, 其中: 

1. `r` :  read 代表读权限, `r`表示可读, `-`表示不可读
2. `w` : write 代表写权限, `w`表示可写, `-`表示不可写
3. `x` : execute 代表执行权限, `x`表示可执行, `-`表示不可执行

并且, **每3位中 读写执行权限的位置是固定的**, 顺序必须为 `rwx` 不能为 `wrx` 或 `xrw`, 即: 
**每三位中, 首位读权限, 次位写权限, 末尾执行权限**

### file 文件类型显示

`file` 是一个指令, 可以辨识指定文件的类型

功能说明: 辨识文件类型
语法: **`file [选项] 文件或目录...`**
常用选项: 

| 选项     | 功能                                                 |
| -------- | ---------------------------------------------------- |
| **`-c`** | 详细显示指令执行过程, 便于排错或分析程序执行的情形。 |
| **`-z`** | 尝试去解读压缩文件的内容                             |

![ |huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708141939043.webp)

> `file` 没有` .c` 后缀, 也可以识别出它是 *C语言源文件*, 因为 Linux不以文件后缀识别文件类型

## Linux 文件访问权限的相关设置

上面介绍了 *Linux系统中文件的类型和文件访问的权限*, 其实**这些属性是可以修改的**

### 访问权限的修改

> **只有文件的拥有者和root才可以改变文件的权限**

修改访问权限的方法有两种, 但都是通过**`chmod`**实现的: 

> **`chmod` 中的 `ch` 为 `change` 的缩写**

1. **`chmod [选项] 身份+/-/=权限 文件`**

    其实用法就像这样: 
    
    ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707232422952.webp)
    
    > **`chmod [选项] 身份+/-/=权限 文件: `**
    >
    > 1. **选项**
    >
    >     | 选项    | 功能                                   |
    >     | ------- | -------------------------------------- |
    >     | **`R`** | 对目录使用, 递归修改目录内所有文件权限 |
    >
    >     2. **身份**
    >
    >     `u` : `user` 表示所有者权限
    >
    >     `g` : `grouper` 表示组成员权限
    >
    >     `o` : `others` 表示其他成员权限
    >
    >     `a` : `all` 表示所有成员
    >
    > 3. **+/-**
    >
    >     `+` : 表示增添权限
    >
    >     `-` : 表示取消权限
    >
    >     `=` : 表示只赋予权限, 一般与 `a` 结合使用
    >
    > 4. **权限**
    >
    >     `r` : `read` 表示读权限
    >
    >     `w` : `write` 表示写权限
    >
    >     `x` : `execute` 表示执行权限
    >
    > 可以使用 **`chmod a=权限 文件`**, **只赋予** 所有成员相应的权限, 什么是只赋予呢？: 
    >
    > ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707233338315.webp)
    >
    > 当然, **`=` 后可跟多个权限**
    
2. **`chmod 权限八进制 文件`**

    通过观察可以发现, 各权限(读、写、执行)**只存在 可和不可 两种状态, 可以看作一种二进制的形式**
    而对应**用户身份权限的表示 又是每三位表示一种用户, 这三位结合就可以看作是一种八进制**

    > 举例子: 
    >
    > 对于文件所有者, 一共存在这八种权限情况: 
    >
    > `---` `--x` `-w-` `-wx` `r--` `r-x` `rw-` `rwx` 
    > 可以看作一种二进制, 分别对应
    > `000` `001` `010` `011` `100` `101` `110` `111`
    > 即八进制的: `0` `1` `2` `3` `4` `5` `6` `7`
    >
    > Linux也就就可以直接使用这种类八进制的方式, 设置权限

    用法: 
    
    ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220707234309136.webp)

### 访问用户的修改

文件的访问权限可以修改, **其所属用户即组也都可以修改**

> 修改文件的所有者, 就像赠送别人东西, 是**需要经过被赠人的同意**的, 正所谓: **己所不欲勿施于人** doge
>
> 所以, 修改文件的所有者, 其实也是需要新所有者同意的
> 但是, **修改所有者的动作并不是一个请求动作, 被赠人也不能主动同意, 所以只能让其被动同意**
>
> 怎么让其被动同意呢？
> **使用 `root` 修改, 或者 `sudo` 临时提升权限**, `root` 就像是上帝, 是不受任何限制的, `sudo` 可将此操作提升到同等的地位
>
> 如果没有使用 `root用户` 或 `sudo` 就会提示: 
>
> ![ |huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708100741021.webp)
>
> PS: 想要将文件给某个用户, 此系统需要有此用户

1. `chown`

    功能: 修改文件的拥有者
    格式: **`chown [选项] 用户名 文件名`**
    选项: 

    | 选项     | 功能                                   |
    | -------- | -------------------------------------- |
    | **`-R`** | 对目录使用, 递归修改目录内所有文件权限 |

    `chown` 可以将文件的所有者, 改为其他用户: 

    ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708100923223.webp)

2. `chgrp`

    功能: 修改文件或目录的所属组
    格式:  **`chgrp [参数] 用户组名 文件名`**
    常用选项: 

    | 选项     | 功能                                   |
    | -------- | -------------------------------------- |
    | **`-R`** | 对目录使用, 递归修改目录内所有文件权限 |

    ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708101302537.webp)

### 相关问题 *

文件权限、用户对其所属关系的修改, 已经介绍过了

但是还有一些问题: 

> 1. 问题1: 进入目录需要什么权限?
>
>     为了得到答案, 可以逐权限测试:
>
>     **读权限:**
>
>     ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708094840323.webp)
>
>     **写权限:** 
>
>     ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708095019590.webp)
>
>     **执行权限:**
>
>     ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708095253026.webp)
>
>     可以看到, **想要进入目录, 访问者需要有执行权限**
>
> 2. 问题2: 查看文件是怎么样查看的？目录文件又是怎么查看的？
>
>     之前指令中提到, 查看文本文件可以直接使用 `cat` `more` `less`:
>
>     ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708095939616.webp)
>
>     那么, **目录文件的内容是怎么查看的呢？文件内容是什么呢？**
>
>     Linux系统中, 所有东西都可看作是文件, 目录也是文件。**目录是由什么组成的呢？**
>
>     目录 = 属性 + 内容, 而目录的内容其实就是 **子目录 和 内部文件 的属性**
>
>     所以
>
>     **读目录的操作就是 `ls` 查看目录内文件列表**, **写目录的操作就是 `mkdir` `touch` 等可创建文件的操作**, **执行目录的操作就是 `cd` 进入目录**
>
>     可以验证一下:
>
>     **用户对目录只有执行权限:**
>
>     ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708105023901.webp)
>
>     **用户对目录只没有读权限:**
>
>     ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708110218588.webp)
>
>     **用户对目录只没有写权限:**
>
>     ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708110716983.webp)
>
> > 用户对各个文件的权限是独立的, 目录内文件的内容是否可以查看, 与目录无关 与 文件本身有关
> >
> > 假如 **`用户对一个目录没有读权限, 但不能说明用户对目录内的文件没有读权限`**
> >
> > 但是, 如果 **`用户对一个目录没有读权限`**, 也就没有办法获取目录内容, 即 **`无法获取目录内文件的属性`**
> >
> > 因为 **`Linux系统是不根据文件名识别文件的, 是根据每个文件在系统中对应的ID`**, 所以即使知道目录内文件的文件名, **`原则上也是无法直接查看目录内文件的内容的`**
> >
> > 但是, 实际的测试发现, 即使 用户对目录没有读权限, 也是可以查看目录内文件的内容的: 
> >
> > ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708112810920.webp)
> >
> > 这其实是因为 虽然系统不根据文件名识别文件, 但是**文件名与文件的ID 存在一定的映射关系**, 如果这个**关系被系统缓存**了, 也可以通过文件名来找到文件, 就**可以通过文件名查看 没有读权限的目录内的文件**

### umask 权限掩码

**一个文件的默认权限是什么？为什么是这样？**

权限掩码可以解释这两个问题

新创建一个普通文件和目录文件, 查看它们的默认权限: 

![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708124948161.webp)

**用户刚创建出文件时的权限被称为 最终权限**, `775` 和`664` 即为不同类型文件的最终权限

而 Linux规定, **目录文件的默认权限是从 `777` 开始的, 普通文件的默认权限是从 `666` 开始的**

那为什么, 创建出来的目录文件是`775`, 普通文件是`664`呢？

这一切都与 权限掩码有关

`umask` 可以查看、修改权限掩码: 

![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708130110411.webp)

**权限掩码是干什么用的？**

默认的权限掩码为 `002`, 目录文件的默认权限是从 `777` 开始的, 普通文件的默认权限是从 `666` 开始的
而刚创建出来的 目录文件的权限是 `775` , 普通文件的权限是 `664`

可以看出, 这三者像是有一种相减的关系

这三者之间确实存在一定的关系, 但并不是相减的关系, 而是: `最终权限 = 默认权限 & (~umask)` 

当目录文件的默认权限为 `777`, 默认权限掩码为 `002`, 则目录文件的最终权限就是 `777 & (~002) -> 775`

> 可以试着验证一下, 这三者的关系究竟是`最终权限 = 默认权限 - umask`, 还是`最终权限 = 默认权限 & (~umask)`

*当默认权限 设置为 000*: 

![|inline](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708131013963.webp)

### 粘滞位

Linux系统中存在一些, 可供不同用户一起存储文件的公共目录, **这些公共目录的所有者和所属组都是 root, 其他用户可以 others的身份 对其内容 读、写、删除等**

但是, **不同用户使用同一个目录, 如果不加以限制 那么用户各自的文件的安全性就得不到保障**

举个例子: 

**`root`**创建一个公共目录`PublicDir`, 用户July 和 Julyxx 都可以使用: 

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708134501470.webp)

两个用户都可以在 这个目录里存放属于自己的文件, 并加以限制: 

![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708135233024.webp)

看似已经非常安全了, 但是, **由于所有用户都可以对此目录内容进行修改、删除, 所以即使设置了其他用户无权限, 其他用户依然可以删除此文件 : **

![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708135639211.webp)

但又**无法避免多用户需要共同使用一个目录的需求**, 又得**保证公共目录下各自文件的安全**, 所以 **Linux引入了粘滞位**

每个用户可以**对属于自己的目录文件** 使用**`chmod +t 目录文件` 就可以设置粘滞位**: 

![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708140600372.webp)

> **任何目录文件都可以设置粘滞位**
>
> ![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708141338551.webp)

设置了粘滞位的目录, 用户就无法在此目录内随意删除文件, 该目录内的文件只能由: 

1. `root` 用户删除
2. 该目录的所有者删除
3. 该文件的所有者删除

![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20220708141549998.webp)
