---
title: '从零接触C语言-IV: 键盘输入'
description: 'C语言可以实现从键盘输入数据到程序中'
pubDate: '2025-07-23'
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710215328038.webp'
categories:
    - Blogs
tags:
    - C
    - 从零开始接触C语言
---

import Info from "../../components/mdx/Info.astro";

import Warning from "../../components/mdx/Warning.astro";

import Kbd from "../../components/mdx/Kbd.astro"

<Warning>

如果你从未接触过C语言, 那么我建议你先阅读前面的文章:

[📌从零开始接触C语言](https://www.humid1ch.cn/blog/tag/从零接触C语言)

</Warning>


## 键盘输入

C语言程序是可以实现, **键盘输入数据到程序中的**

C语言标准提供了一些函数, 可以实现从标准输入(一般为键盘)中获取字符、字符串数据, 然后在程序中使用

比如: `scanf()` `gets()` `fgets()` `getchar()` `getc(stdin)` 

最常用的是`scanf()`, 本篇文章重点分析`scanf()`的功能和使用

### `scanf()`**

`scanf()`的用法, 与`printf()`几乎一致

```c
#include <stdio.h>

int main() {
    int age;

    printf("请输入年龄:> ");
    scanf("%d", &age);

    printf("您输入的年龄为: %d\n", age);

    return 0;
}
```

这段代码的功能是, 接收输入的数字, 存储到`int age`变量中, 再打印出来:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250724140628408.gif)

`scanf()`实现的功能, 目前可以理解为三个大步骤:

1. 从键盘接收字符串
2. 按照代码中调用`scanf()`时的格式字符串, 对接收到的字符串进行格式化解析
3. 将解析到的对应格式的数据, 存储到调用`scanf()`时传入的变量中

`scanf("%d", &age);` 的目标作用就是, 接收输入字符串, 并将字符串解析为`%d`对应的类型, 并将解析出来的数据写入到变量`age`的内存空间中

<Info>

`&` 是取地址符, 可以用来获取变量的内存空间的地址

`scanf()`需要传入地址, 才能将解析到的格式化数据, 存储到对应的变量的内存空间中, 这个地址就是目标变量的内存空间的地址

**C语言中, 想要改变变量的值, 就需要找到此变量的内存空间的地址,然后改变内存空间种的数据, 就是改变这个变量的值**

</Info>

现阶段, 在使用`scanf()`时, 最好注意一个要求: **输入字符串格式严格与`scanf()`中传入的格式字符串匹配**, 如果你已经对`scanf()`的实现机制比较熟悉, 可以按照自己的理解随意使用

输入字符串格式严格与`scanf()`中传入的格式字符串匹配, 是什么意思?

在调用`scanf()`时, 会先传入格式字符串, 在传入接收数据的变量地址:

```c
scanf("%d, %d, %s", &age, &height, name);
```

如果格式字符串内容是: `"%d, %d, %s"`

那么在实际输入时, 最好严格按照格式字符串的格式进行输入, 即`整型, 整型, 字符串`的格式

这样更加安全, 不会偏离预期

以代码为例:

```c
#include <stdio.h>

int main() {
    int age = 0;
    int height = 0;
    char name[32] = {0};
    
    printf("请按格式输入年龄、身高和名字(年龄, 身高, 名字):> ");
    scanf("%d, %d, %s", &age, &height, name);

    printf("您输入的年龄为: %d, 身高为: %d, 名字是: %s\n", age, height, name);

    return 0;
}
```

如果严格按照格式字符串输入, 不会与预期有偏差:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250724150124886.gif)

但是如果没有严格按照格式字符串输入, 结果就可能出现偏差:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250724165929389.gif)

可以发现, 身高和名字并没有输出, 也就意味着 输入的`180`和`humid1ch`并没有被接收到

出现这个情况的原因是: **`scanf()`在解析字符时, 如果遇到非目标格式的字符, 会停止接收字符并返回**

这里的非目标格式是与调用`scanf()`时传入的格式字符串做对比的

例子中格式字符串是`"%d, %d, %s"`, 那么在输入时就应该严格按照`"整型, 整型, 字符串"`的格式输入

`scanf()`在接收并解析第一个整型数据, 应该接收数字或`','`, 如果接收到`'.'`, `scanf()`这个函数会停止接收之后的数据, 并将已经接收并解析好的数据存储到对应的变量中

像`"整型.整型.字符串"`这样错误的输入, 就会导致只有第一个整型数据被正确接收和解析了

---

那么, 问题就出现了: **第一个整型数据被正确接收了, 那么后面的字符呢?**

要解释这个问题, 就要了解一个概念: **C语言程序是存在标准输入缓冲区的**

什么是标准输入缓冲区呢?

简单一点理解:

当调用`scanf()`时, 你可以从键盘输入的内容, 不过 你输入的过程C语言程序是不知道的, 只有在你按下*回车*之后, 你的终端才会将输入的内容一次性交给C语言程序

并且你**输入的内容, 在交给C语言程序之后, 不是直接被`scanf()`解析, 而是会被C语言程序 在一个空间中存储起来, 然后`scanf()`会从这个空间中读取数据进行解析**

这个存储你键盘输入内容的空间, 就是**标准输入缓冲区**

了解了这个标准输入缓冲区之后, 你可能已经猜到问题的答案了

**第一个整型数据被正确接收了, 那么后面的字符呢?**

**后面的字符, 依旧留在标准输入缓冲区中, 并且 首个被检测到的不符合格式的字符也会留在标准输入缓冲区中**

即, 如果`scanf("%d, %d, %s", &age, &height, name);`, 但实际输入`22.180.humid1ch`

`scanf()`将会只接收解析到`22`, 并将其存入变量`age`中, 剩下的`.180.humid1ch`都会留在标准输入缓冲区中, 之后的代码要从标准输入缓冲区中拿数据时, 拿到标准输入缓冲区中剩余的内容

这个结论是可以通过代码验证的:

```c
#include <stdio.h>

int main() {
    int age = 0;
    int height = 0;
    char name[32] = {0};
    
    printf("请按格式输入年龄、身高和名字(年龄, 身高, 名字):> ");
    scanf("%d, %d, %s", &age, &height, name);
    // 要输入 整型数据.整型数据.字符串
    printf("第一个scanf解析完之后, 您输入的年龄为: %d, 身高为: %d, 名字是: %s\n", age, height, name);
    scanf(".%d.%s", &height, name);
    printf("第二个scanf解析完之后, 您输入的年龄为: %d, 身高为: %d, 名字是: %s\n", age, height, name);

    return 0;
}
```

运行这段代码, 如果输入`22.180.humid1ch`

第一个`scanf()`的执行结果我们已经知道了

那么第二个`scanf()`的执行结果:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250724171432565.gif)

从结果中看, 第二次调用的`scanf(".%d.%s", &height, name)`直接完整的接收并解析了剩余的`".180.humid1ch"`

这个现象符合上面的结论

并且, 从现象中可以分析出另一个事实: **当标准输入缓冲区中存在数据时, 再调用`scanf()`, 不会再要求进行键盘输入**

这样的结果也意味着, **事实上`scanf()`并不是直接对完整的字符串进行解析的, 而是边接收单个字符, 边解析**

#### 对空白字符的处理

