---
draft: true
title: "[TCP/IP] 传输层代表协议--UDP协议介绍:UDP协议格式、端口号在网络协议栈那一层工作..."
pubDate: "2024-01-08"
description: "本篇文章, 简单介绍UDP协议的相关内容"
image: https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401080145365.webp
categories:
    - Blogs
tags: 
    - Linux网络
    - TCP-IP
    - 传输层
    - UDP
---

`TCP/IP`网络模型, 将网络分为了四层:

![|huge](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250722181929270.webp)

之前的文章中以`HTTP`和`HTTPS`这两个协议为代表, 简单介绍了应用层协议

实际上, 无论是`HTTP`还是`HTTPS`等应用层协议, 都是在传输层协议的基础上实现的

而传输层协议中最具代表性的就是: `UDP`和`TCP`协议了

以`HTTP`为例, 在使用`HTTP`协议通信之前, 是先需要建立`TCP`连接的

那么, 传输层协议的介绍就先从`UDP`协议开始

# 再谈端口号

在网络通信中, 端口号可以标识主机中的唯一进程

我们在使用`UDP/TCP Socket`时, 都对服务器绑定过端口号

在实际通信中, 当一个客户端向服务器发送数据时, 服务器主机接收到数据之后, 操作系统会 根据报文中的端口号 将数据推送给对应的进程

在`TCP/IP`协议中, 通过**源IP、源端口、目的IP、目的端口、协议号**这样一个五元组标识一个通信

**`IP`标记主机唯一性(用来寻找主机), `端口号`标记进程唯一性(用来选择主机中的进程)**

其中, `端口号`实际是传输层的内容, 因为传输层向上就是应用层了, 那么传输层就需要解决将数据交给上层哪一个进程的问题

而`IP`则是解决报文在网络中进行路由的问题, 需要通过**源IP和目的IP解决从哪来到哪去**的问题

实际上, 通过通过系统调用绑定的`IP`和`端口号`, 是会使用在`TCP/IP`的不同层次中的: `IP`使用在网络层, `端口号`则使用在传输层

## 端口号划分

端口号是16位的, 是因为传输层报头中存在16位用来存储端口号

那么端口号的范围就是: `0~66535`

其中`0~1023`是知名端口号, 它特定分配给一些知名的应用层协议使用, 比如:

1. `SSH`服务器, 使用22端口

2. `FTP`服务器, 使用21端口

3. `TELNET`服务器, 使用23端口

4. `HTTP`服务器, 使用80端口

5. `HTTPS`服务器, 使用443端口

6. 知名端口号在`/etc/services`文件中存储着, 可以进行查看

    ![|wide](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250722181931736.webp)

这些知名端口号一般是不允许分配给其他服务的

而剩下的`1024~65535`, 就是操作系统可以动态分配的端口号, 也可以被指定

# `UDP`协议

之前介绍过, 主机发送数据通过不同的层级时, 不同的协议是会对数据添加报头的

即之前我们使用`sendto()`等一系列系统调用时, 并不是直接将数据发送到了另一套主机上, 而是由操作系统给网络的下一层, 添加对应的协议报头:

![PC1 |inline](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250722181934825.gif)

不同协议会添加自己的报头, 下面就介绍一下`UDP`协议的格式

## `UDP`协议格式

`UDP`协议的格式可以用一张图来表示


![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250722181936936.webp)

从图中可以看到出, `UDP`协议报头部分是固定的**`8`个字节**, 剩下的则是应用层传输过来的原始数据, 即有效载荷

`UDP`协议的报头非常容易理解

首先, 这里有三个概念简单理解一下:

传输层协议接收到来自上层的数据之后, 需要添加自己的协议报头, 这个行为叫**封装**

封装之后, 就可以将数据继续向下层传输

直到对应主机的传输层收到封装数据之后, 传输层协议需要对封装数据进行**解包**, 分别读取数据和报头

之后, 传输层还需要将获取到的数据内容 传输到 指定应用层进程的可用空间, 这个行为叫**分用**

> 实际上, `TCP/IP`的每层都要考虑如何封装、解包和分用的问题

---

`UDP`协议使用固定长度的报头长度, 就很好的解决了如何封装和解包的问题

主机1在使用`UDP`协议发送数据时, 只需要在原始数据前加上这`8`字节的报头就可以 实现封装

对方主机获取到数据之后, 只需要去掉前8个字节, 就可以获取有效载荷 实现解包

而, 分用的实现 就需要读取`UDP`报头的内容了

`UDP`报头中存在**16位的源端口号**和**16位的目的端口号**

当主机接收到`UDP`报文之后, 读取报头中存储的**16位目的端口号**, 就可以知道要向哪一个应用层进程的可用空间传输数据了, 即 可以实现分用

> Linux中, 一切皆文件
>
> 我们之前也介绍过`socket`套接字, 实际就是文件描述符
>
> 当传输层协议知道应用层对应服务的端口号之后, 就可以找到对应的进程, 然后就可以找到进程对应的网络文件, 将数据写入到网络文件的文件缓冲区中
>
> 进程服务就可以读取数据了

而, `16位UDP长度`该作何理解呢?

`16位UDP长度`表示, `UDP`报文的整体长度, 而不是单指有效载荷的长度

我们知道, `UDP`协议的特点之一是**面向数据报**

面向数据报就表示, 每一个`UDP`数据报都应该是完整的

两个数据报之间是具有明显的边界的

当接收主机接收到多个`UDP`报文时, 可以通过读取每个报头中的`UDP长度`来准确的获取到完整的`UDP`报文, 而不产生混乱

而, **`16`位检验和**则用于检验报文内容是否出现了差错等, 如果出现了差错操作系统就会直接丢弃掉整个报文(这就是`UDP`协议**不可靠**的表现)

> `UDP`协议的不可靠是否看作一种缺点?
>
> 不能将 不可靠看作`UDP`协议的缺点, 不可靠是`UDP`协议的特点
>
> 使用`UDP`协议通信, 数据报发生损坏会被直接丢弃
>
> 这使`UDP`协议可以使用在一些 对数据丢失有一定的容忍度的 一些特定的场景中, 比如: 视频直播
>
> 视频直播可以容忍短暂的卡顿和画面丢失, 但是需要保证直播内容的持续输出
>
> 类似这样的场景中, `UDP`协议可以很好的适配
>
> 也就是说, **不可靠**不是一种缺点, 而是一种特点, 可以用在更合适的场景中
>
> `UDP`不可靠, 也就意味这它不用像`TCP`那样, 需要做一系列的保证数据可靠的操作和处理, 也就不用非常的复杂

---

总的来说, `UDP`协议的格式就是`8字节的UDP报头`+`原始数据`

## UDP协议报头在`Linux`中的格式

那么, 使用`UDP`协议通信时, 操作系统在传输层添加协议报头时, 是以什么形式添加的, `UDP`报头的本质是什么?

网络协议栈`TCP/IP`是在`Linux`内核中实现的, `Linux`内核是由C语言实现的

而`Linux`内核中, `UDP`报头的实现就是一个结构体:

![Linux_2.6.38_Kernel |large](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250722181939986.webp)

这就意味着, 操作系统使用`UDP`协议封装数据时, 是以结构体的形式添加的`UDP`协议报头, 因为`UDP`协议报头的格式在`Linux`内核中的实现方式就是一个结构体

那么, 我们使用`UDP`协议创建网络套接字时候, 需要将套接字`bind()`到特定的端口上

然后在使用`sendto()`进行发送数据时, 操作系统就会创建`udphdr对象`并填充端口号、内容以及检验和

并将`udphdr对象`以一定的形式拷贝到原始数据之前, 形成一个完整的`UDP`报文

## `UDP`的缓冲区

> 在`Linux`系统中, 无论使用`UDP`还是`TCP`进行通信, 无论是使用`sendto()`还是`write()`向网络中发送数据
>
> 实际上, 在函数执行完毕之后都没有直接将数据发送到网络中, 而是在操作系统对数据进行处理了之后, 将数据放入到**发送缓冲区**中, 什么时候真正的发送出去, 由操作系统内核决定
>
> 所以, 要理解一个东西: `sendto()`和`write()`并不是发送的接口, 而是**拷贝的接口**
>
> 调用这两个接口, 都只是将数据拷贝到内核中, 而不是直接发送到网络中或者直接写入到内核中
>
> 接收数据也是一样的, 操作系统接收网络数据时, 从网络层到传输层 也会将数据暂时存储到接收缓冲区, 等待内核中传输层的接收、解包以及分用

实际上, **`UDP`协议在内核中并没有真正意义上的发送缓冲区**

首先, 因为使用`UDP`协议在发送数据时, 操作系统需要对数据进行的处理动作很简单, 毕竟`udphdr`是一个很简单的只有`8`字节的结构体, 只需要添加一个结构体就可以

并且`UDP`协议不需要保证数据可靠性, 这也就意味着`UDP`协议不需要将发送的数据在本地长时间维护, 也就不需要一个真正的发送缓冲区

这意味着, 当使用`sendto()`将数据交给内核时, 内核会尽快的将数据发送到网络层, 不需要在传输层存储数据

不过, 虽然`UDP`协议并没有发送缓冲区, 但**`UDP`协议是有接收缓冲区的**

也就是说, `Linux`系统内核中维护有一块空间, 专门存储收到的`UDP`报文数据, 并且针对每一个`UDP`套接字都会维护那一块空间, 这就是内核中`UDP`的接收缓冲区

当操作系统接收到`UDP`协议数据报时, `UDP`协议会对`UDP`数据报进行解包, 然后再将数据存储到对应`UDP Socket`的接收缓冲区中, 这个过程实际就是`UDP`协议对`UDP`数据报解包和分用的过程

但是, `UDP`协议是面向数据报的, 使用`UDP`协议通信发送数据时, 都是以一个数据报一个数据报的形式发送的

但是`UDP`协议的接收缓冲区是 **不保证接收到`UDP`数据报的顺序 与 发送端发送`UDP`数据报的顺序 是一致的(即, 如果发送端按照12345的顺序发送数据报, 接收端很可能并不是按照12345的顺序接收到的)**

> `UDP`数据报的发送顺序与接收顺序可能一致, 也体现了`UDP`协议的不可靠性
>
> 因为无法保证`UDP`数据报的接收顺序, 所以如果有顺序一致的需求, 那么接收端就需要对`UDP`数据报进行重排序, 一般在发送方和接收方的应用层实现

并且, **当`UDP`协议接收缓冲区满了之后, 再发送过来的`UDP`数据报会被直接丢弃**

> `UDP`协议发送端与接收端的 发送与接收 是互不影响的, 所以`UDP`协议是全双工的
>
> 使用`UDP`协议可以同时发送和接收数据报

## `UDP`报文大小

`UDP`报文首部中, 有一块16位的空间 是用来存储`UDP`报文总长度的

那么也就意味着: 一个`UDP`报文, 最大也就 **2的16次方个字节**, 即 **`64KB`(包括`8字节`首部)**

`64KB`在现在是非常的小的

那么, 如果使用`UDP`协议传输大一点(超过`64KB`)的文件时, 就需要在应用层进行分包, 多次发送

对应的, 接收端同样需要对接受的数据进行手动拼装

---

这就是关于`UDP`协议简单介绍的全部内容了

感谢阅读~
