---
draft: true
title: "[C++é¡¹ç›®] Boostæ–‡æ¡£ ç«™å†…æœç´¢å¼•æ“(4): æœç´¢çš„ç›¸å…³æ¥å£çš„å®ç°ã€çº¿ç¨‹å®‰å…¨çš„å•ä¾‹indexæ¥å£ã€cppjiebaåˆ†è¯åº“çš„ä½¿ç”¨ã€ç»¼åˆè°ƒè¯•..."
pubDate: "2023-08-05"
description: "æœ¬ç¯‡æ–‡ç« çš„å†…å®¹ä¸º: æŸ¥æ‰¾ã€æœç´¢ ç›¸å…³æ¥å£çš„å®ç°, å»ºç«‹ç´¢å¼•æ¥å£çš„ç›¸å…³ä¼˜åŒ–, æœ¬åœ°æœç´¢æµ‹è¯•. åšå®Œä¸Šé¢çš„å†…å®¹, å°±åé¢å°±æ˜¯åŠ å…¥ç½‘ç»œå’Œé¡µé¢çš„åˆ¶ä½œäº†~"
image: https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710225941036.webp
categories:
    - Blogs
tags: 
    - é¡¹ç›®
    - æœç´¢å¼•æ“
    - Booståº“
---

æœ‰å…³`Boost`æ–‡æ¡£æœç´¢å¼•æ“çš„é¡¹ç›®çš„å‰ä¸‰ç¯‡æ–‡ç« , å·²ç»åˆ†åˆ«ä»‹ç»åˆ†æäº†:

1. é¡¹ç›®èƒŒæ™¯: [ğŸ«¦[C++é¡¹ç›®] Boostæ–‡æ¡£ ç«™å†…æœç´¢å¼•æ“(1): é¡¹ç›®èƒŒæ™¯ä»‹ç»ã€ç›¸å…³æŠ€æœ¯æ ˆã€ç›¸å…³æ¦‚å¿µä»‹ç»...](https://www.humid1ch.cn/posts/Boost-Doc-Searcher-I)
2. æ–‡æ¡£è§£æã€å¤„ç†æ¨¡å—`parser`çš„å®ç°: [ğŸ«¦[C++é¡¹ç›®] Boostæ–‡æ¡£ ç«™å†…æœç´¢å¼•æ“(2): æ–‡æ¡£æ–‡æœ¬è§£ææ¨¡å—parserçš„å®ç°ã€å¦‚ä½•å¯¹æ–‡æ¡£æ–‡ä»¶å»æ ‡ç­¾ã€å¦‚ä½•è·å–æ–‡æ¡£æ ‡é¢˜...](https://www.humid1ch.cn/posts/Boost-Doc-Searcher-II)
3. æ–‡æ¡£**æ­£æ’ç´¢å¼•ä¸å€’æ’ç´¢å¼•**å»ºç«‹çš„æ¥å£çš„å®ç°: [ğŸ«¦[C++é¡¹ç›®] Boostæ–‡æ¡£ ç«™å†…æœç´¢å¼•æ“(3): å»ºç«‹æ–‡æ¡£åŠå…¶å…³é”®å­—çš„æ­£æ’ å€’æ’ç´¢å¼•ã€jiebaåº“çš„å®‰è£…ä¸ä½¿ç”¨...](https://www.humid1ch.cn/posts/Boost-Doc-Searcher-III)
4. **`å»ºè®®å…ˆé˜…è¯»ä¸Šé¢ä¸‰ç¯‡æ–‡ç« `**

å·²ç»å®ç°äº†å¯¹æ–‡æ¡£å»ºç«‹ç´¢å¼•çš„ç›¸å…³æ¥å£. æœ‰äº†æ¥å£, å°±å¯ä»¥è°ƒç”¨å¹¶å»ºç«‹æ–‡æ¡£ç´¢å¼•.

å»ºç«‹äº†ç´¢å¼•, å…¶å®å°±å¯ä»¥æ ¹æ®ç´¢å¼•æŸ¥æ‰¾æ–‡æ¡£äº†. æ‰€ä»¥, æœ¬ç¯‡æ–‡ç« çš„å†…å®¹å³ä¸º: 

1. æŸ¥æ‰¾ã€æœç´¢ ç›¸å…³æ¥å£çš„å®ç°
2. å»ºç«‹ç´¢å¼•æ¥å£çš„ç›¸å…³ä¼˜åŒ–
3. æœ¬åœ°æœç´¢æµ‹è¯•

åšå®Œä¸Šé¢çš„å†…å®¹, å°±åé¢å°±æ˜¯åŠ å…¥ç½‘ç»œå’Œé¡µé¢çš„åˆ¶ä½œäº†~

# æœç´¢

æœç´¢æ˜¯é€šè¿‡è¾“å…¥çš„å†…å®¹è¿›è¡Œæœç´¢çš„. å¹¶ä¸”ä¸€å®šæ˜¯**å…ˆåœ¨å€’æ’ç´¢å¼•ä¸­æ‰¾åˆ°æ–‡æ¡£`id`, å†æ ¹æ®æ–‡æ¡£`id`å»æ­£æ’ç´¢å¼•ä¸­æ‰¾åˆ°æ–‡æ¡£**çš„å†…å®¹.

è€Œå€’æ’ç´¢å¼•ä¸­å­˜å‚¨çš„å†…å®¹æ˜¯å¯¹æ–‡æ¡£å†…å®¹è¿›è¡Œåˆ†è¯, ç„¶åæ ¹æ®åˆ†è¯å»ºç«‹çš„.

é‚£ä¹ˆè¦å®ç°æœç´¢, ä¹Ÿéœ€è¦**å¯¹æœç´¢çš„å†…å®¹è¿›è¡Œåˆ†è¯, ç„¶åå†æ ¹æ®æœç´¢å†…å®¹çš„åˆ†è¯ åœ¨ å€’æ’ç´¢å¼•ä¸­æŸ¥æ‰¾å…³é”®è¯å¯¹åº”çš„å€’æ’æ‹‰é“¾**

## æœç´¢æ¥å£çš„åŸºæœ¬ç»“æ„

äº†è§£äº†æœç´¢çš„æµç¨‹, é‚£ä¹ˆæœç´¢çš„ç›¸å…³æ¥å£çš„åŸºæœ¬ç»“æ„å®é™…ä¹Ÿå°±æ˜¾ç°å‡ºæ¥äº†:

```cpp
namespace ns_searcher {
	class searcher {
	private:
		ns_index::index* _index; // å»ºç«‹ç´¢å¼•çš„ç±»

	public:
        // åˆå§‹åŒ–æ¥å£
        // åœ¨æœç´¢ä¹‹å‰éœ€è¦å…ˆå»ºç«‹ç´¢å¼•. è¿™ä¸ªæ¥å£å°±æ˜¯å»ºç«‹ç´¢å¼•ç”¨çš„
		void initSearcher(const std::string& input) {}

		// æœç´¢æ¥å£
		// æœç´¢éœ€è¦å®ç°ä»€ä¹ˆåŠŸèƒ½?
        // æœç´¢éœ€è¦æ¥æ”¶å­—ç¬¦ä¸², ç„¶åé’ˆå¯¹å­—ç¬¦ä¸²è¿›è¡Œåˆ†è¯ å†æ ¹æ®åˆ†è¯åœ¨ç´¢å¼•ä¸­è¿›è¡ŒæŸ¥æ‰¾
		// é¦–å…ˆå‚æ•°éƒ¨åˆ†éœ€è¦æ€ä¹ˆå®ç°?
		// å‚æ•°éƒ¨åˆ†, éœ€è¦æ¥æ”¶éœ€è¦æœç´¢çš„å¥å­æˆ–å…³é”®å­—, è¿˜éœ€è¦ä¸€ä¸ªè¾“å‡ºå‹å‚æ•° ç”¨äºè¾“å‡ºæŸ¥æ‰¾ç»“æœ
		//  æŸ¥æ‰¾ç»“æœæˆ‘ä»¬ä½¿ç”¨jsoncppè¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–
		void search(const std::string& query, std::string* jsonString) {}
```

åŸºæœ¬çš„ç»“æ„å°±è¿™ä¹ˆç®€å•. åªéœ€è¦å¯¹å¤–æä¾›ä¸¤ä¸ªæ¥å£:

1. `initSearcher()` åˆå§‹åŒ–æ¥å£
2. `search()` æœç´¢æ¥å£

## `initSearcher()`æ¥å£ å®ç°

`initSearcher()` æ˜¯ç”¨æ¥åšæœç´¢å‰çš„å·¥ä½œçš„, å®é™…å°±æ˜¯å»ºç«‹ç´¢å¼•çš„æ¥å£

ä½†æ˜¯, åœ¨å»ºç«‹ç´¢å¼•ä¹‹å‰ æˆ‘ä»¬æ¸…æ¥š æ‰€æœ‰çš„æœç´¢éƒ½æ˜¯åœ¨å”¯ä¸€ä¸€ä¸ªå€’æ’ç´¢å¼•å’Œå”¯ä¸€ä¸€ä¸ªæ­£æ’ç´¢å¼•ä¸­è¿›è¡Œçš„. ä¹Ÿå°±æ˜¯è¯´**æœ€ç»ˆä¸€ä¸ªç¨‹åºä¸­åªéœ€è¦å»ºç«‹ä¸€æ¬¡ç´¢å¼•**. æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†ç´¢å¼•çš„ç›¸å…³å‡½æ•°å®ç°ä¸ºå•ä¾‹.

### `index`æ¥å£ç±» å•ä¾‹å®ç°

`index`ç±»çš„å•ä¾‹å®ç°éå¸¸çš„ç®€å•:

```cpp
namespace ns_index {

	// ç”¨äºæ­£æ’ç´¢å¼•ä¸­ å­˜å‚¨æ–‡æ¡£å†…å®¹
	typedef struct docInfo {
		std::string _title;	  // æ–‡æ¡£æ ‡é¢˜
		std::string _content; // æ–‡æ¡£å»æ ‡ç­¾ä¹‹åçš„å†…å®¹
		std::string _url;	  // æ–‡æ¡£å¯¹åº”å®˜ç½‘url
		std::size_t _docId;	  // æ–‡æ¡£id
	} docInfo_t;

	// ç”¨äºå€’æ’ç´¢å¼•ä¸­ è®°å½•å…³é”®å­—å¯¹åº”çš„æ–‡æ¡£idå’Œæƒé‡
	typedef struct invertedElem {
		std::size_t _docId;	   // æ–‡æ¡£id
		std::string _keyword;  // å…³é”®å­—
		std::uint64_t _weight; // æœç´¢æ­¤å…³é”®å­—, æ­¤æ–‡æ¡£id æ‰€å æƒé‡

		invertedElem() // æƒé‡åˆå§‹åŒ–ä¸º0
			: _weight(0) {}
	} invertedElem_t;

	// å…³é”®å­—çš„è¯é¢‘
	typedef struct keywordCnt {
		std::size_t _titleCnt;	 // å…³é”®å­—åœ¨æ ‡é¢˜ä¸­å‡ºç°çš„æ¬¡æ•°
		std::size_t _contentCnt; // å…³é”®å­—åœ¨å†…å®¹ä¸­å‡ºç°çš„æ¬¡æ•°

		keywordCnt()
			: _titleCnt(0)
			, _contentCnt(0) {}
	} keywordCnt_t;

	// å€’æ’æ‹‰é“¾
	typedef std::vector<invertedElem_t> invertedList_t;

	class index {
	private:
		// æ­£æ’ç´¢å¼•ä½¿ç”¨vector, ä¸‹æ ‡å¤©ç„¶æ˜¯ æ–‡æ¡£id
		std::vector<docInfo_t> forwardIndex;
		// å€’æ’ç´¢å¼• ä½¿ç”¨ å“ˆå¸Œè¡¨, å› ä¸ºå€’æ’ç´¢å¼• ä¸€å®šæ˜¯ ä¸€ä¸ªkeyword å¯¹åº”ä¸€ç»„ invertedElemæ‹‰é“¾
		std::unordered_map<std::string, invertedList_t> invertedIndex;

		// å•ä¾‹æ¨¡å¼è®¾è®¡
		index() {}

		index(const index&) = delete;
		index& operator=(const index&) = delete;

		static index* _instance; // å•ä¾‹
		static std::mutex _mtx;

	public:
		// è·å–å•ä¾‹
		static index* getInstance() {
			if (nullptr == _instance) {
				_mtx.lock();
				if (nullptr == _instance) {
					_instance = new index;
				}
				_mtx.unlock();
			}

			return _instance;
		}
		
        // é€šè¿‡å…³é”®å­— æ£€ç´¢å€’æ’ç´¢å¼•, è·å–å¯¹åº”çš„ å€’æ’æ‹‰é“¾
		invertedList_t* getInvertedList(const std::string& keyword) {}

		// é€šè¿‡å€’æ’æ‹‰é“¾ä¸­ æ¯ä¸ªå€’æ’å…ƒç´ ä¸­å­˜å‚¨çš„ æ–‡æ¡£id, æ£€ç´¢æ­£æ’ç´¢å¼•, è·å–å¯¹åº”æ–‡æ¡£å†…å®¹
		docInfo_t* getForwardIndex(std::size_t docId) {}

		// æ ¹æ®parseræ¨¡å—å¤„ç†è¿‡çš„ æ‰€æœ‰æ–‡æ¡£çš„ä¿¡æ¯
		// æå–æ–‡æ¡£ä¿¡æ¯, å»ºç«‹ æ­£æ’ç´¢å¼•å’Œå€’æ’ç´¢å¼•
		// input ä¸º ./data/output/raw
		bool buildIndex(const std::string& input) {}

	private:
		// å¯¹ä¸€ä¸ªæ–‡æ¡£å»ºç«‹æ­£æ’ç´¢å¼•
		docInfo_t* buildForwardIndex(const std::string& file) {}
        // å¯¹ä¸€ä¸ªæ–‡æ¡£å»ºç«‹å€’æ’ç´¢å¼•
		bool buildInvertedIndex(const docInfo_t& doc) {}
	};
	// å•ä¾‹ç›¸å…³
	index* index::_instance = nullptr;
	std::mutex index::_mtx;
}
```

éœ€è¦åšçš„å·¥ä½œä¹Ÿå°±åªæœ‰:

1. æ·»åŠ ä¸¤ä¸ªæˆå‘˜å˜é‡, å¹¶åœ¨ç±»å¤–å®šä¹‰: 

    **`static index* _instance;`**

    **`static std::mutex _mtx;`**

2. æ„é€ å‡½æ•°è®¾ç½®ç§æœ‰, æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼é‡è½½å‡½æ•°åˆ é™¤:

    **`index() {}`**

    **`index(const index&) = delete;`**

    **`index& operator=(const index&) = delete;`**

3. æ·»åŠ çº¿ç¨‹å®‰å…¨çš„è·å–å•ä¾‹çš„å…¬å¼€æ¥å£:

    ```cpp
    static index* getInstance() {
        if (nullptr == _instance) {
            _mtx.lock();
            if (nullptr == _instance) {
                _instance = new index;
            }
            _mtx.unlock();
        }
    
        return _instance;
    }
    ```

è¿™æ ·å°±å°†`index`ç±»è®¾è®¡ä¸ºäº†å•ä¾‹æ¨¡å¼

### æ¥å£å®ç°

`initSearcher()`æ¥å£çš„å®ç°ä¹Ÿæ˜¯éå¸¸çš„ç®€å•, åªéœ€è¦å»ºç«‹ç´¢å¼•å°±å¯ä»¥äº†:

```cpp
void initSearcher(const std::string& input) {
    // æœç´¢å‰çš„åˆå§‹åŒ–æ“ä½œ
    // searchç±»æˆå‘˜ ns_index::index* _index è·å–å•ä¾‹
    _index = ns_index::index::getInstance();
    std::cout << "è·å–å•ä¾‹æˆåŠŸ ..." << std::endl;
    
    // å»ºç«‹ç´¢å¼•
    _index->buildIndex(input);
    std::cout << "æ„å»ºæ­£æ’ç´¢å¼•ã€å€’æ’ç´¢å¼•æˆåŠŸ ..." << std::endl;
}
```

## `search()`æ¥å£ å®ç°**

`searcher`ç±»ä¸­, åˆå§‹åŒ–æ¥å£`initSearcher()`å®ç°çš„ç®€å•.

ä½†æ˜¯`search()`å°±æ²¡æœ‰é‚£ä¹ˆç®€å•äº†, éœ€è¦æ³¨æ„éå¸¸å¤šçš„ç»†èŠ‚

æœç´¢æ¥å£éœ€è¦å®ç°çš„åŠŸèƒ½æ˜¯: 

1. æ¥æ”¶å­—ç¬¦ä¸², ç„¶åé’ˆå¯¹å­—ç¬¦ä¸²è¿›è¡Œåˆ†è¯
2. å†æ ¹æ®åˆ†è¯åœ¨å€’æ’ç´¢å¼•ä¸­æŸ¥æ‰¾å¯¹åº”çš„å€’æ’æ‹‰é“¾
3. é€šè¿‡å€’æ’æ‹‰é“¾è·å–ç›¸å…³æ–‡æ¡£çš„id
4. å†æ ¹æ®æ–‡æ¡£id, æŸ¥æ‰¾æ­£æ’ç´¢å¼•æŸ¥æ‰¾å¯¹åº”çš„æ–‡æ¡£å†…å®¹ä¿¡æ¯
5. æœ€ç»ˆæŸ¥æ‰¾åˆ°çš„æ–‡æ¡£å†…å®¹ä¿¡æ¯æ˜¯éœ€è¦è¾“å‡ºçš„, æ‰€ä»¥æˆ‘ä»¬æ¥å£ä½¿ç”¨äº†è¾“å‡ºå‹å‚æ•°

ä½†è¿™åªæ˜¯åŠŸèƒ½å®ç°çš„æ•´ä½“é€»è¾‘. è¿˜æœ‰è®¸å¤šçš„ç»†èŠ‚éœ€è¦è€ƒè™‘:

1. å€’æ’ç´¢å¼•ä¸­çš„ å…³é”®è¯éƒ½æ˜¯å°å†™çš„, è€Œæœç´¢è¾“å…¥çš„å†…å®¹å¾ˆå¯èƒ½å­˜åœ¨å¤§å°å†™, å¦‚ä½•å®ç°å¿½ç•¥å¤§å°å†™çš„æœç´¢å‘¢?

2. æŸ¥æ‰¾åˆ°å€’æ’æ‹‰é“¾ä¹‹å, æ˜¯å¯ä»¥é€šè¿‡éå†æ‹‰é“¾ è·å–åˆ°æ–‡æ¡£idç­‰ç›¸å…³ä¿¡æ¯çš„

    ä¸è¿‡, é¡µé¢çš„æ˜¾ç¤ºæ˜¯éœ€è¦æŒ‰ç…§ç›¸å…³åº¦æ’åºçš„, æˆ‘ä»¬ä¹Ÿåœ¨å€’æ’ç´¢å¼•ä¸­ ä½¿ç”¨è¯é¢‘ç®€å•åœ°ä½“ç°å‡ºäº† å…³é”®å­—ä¸å¯¹åº”æ–‡æ¡£çš„ç›¸å…³æ€§

    é‚£ä¹ˆå¦‚ä½•å¯¹è·å–åˆ°çš„æ–‡æ¡£è¿›è¡Œæ’åºå‘¢?

3. åœ¨æŸ¥æ‰¾çš„æ—¶å€™, ä¸€å®šä¼šæœ‰ä¸åŒçš„è¯ æŸ¥æ‰¾åˆ°åŒä¸€ä¸ªæ–‡æ¡£çš„é—®é¢˜. é‚£ä¹ˆ å¦‚æœä¸åšå¤„ç†, å°±ä¼šå‡ºç°åŒä¸€ä¸ªæ–‡æ¡£åœ¨é¡µé¢ä¸­ä¸åŒçš„ä½ç½® è¢«æ˜¾ç¤ºå‡ºæ¥çš„é—®é¢˜, è¯¥æ€ä¹ˆè§£å†³å‘¢?

4. è·å–åˆ°æ–‡æ¡£å†…å®¹ä¿¡æ¯ä¹‹å, æ˜¯éœ€è¦å°†è®¾ç½®æ–‡æ¡£éœ€è¦å±•ç¤ºçš„ç›¸å…³ä¿¡æ¯çš„: `title` `description` `url`

    å¦‚æœæ–‡æ¡£å†…å®¹è¿‡é•¿, ä¸€å®šä¸èƒ½å°†æ–‡æ¡£å…¨éƒ¨å†…å®¹å±•ç¤ºåœ¨æœç´¢é¡µé¢ä¸­, é‚£ä¹ˆå¦‚ä½•è·å–æ–‡ç« ç›¸å…³çš„æ‘˜è¦å‘¢?

5. è¿˜æœ‰ä¸€äº›å…¶ä»–ç»†èŠ‚, ç»“åˆä»£ç å…·ä½“åˆ†æ...

é‚£ä¹ˆ, æ ¹æ®éœ€æ±‚ `search()`æ¥å£çš„å®ç°ä»£ç å°±æ˜¯è¿™æ ·çš„:

```cpp
typedef struct invertedElemOut {
    std::size_t _docId;
    std::uint64_t _weight;
    std::vector<std::string> _keywords;
} invertedElemOut_t;

// æœç´¢æ¥å£
// é¦–å…ˆå‚æ•°éƒ¨åˆ†éœ€è¦æ€ä¹ˆå®ç°?
// å‚æ•°éƒ¨åˆ†, éœ€è¦æ¥æ”¶éœ€è¦æœç´¢çš„å¥å­æˆ–å…³é”®å­—, è¿˜éœ€è¦ä¸€ä¸ªè¾“å‡ºå‹å‚æ•° ç”¨äºè¾“å‡ºæŸ¥æ‰¾ç»“æœ
//  æŸ¥æ‰¾ç»“æœæˆ‘ä»¬ä½¿ç”¨jsoncppè¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–
// search() å…·ä½“éœ€è¦å®ç°çš„åŠŸèƒ½:
//  1. å¯¹æ¥æ”¶çš„å¥å­æˆ–å…³é”®è¯è¿›è¡Œåˆ†è¯
//  2. æ ¹æ®åˆ†è¯, åœ¨å€’æ’ç´¢å¼•ä¸­æŸ¥æ‰¾åˆ°æ‰€æœ‰åˆ†è¯çš„å€’æ’æ‹‰é“¾ å¹¶æ±‡æ€»å…¶ä¸­çš„ invertedElem, ç„¶åæ ¹æ®ç›¸å…³æ€§è¿›è¡Œæ’åº
//  4. ç„¶åå†éå†æ‰€æœ‰çš„ invertedElem, æ ¹æ® invertedElemä¸­å­˜å‚¨çš„ æ–‡æ¡£id, åœ¨æ­£æ’ç´¢å¼•ä¸­è·å–åˆ°æ–‡æ¡£å†…å®¹
//  5. ç„¶åå°†è·å–åˆ°çš„æ–‡æ¡£å†…å®¹ä½¿ç”¨jsoncpp è¿›è¡Œåºåˆ—åŒ–, å­˜å‚¨åˆ°è¾“å‡ºå‹å‚æ•°ä¸­
// ç›´åˆ°éå†å®ŒinvertedElem
void search(const std::string& query, std::string* jsonString) {
    // 1. å¯¹éœ€è¦æœç´¢çš„å¥å­æˆ–å…³é”®è¯è¿›è¡Œåˆ†è¯
    std::vector<std::string> keywords;
    ns_util::jiebaUtil::cutString(query, &keywords);

    // ç»Ÿè®¡æ–‡æ¡£ç”¨, å› ä¸ºå¯èƒ½å­˜åœ¨ä¸åŒçš„åˆ†è¯ åœ¨å€’æ’ç´¢å¼•ä¸­æŒ‡å‘åŒä¸€ä¸ªæ–‡æ¡£çš„æƒ…å†µ
    // å¦‚æœä¸å»é‡, ä¼šé‡å¤å±•ç¤º
    std::unordered_map<std::size_t, invertedElemOut_t> invertedElemOutMap;
    // 2. æ ¹æ®åˆ†è¯è·å–å€’æ’ç´¢å¼•ä¸­çš„å€’æ’æ‹‰é“¾, å¹¶æ±‡æ€»å»é‡ invertedElem
    for (std::string word : keywords) {
        boost::to_lower(word);

        ns_index::invertedList_t* tmpInvertedList = _index->getInvertedList(word);
        if (nullptr == tmpInvertedList) {
            // æ²¡æœ‰è¿™ä¸ªå…³é”®è¯
            continue;
        }

        for (auto& elem : *tmpInvertedList) {
            // éå†å€’æ’æ‹‰é“¾, æ ¹æ®æ–‡æ¡£id å¯¹invertedElem å»é‡
            auto& item = invertedElemOutMap[elem._docId]; // åœ¨mapä¸­è·å– æˆ– åˆ›å»ºå¯¹åº”æ–‡æ¡£idçš„ invertedElem
            item._docId = elem._docId;
            item._weight += elem._weight;
            // æƒé‡éœ€è¦+= æ˜¯å› ä¸ºå¤šä¸ªå…³é”®è¯æŒ‡å‘äº†åŒä¸€ä¸ªæ–‡æ¡£ é‚£ä¹ˆå°±è¯´æ˜æ­¤æ–‡æ¡£çš„ä¸æœç´¢å†…å®¹çš„ç›¸å…³æ€§æ›´é«˜
      		// å°±å¯ä»¥å°†å¤šä¸ªå…³é”®å­—å…³äºæ­¤æ–‡æ¡£çš„æƒé‡ç›¸åŠ , è¡¨ç¤ºæœç´¢ç›¸å…³æ€§é«˜
            // æœ€å¥½ä¹Ÿå°† æ­¤æ–‡æ¡£ç›¸å…³çš„å…³é”®è¯ ä¹Ÿå­˜å‚¨èµ·æ¥, å› ä¸ºåœ¨å®¢æˆ·ç«¯æœç´¢ç»“æœä¸­, å¯èƒ½éœ€è¦å¯¹ç½‘é¡µä¸­æœ‰çš„å…³é”®å­—è¿›è¡Œé«˜äº®
            // ä½†æ˜¯ invertedElem çš„ç¬¬ä¸‰ä¸ªæˆå‘˜æ˜¯ å•ç‹¬çš„ä¸€ä¸ªstringå¯¹è±¡, ä¸å¤ªåˆé€‚
            // æ‰€ä»¥, å¯ä»¥å®šä¹‰ä¸€ä¸ªä¸invertedElem ç›¸ä¼¼çš„, ä½†æ˜¯ç¬¬ä¸‰ä¸ªæˆå‘˜æ˜¯ä¸€ä¸ª vector çš„ç±», æ¯”å¦‚ invertedElemOut
            item._keywords.push_back(elem._keyword);
            // æ­¤æ—¶å°±å°†å½“å‰invertedElem å»é‡åˆ°äº† invertedElemMap ä¸­
        }
    }
    
    // vector å­˜å‚¨ æ–‡æ¡£idç›¸å…³ä¿¡æ¯, æ–¹ä¾¿æ’åº
    std::vector<invertedElemOut_t> allInvertedElemOut;
    // å‡ºå¾ªç¯ä¹‹å, å°±å°†æœç´¢åˆ°çš„ æ–‡æ¡£çš„ idã€æƒé‡å’Œç›¸å…³å…³é”®è¯ å­˜å‚¨åˆ°äº† invertedElemMap
    // ç„¶åå°†æ–‡æ¡£çš„ç›¸å…³ä¿¡æ¯ invertedElemOut éƒ½å­˜å‚¨åˆ° vector ä¸­
    for (const auto& elemOut : invertedElemOutMap) {
        // mapä¸­çš„second: elemOut, åœ¨æ‰§è¡Œæ­¤æ“ä½œä¹‹å, å°±æ²¡ç”¨äº†
        // æ‰€ä»¥ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰, é˜²æ­¢å‘ç”Ÿæ‹·è´
        allInvertedElemOut.push_back(std::move(elemOut.second));
    }

    // æ‰§è¡Œåˆ°è¿™é‡Œ, å¯ä»¥æœç´¢åˆ°çš„æ–‡æ¡£id æƒé‡ å’Œ ç›¸å…³å…³é”®è¯çš„ä¿¡æ¯, å·²ç»éƒ½åœ¨allInvertedElemOut ä¸­äº†.
    // ä½†æ˜¯, è¿˜ä¸èƒ½ç›´æ¥ æ ¹æ®æ–‡æ¡£id åœ¨æ­£æ’ç´¢å¼•ä¸­æ£€ç´¢
    // å› ä¸º, æ­¤æ—¶å¦‚æœç›´æ¥è¿›è¡Œæ–‡æ¡£å†…å®¹çš„ç´¢å¼•, åœ¨æ‰¾åˆ°æ–‡æ¡£å†…å®¹ä¹‹å, å°±è¦ç›´æ¥è¿›è¡Œåºåˆ—åŒ–å¹¶è¾“å‡ºäº†. è€Œå®¢æˆ·ç«¯æ˜¾ç¤ºçš„æ—¶å€™, ååºåˆ—åŒ–å‡ºæ¥çš„æ–‡æ¡£é¡ºåº, å°±æ˜¯æ˜¾ç¤ºçš„æ–‡æ¡£é¡ºåº
    // ä½†æ˜¯ç°åœ¨æ‰¾åˆ°çš„æ–‡æ¡£è¿˜æ˜¯ä¹±åºçš„. è¿˜éœ€è¦å°†allInvertedElemOutä¸­çš„ç›¸å…³æ–‡æ¡£, é€šè¿‡_weight è¿›è¡Œå€’åºæ’åˆ—
    // è¿™æ ·, åºåˆ—åŒ–å°±æ˜¯æŒ‰ç…§å€’åºæ’åˆ—çš„, ååºåˆ—åŒ–ä¹Ÿä¼šå¦‚æ­¤, æ˜¾ç¤ºåŒæ ·å¦‚æ­¤
    std::sort(allInvertedElemOut.begin(), allInvertedElemOut.end(),
              [](const invertedElemOut_t& elem1, const invertedElemOut_t& elem2) {
                  return elem1._weight > elem2._weight;
              });

    // æ’åºä¹‹å, allInvertedElemOutä¸­ æ–‡æ¡£çš„æ’åºå°±æ˜¯é™åºäº†
    // ç„¶å é€šè¿‡éå†æ­¤æ•°ç»„, è·å–æ–‡æ¡£id, æ ¹æ®idè·å–æ–‡æ¡£åœ¨æ­£æ’ç´¢å¼•ä¸­çš„å†…å®¹
    // ç„¶åå†å°† æ‰€æœ‰å†…å®¹åºåˆ—åŒ–
    Json::Value root;
    for (auto& elemOut : allInvertedElemOut) {
        // é€šè¿‡Json::Value å¯¹è±¡, å­˜å‚¨æ–‡æ¡£å†…å®¹
        Json::Value elem;
        // é€šè¿‡elemOut._docId è·å–æ­£æ’ç´¢å¼•ä¸­ æ–‡æ¡£çš„å†…å®¹ä¿¡æ¯
        ns_index::docInfo_t* doc = _index->getForwardIndex(elemOut._docId);
        // elemèµ‹å€¼
        elem["url"] = doc->_url;
        elem["title"] = doc->_title;
        // å…³äºæ–‡æ¡£çš„å†…å®¹, æœç´¢ç»“æœä¸­æ˜¯ä¸å±•ç¤ºæ–‡æ¡£çš„å…¨éƒ¨å†…å®¹çš„, åº”è¯¥åªæ˜¾ç¤ºåŒ…å«å…³é”®è¯çš„æ‘˜è¦, ç‚¹è¿›æ–‡æ¡£æ‰æ˜¾ç¤ºç›¸å…³å†…å®¹
        // è€ŒdocInfoä¸­å­˜å‚¨çš„æ˜¯æ–‡æ¡£å»é™¤æ ‡ç­¾ä¹‹åçš„æ‰€æœ‰å†…å®¹, æ‰€ä»¥ä¸èƒ½ç›´æ¥å°† doc._content å­˜å‚¨åˆ°elemå¯¹åº”key:valueä¸­
        elem["desc"] = getDesc(doc->_content, elemOut._keywords[0]); // åªæ ¹æ®ç¬¬ä¸€ä¸ªå…³é”®è¯æ¥è·å–æ‘˜è¦
        // for Debug
        // è¿™é‡Œæœ‰ä¸€ä¸ªbug, jsoncpp 0.10.5.2 æ˜¯ä¸æ”¯æŒlongæˆ–long long ç›¸å…³ç±»å‹çš„, æ‰€ä»¥éœ€è¦è½¬æ¢æˆ double
        // è¿™é‡Œè½¬æ¢æˆ doubleä¸ä¼šæœ‰ä»€ä¹ˆå½±å“, å› ä¸ºè¿™ä¸¤ä¸ªå‚æ•°åªæ˜¯æœ¬åœ°è°ƒè¯•æ˜¾ç¤ºç”¨çš„.
        elem["docId"] = (double)doc->_docId;
        elem["weight"] = (double)elemOut._weight;

        root.append(elem);
    }

    // åºåˆ—åŒ–å®Œæˆä¹‹åå°†ç›¸å…³å†…å®¹å†™å…¥å­—ç¬¦ä¸²
    // for Debug ç”¨ styledWriter
    Json::StyledWriter writer;
    *jsonString = writer.write(root);
}
```

æ‰§è¡Œæœç´¢, é¦–å…ˆè¦åšçš„å°±æ˜¯**å¯¹ä¼ å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œåˆ†è¯**

ç„¶åæ ¹æ®æ¯ä¸ªåˆ†è¯, åœ¨å€’æ’ç´¢å¼•ä¸­æŸ¥æ‰¾å¯¹åº”çš„å€’æ’æ‹‰é“¾, å†é€šè¿‡éå†å€’æ’æ‹‰é“¾å°±å¯ä»¥è·å–åˆ°å½“å‰å…³é”®å­—å¯¹åº”å‡ºç°çš„æ–‡æ¡£ç›¸å…³ä¿¡æ¯.

ä¸è¿‡, åˆ†è¯ä¹‹å-éå†æ—¶-æ­£å¼æŸ¥æ‰¾ä¹‹å‰ è¦åšçš„é¦–è¦ä»»åŠ¡å°±æ˜¯,**å°†åˆ†è¯è½¬æ¢ä¸ºå°å†™**. å› ä¸º, å€’æ’ç´¢å¼•ä¸­çš„æ‰€æœ‰å…³é”®è¯ éƒ½æ˜¯å°å†™çš„çŠ¶æ€

å¹¶ä¸”, æŸ¥æ‰¾åˆ°å€’æ’æ‹‰é“¾ åœ¨è·å–å¹¶ç»Ÿè®¡æ–‡æ¡£ä¿¡æ¯æ—¶, è¿˜ä¼šå‡ºç°ä¸åŒå…³é”®å­—æŒ‡å‘åŒä¸€æ–‡æ¡£çš„æƒ…å†µ, è¿™ç§æƒ…å†µæ˜¯éœ€è¦å¤„ç†çš„**ä¸èƒ½å¤šæ¬¡è®°å½•åŒä¸€ä¸ªæ–‡æ¡£**.

è¿˜æœ‰å°±æ˜¯, å¦‚æœä¸€æ¬¡æœç´¢ä¸­**å¤šä¸ªå…³é”®è¯æŒ‡å‘äº†åŒä¸€ä¸ªæ–‡æ¡£ é‚£ä¹ˆå°±è¯´æ˜æ­¤æ–‡æ¡£çš„ä¸æœç´¢å†…å®¹çš„ç›¸å…³æ€§æ›´é«˜**, æ­¤æ—¶æ˜¯éœ€è¦å°†æ–‡æ¡£çš„æ˜¾ç¤ºæƒé‡å¢åŠ çš„.

æ ¹æ®è¿™äº›éœ€æ±‚, å®ç°äº†ç¬¬ä¸€éƒ¨åˆ†çš„ä»£ç :

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710225958540.webp)

ç¬¬ä¸€éƒ¨åˆ†çš„ä»£ç å®ç°äº†:

1. å¯¹æœç´¢å†…å®¹åˆ†è¯
2. éå†åˆ†è¯æŸ¥æ‰¾å€’æ’æ‹‰é“¾
3. æ ¹æ®å€’æ’æ‹‰é“¾ å»é‡è·å–æ–‡æ¡£ä¿¡æ¯

è¿™éƒ¨åˆ†ä»£ç , æœ‰ä¸‰ä¸ªè¦ç‚¹:

1. éœ€è¦å®šä¹‰ä¸€ä¸ª`unordered_map`æ¥å®ç°å¯¹æœç´¢åˆ°çš„æ–‡æ¡£ è®°å½•å¹¶å»é‡

2. å¦‚æœå•çº¯åœ° å¯¹å¤šä¸ªå…³é”®è¯æœåˆ°çš„åŒä¸€ä¸ªæ–‡æ¡£ å»é‡, è€Œä¸è®°å½•ç›¸å…³çš„å…³é”®å­—, é‚£ä¹ˆå°±æ— æ³•å¾—çŸ¥æ­¤æ–‡æ¡£æ˜¯æ ¹æ®é‚£äº›å…³é”®å­—æœç´¢åˆ°çš„.  é‚£ä¹ˆå†å»é‡çš„åŒæ—¶, è¿˜éœ€è¦è®°å½•å¯¹åº”çš„å…³é”®è¯

    ä¹Ÿå°±æ˜¯è¯´, `unordered_map` å­˜å‚¨çš„å…ƒç´ ç±»å‹ä¸èƒ½æ˜¯ç®€å•çš„`ns_index::invertedElem`, å› ä¸º`invertedElem`æ²¡æœ‰åŠæ³•å¾ˆå¥½çš„è®°å½•å¤šä¸ªå…³é”®è¯

    æ‰€ä»¥, å®šä¹‰äº†ä¸€ä¸ªç»“æ„ä½“:

    ```cpp
    typedef struct invertedElemOut {
        std::size_t _docId;
        std::uint64_t _weight;
        std::vector<std::string> _keywords;
    } invertedElemOut_t;
    ```

    æˆå‘˜ä¾æ—§åŒ…æ‹¬ æ–‡æ¡£`id`å’Œæƒé‡, ä½†æ˜¯ç¬¬ä¸‰ä¸ªæˆå‘˜å˜é‡ä¸`invertedElem`ä¸åŒ, `invertedElemOut`çš„ç¬¬ä¸‰ä¸ªæˆå‘˜å˜é‡æ˜¯`vector<string>`, é€‚åˆå­˜å‚¨å¤šä¸ªå…³é”®å­—.

3. ç¬¬ä¸‰ä¸ªè¦ç‚¹å°±æ˜¯: `unordered_map`ä¸­å­˜å‚¨çš„å¯¹åº”æ­¤å…³é”®å­—çš„å…ƒç´ çš„æƒé‡, éœ€è¦`+=`å½“å‰å…³é”®å­—çš„æƒé‡.

    å› ä¸º**å¤šä¸ªå…³é”®è¯æŒ‡å‘äº†åŒä¸€ä¸ªæ–‡æ¡£ é‚£ä¹ˆå°±è¯´æ˜æ­¤æ–‡æ¡£çš„ä¸æœç´¢å†…å®¹çš„ç›¸å…³æ€§æ›´é«˜, æ‰€ä»¥ å°±å¯ä»¥å°†å¤šä¸ªå…³é”®å­—å…³äºæ­¤æ–‡æ¡£çš„æƒé‡ç›¸åŠ , è¡¨ç¤ºæœç´¢ç›¸å…³æ€§é«˜**

ç¬¬ä¸€éƒ¨åˆ†æ‰§è¡Œå®Œä¹‹å, æ ¹æ®æœç´¢å†…å®¹ æŸ¥æ‰¾åˆ°çš„æ‰€æœ‰çš„æ–‡æ¡£çš„ç›¸å…³ä¿¡æ¯, éƒ½å­˜å‚¨åœ¨äº†`invertedElemOutMap`ä¸­.

æ¥ä¸‹æ¥è¦åšçš„, å¹¶ä¸æ˜¯éå†`unordered_map`è·å–æ–‡æ¡£`id`, å»æ­£æ’ç´¢å¼•ä¸­æŸ¥æ‰¾æ–‡æ¡£çš„å†…å®¹. è€Œæ˜¯éœ€è¦å…ˆæ ¹æ®æ–‡æ¡£çš„æ˜¾ç¤ºæƒé‡è¿›è¡Œæ’åº. æ’å®Œåºä¹‹å, å†è¿›è¡Œæ–‡æ¡£å†…å®¹çš„è·å–.

å› ä¸º, è·å–æ¯åˆ°ä¸€ä¸ªæ–‡æ¡£å†…å®¹å°±éœ€è¦å°†æ–‡æ¡£å†…å®¹è¾“å‡ºäº†, è¾“å‡ºä¹‹å å°±è¦åšå¤„ç†å“åº”å›å®¢æˆ·ç«¯è¿›è¡Œæ˜¾ç¤ºäº†. è¿™ä¹Ÿæ„å‘³ç€ åœ¨æ­£æ’ç´¢å¼•ä¸­çš„æŸ¥æ‰¾é¡ºåº å®é™…å°±æ˜¯æœç´¢ç»“æœçš„æ˜¾ç¤ºé¡ºåº, æ‰€ä»¥åœ¨æŸ¥æ‰¾ä¹‹å‰, éœ€è¦å…ˆæ’åº:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230001169.webp)

è¿™é‡Œçš„å®ç°, å…ˆä½¿ç”¨`vector`å­˜å‚¨`invertedElemOut`å…ƒç´ . ä¸ºäº†æ–¹ä¾¿æ’åº

ç„¶åé€šè¿‡`std::sort()`+`lambda`è¿›è¡Œé™åºæ’åº

è¿™é‡Œéœ€è¦æ³¨æ„ä¸€ä¸ªç»†èŠ‚:

1. åœ¨å‘`vector`æ’å…¥å…ƒç´ æ—¶, å¯¹`invertedElemOutMap`ä¸­å­˜å‚¨çš„å…ƒç´ æ‰§è¡Œ`std::move()`

    ä¹Ÿå°±æ˜¯ ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰, é˜²æ­¢å‘ç”Ÿæ‹·è´æ„é€ . 

    å¯ä»¥ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰çš„åŸå› å°±æ˜¯, æ„å»ºå®Œ`vector`ä¹‹å, `invertedElemOutMap`å°±æ²¡ç”¨äº†, ä¸éœ€è¦å­˜å‚¨å…ƒç´ .

æ‰§è¡Œå®Œè¿™ä¸€éƒ¨åˆ†ä»£ç . æ­¤æ¬¡æœç´¢åˆ°çš„æ‰€æœ‰çš„æ–‡æ¡£idç›¸å…³ä¿¡æ¯å°±æŒ‰ç…§æ˜¾ç¤ºæƒé‡çš„é™åºè¢«å­˜å‚¨åˆ°äº† `std::vector<invertedElemOut_t> allInvertedElemOut`ä¸­.

æ¥ä¸‹æ¥, å°±æ˜¯æ ¹æ®æ–‡æ¡£idç›¸å…³ä¿¡æ¯ åœ¨æ­£æ’ç´¢å¼•ä¸­ æŸ¥æ‰¾æ–‡æ¡£å†…å®¹ä¿¡æ¯äº†

è¿™éƒ¨åˆ†ä»£ç , å®é™…å°±æ˜¯æœç´¢çš„æœ€åä¸€éƒ¨åˆ†ä»£ç äº†. 

æœ€åä¸€éƒ¨åˆ†çš„ä»£ç  å…¶å®ç›¸å¯¹ç®€å•, åªéœ€è¦åœ¨æ­£æ´¾ç´¢å¼•ä¸­æ‰¾åˆ°æ–‡æ¡£çš„å†…å®¹ä¿¡æ¯, ç„¶ååºåˆ—åŒ–å¹¶å­˜å‚¨èµ·æ¥å°±å¯ä»¥äº†.

ç­‰è·å–åˆ°å…¨éƒ¨çš„æ–‡æ¡£å†…å®¹ä¿¡æ¯, å†å°†ç»“æœé€šè¿‡è¾“å‡ºå‹å‚æ•°ä¼ é€’å‡ºå»å°±å¯ä»¥äº†

> å¯¹å†…å®¹åšåºåˆ—åŒ–å¤„ç†, éœ€è¦ç”¨åˆ°`jsoncpp`.
>
> åœ¨`CentOS`å¹³å°ä¸‹, ç›´æ¥æ‰§è¡Œ`sudo yum install -y jsoncpp-devel`å°±å¯ä»¥å®‰è£…äº†
>
> å…³äº`jsoncpp`æœ€åŸºæœ¬çš„ä½¿ç”¨çš„ç›¸å…³ä»‹ç», å¯ä»¥çœ‹ä¸€ä¸‹è¿™ç¯‡æ–‡ç« :
>
> [[Linux] åˆè¯†åº”ç”¨å±‚åè®®: åºåˆ—åŒ–ä¸ååºåˆ—åŒ–ã€ç¼–ç ä¸è§£ç ã€jsoncppç®€å•é£Ÿç”¨...](https://www.humid1ch.cn/posts/Linux-Application-Layer-Protocol)

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230003811.webp)

è¿™æ®µä»£ç ä¸­, å”¯ä¸€è¦æ³¨æ„çš„å°±æ˜¯: 

ä½¿ç”¨`Json::Value root`å­˜å‚¨`Json::Value elem`çš„æ–¹å¼, åœ¨`root`å­˜å‚¨ä¸åŒæ–‡æ¡£çš„åºåˆ—åŒ–å†…å®¹. 

åœ¨ä¹‹å‰çš„ä½¿ç”¨ä¸­, åªéœ€è¦é€šè¿‡`Json::Value`å˜é‡åºåˆ—åŒ–ä¸€ä¸ªç»“æ„ä½“ä¹‹å, å°±å¯ä»¥å°†`Json::Value`çš„ç»“æœå†™å…¥`string`äº†.

è€Œ, è¿™é‡Œä¸ºä»€ä¹ˆè¦å¥—ä¸¤å±‚`Json::Value`å‘¢?

å› ä¸º, è¿™é‡Œ ä¼ è¾“çš„ä¸åªæ˜¯ä¸€ä¸ªç»“æ„ä½“å˜é‡çš„å†…å®¹, è€Œæ˜¯**æœ‰å¾ˆå¤šä¸ªç»“æ„ä½“**. å¾ˆå¤šä¸ªåŒç±»å‹ç»“æ„ä½“çš„å†…å®¹éƒ½éœ€è¦åºåˆ—åŒ–å¹¶å­˜å‚¨èµ·æ¥, å¾ˆè‡ªç„¶è€Œç„¶å°±å¯ä»¥æƒ³åˆ°è¦ä½¿ç”¨ä¸¤å±‚ç»“æ„. å¹¶ä¸”è¿˜éœ€è¦ä¿è¯åºåˆ—åŒ–, æ‰€ä»¥å°±æ˜¯ç”¨`Json::Value`åµŒå¥—çš„æ–¹å¼å¯¹ä¸åŒçš„æ–‡æ¡£å†…å®¹åºåˆ—åŒ–å¹¶å­˜å‚¨.

è€Œ `Json::Value`ä¹Ÿå¾ˆå¥½çš„æ”¯æŒäº†å­˜å‚¨`Json::Value`çš„æ¥å£, å°±æ˜¯`Json::Value::append()`. 

>  æºç ä¸­å…³äº`append()`çš„å£°æ˜, å‚æ•°å°±æ˜¯`Json::Value&`:
>
> ```cpp
> Value& Value::append(const Value& value) { return append(Value(value)); }
> 
> Value& Value::append(Value&& value) {
>       JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue,
>                            "in Json::Value::append: requires arrayValue");
>       if (type() == nullValue) {
>            *this = Value(arrayValue);
>       }
>       return this->value_.map_->emplace(size(), std::move(value)).first->second;
> }
> ```

è¿˜æœ‰å°±æ˜¯, `elem`ä¸­å¹¶ä¸ åºåˆ—åŒ–å­˜å‚¨æ–‡æ¡£çš„å®Œæ•´å†…å®¹, è€Œæ˜¯å­˜å‚¨æ–‡æ¡£çš„éƒ¨åˆ†å†…å®¹.

æ‰€ä»¥å°±éœ€è¦å®ç°ä¸€ä¸ª`getDesc()`æ¥å£

### `getDesc()`æ‘˜è¦è·å–æ¥å£ å®ç°

æˆ‘ä»¬æ‘˜è¦è·å–çš„æ€è·¯éå¸¸ç®€å•, å°±æ˜¯ åœ¨æ­£æ–‡å†…å®¹ä¸­æ‰¾åˆ°ç¬¬ä¸€ä¸ªå…³é”®è¯çš„æ‰€åœ¨ä½ç½®. ç„¶å æˆªå– æ­¤ä½ç½®çš„å‰50å­—èŠ‚åˆ°æ­¤ä½ç½®çš„å100å­—èŠ‚ çš„å†…å®¹.

```cpp
std::string getDesc(const std::string& content, const std::string& keyword) {
    // å¦‚ä½•è·å–æ‘˜è¦å‘¢?
    // æˆ‘ä»¬å°è¯•è·å–æ­£æ–‡ä¸­ ç¬¬ä¸€ä¸ªkeyword çš„å‰50ä¸ªå­—èŠ‚å’Œå100ä¸ªå­—èŠ‚çš„å†…å®¹ ä½œä¸ºæ‘˜è¦
    const std::size_t prevStep = 50;
    const std::size_t nextStep = 100;

    // è·å–æ­£æ–‡ä¸­ ç¬¬ä¸€ä¸ª keyword çš„ä½ç½®
    std::size_t pos = content.find(keyword);
    if (pos == std::string::npos)
        return "keyword does not exist!";

    std::size_t begin = 0;
    std::size_t end = content.size() - 1;

    // è·å–å‰50å­—èŠ‚ å’Œ å100å­—èŠ‚çš„è¿­ä»£å™¨ä½ç½®
    if (pos > begin + prevStep)
        begin += (pos - prevStep);
    if (pos + nextStep < end)
        end = pos + nextStep;

    if (begin >= end)
        return "nothing!";

    // è·å–æ‘˜è¦
    std::string desc;
    if (content.begin() + begin > content.begin())
        desc = "...";
    desc += content.substr(begin, end - begin);
    if (content.begin() + end < content.end())
        desc += "...";

    return desc;
}
```

## æ¼”ç¤º åŠ è°ƒè¯•

ä¸Šé¢å·²ç»å°†æ‰€æœ‰ æœç´¢çš„ç›¸å…³æ¥å£éƒ½å®ç°äº†.

ä¸‹é¢æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç®€å•çš„ä»£ç è°ƒè¯•ä¸€ä¸‹:

```cpp
#include <iostream>
#include "util.hpp"
#include "index.hpp"
#include "searcher.hpp"

const std::string& rawPath = "./data/output/raw";

int main() {
	ns_searcher::searcher searcher;
	searcher.initSearcher(rawPath);

	std::string query;
	std::string json_string;

	char buffer[1024];
	while (true) {
		std::cout << "Please Enter You Search Query# ";
		fgets(buffer, sizeof(buffer) - 1, stdin);
		buffer[strlen(buffer) - 1] = 0;
		query = buffer;
		searcher.search(query, &json_string);
		std::cout << json_string << std::endl;
	}

	return 0;
}
```

è¿™æ®µä»£ç å¯ä»¥æŠŠæœç´¢åˆ°çš„å†…å®¹ ç›´æ¥æ‰“å°å‡ºæ¥.

æˆ‘ä»¬æ¼”ç¤ºä¸€ä¸‹:

é¦–å…ˆæ˜¯ å»ºç«‹ç´¢å¼•çš„è¿‡ç¨‹:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230007666.gif)

ç„¶åå°±æ˜¯æœç´¢

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230009497.gif)

ä»å¤§ä½“çš„ç»“æœä¸Šæ¥çœ‹, æ˜¯æ²¡ä»€ä¹ˆé—®é¢˜çš„. ä¸ä»…å¯ä»¥æœç´¢åˆ°, è€Œä¸”æ˜¯æŒ‰ç…§`weight`æ’åºçš„

ä½†æ˜¯, ä¸ºä»€ä¹ˆ`desc`ä¼šæ˜¯`keyword does not exist!`? 

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230012352.webp)

æœåˆ°äº†æ–‡æ¡£, åº”è¯¥å°±è¡¨ç¤ºæ–‡æ¡£ä¸­æœ‰è¿™ä¸ªå…³é”®è¯. ä½†ä¸ºä»€ä¹ˆä¼šå‡ºç°`keyword does not exist!`?

å…¶å®åŸå› å¾ˆç®€å•: æˆ‘ä»¬é€šè¿‡å…³é”®è¯ åœ¨å€’æ’ç´¢å¼•ä¸­æœç´¢, éƒ½æ˜¯é€šè¿‡å…¨å°å†™æ¥æœç´¢çš„. æ‰€ä»¥å¯ä»¥ æœåˆ°æ–‡æ¡£. ä½†æ˜¯`getDesc()`è·å–æ‘˜è¦çš„æ¥å£, å¯å¹¶æ²¡æœ‰å®ç°é€šè¿‡å°å†™æ¥æŸ¥è¯¢å…³é”®å­—. è¿™æ—¶å€™, å°±æœ‰å¯èƒ½æ‰¾ä¸åˆ°å…¨å°å†™çš„å…³é”®å­—, ä¹Ÿå°±æ— æ³•è·å–æ‘˜è¦.

æ‰€ä»¥, `getDesc()`æ¥å£ åœ¨æ­£æ–‡å†…å®¹ä¸­æŸ¥æ‰¾å…³é”®å­—çš„è¡Œä¸º, ä¸èƒ½ç®€å•çš„ä½¿ç”¨`string::find()`. 

### `getDesc()`æ¥å£ ä¼˜åŒ–

ä¸èƒ½ä½¿ç”¨`string::find()`, å¹¶ä¸” `string`ä¹Ÿå¹¶æ²¡æœ‰æä¾›å¿½ç•¥å¤§å°å†™æœç´¢çš„æ¥å£

è€Œä¸”, å…³é”®è¯å¯ä»¥æ”¹ä¸ºå°å†™, ä½†æ˜¯ä¹Ÿä¸èƒ½å°†æ­£æ–‡å†…å®¹å…¨éƒ¨è½¬æ¢æˆå°å†™å‘€.

é‚£ä¹ˆ, åœ¨æ­£æ–‡ä¸­å¦‚ä½•å¿½ç•¥å¤§å°å†™çš„æŸ¥æ‰¾å…³é”®è¯å‘¢? 

`std::search()`æ¥å£. å¯ä»¥é€šè¿‡ä»¿å‡½æ•°æ¥è®¾ç½®å­—ç¬¦ä¹‹é—´çš„æŸ¥æ‰¾æ–¹å¼:

```cpp
std::string getDesc(const std::string& content, const std::string& keyword) {
    // å¦‚ä½•è·å–æ‘˜è¦å‘¢?
    // æˆ‘ä»¬å°è¯•è·å–æ­£æ–‡ä¸­ ç¬¬ä¸€ä¸ªkeyword çš„å‰50ä¸ªå­—èŠ‚å’Œå100ä¸ªå­—èŠ‚çš„å†…å®¹ ä½œä¸ºæ‘˜è¦
    const std::size_t prevStep = 50;
    const std::size_t nextStep = 100;
    // è·å–æ­£æ–‡ä¸­ ç¬¬ä¸€ä¸ª keyword çš„ä½ç½®

    // std::size_t pos = content.find(keyword);
    // if (pos == std::string::npos)
    //     return "keyword does not exist!";
    // ç›´æ¥è¿™æ ·å¤„ç†, ä¼šå‡ºç°ä¸€ä¸ªé—®é¢˜:
    // keywordæ˜¯æœ‰å¤§å°å†™çš„. å€’æ’ç´¢å¼•ä¸­æŸ¥æ‰¾ æˆ‘ä»¬å®ç°çš„æ˜¯å¿½ç•¥å¤§å°å†™, æ‰€ä»¥å¯ä»¥æ‰¾åˆ°æ–‡æ¡£
    // è€Œ string::find() æ˜¯åŒºåˆ†å¤§å°å†™çš„æŸ¥æ‰¾, å¯èƒ½æ— æ³•åœ¨å†…å®¹ä¸­æ‰¾åˆ°å¯¹åº”çš„å…³é”®è¯
    // stringå®¹å™¨ä¹Ÿæ²¡æœ‰æä¾›ä¸åŒºåˆ†å¤§å°å†™çš„æŸ¥æ‰¾æ–¹æ³•
    // æ­¤æ—¶, å¯ä»¥ç”¨std::search()
    // std::search(it1, it2, it3, it4, pred);
    // å¯ä»¥åœ¨[it1, it2)ä¸­ æŸ¥æ‰¾ç¬¬ä¸€ä¸ª[it3, it4)(è¯è¯­)çš„å‡ºç°ä½ç½®.
    // å¹¶ä¸”, å¦‚æœä½¿ç”¨ç¬¬5ä¸ªå‚æ•°, å°±å¯ä»¥ä¼ å…¥ å¸¦æœ‰ä¸¤ä¸ªå‚æ•°çš„ä»¿å‡½æ•°, è¿™ä¸¤ä¸ªå‚æ•°å°±æ˜¯éœ€è¦æ¯”è¾ƒçš„å­—ç¬¦
    // å¯ä»¥åœ¨ä»¿å‡½æ•°å†…è®¾ç½®è¿™ä¸¤ä¸ªå­—ç¬¦çš„æ¯”è¾ƒæ–¹å¼
    // æœ€ç»ˆä¼šè¿”å›æ‰¾åˆ°çš„æ‰¾åˆ°çš„å•æ¬¡ç¬¬ä¸€ä¸ªå­—ç¬¦ä½ç½®çš„è¿­ä»£å™¨, å¦åˆ™è¿”å›it2
    auto iter = std::search(content.begin(), content.end(), keyword.begin(), keyword.end(),
                            [](int x, int y) {
                                return std::tolower(x) == std::tolower(y);
                            });
    if (iter == content.end())
        return "keyword does not exist!";
    std::size_t pos = std::distance(content.begin(), iter);

    std::size_t begin = 0;
    std::size_t end = content.size() - 1;

    // è·å–å‰50å­—èŠ‚ å’Œ å100å­—èŠ‚çš„è¿­ä»£å™¨ä½ç½®
    if (pos > begin + prevStep)
        begin += (pos - prevStep);
    if (pos + nextStep < end)
        end = pos + nextStep;

    if (begin >= end)
        return "nothing!";

    // è·å–æ‘˜è¦
    std::string desc;
    if (content.begin() + begin > content.begin())
        desc = "...";
    desc += content.substr(begin, end - begin);
    if (content.begin() + end < content.end())
        desc += "...";

    return desc;
}
```

ä½¿ç”¨`std::search(it1, it2, it3, it4, pred);`

å¯ä»¥åœ¨`[it1, it2)`ä¸­ æŸ¥æ‰¾ç¬¬ä¸€ä¸ª`[it3, it4)(è¯è¯­)`çš„å‡ºç°ä½ç½®.

å¹¶ä¸”, å¦‚æœä½¿ç”¨ç¬¬5ä¸ªå‚æ•°, å°±å¯ä»¥ä¼ å…¥**å¸¦æœ‰ä¸¤ä¸ªå‚æ•°çš„ä»¿å‡½æ•°, è¿™ä¸¤ä¸ªå‚æ•°å°±æ˜¯éœ€è¦æ¯”è¾ƒçš„å­—ç¬¦**å¯ä»¥åœ¨ä»¿å‡½æ•°å†…è®¾ç½®è¿™**ä¸¤ä¸ªå­—ç¬¦çš„æ¯”è¾ƒæ–¹å¼**

æœ€ç»ˆä¼šè¿”å›æ‰¾åˆ°çš„æ‰¾åˆ°çš„å•æ¬¡ç¬¬ä¸€ä¸ªå­—ç¬¦ä½ç½®çš„è¿­ä»£å™¨, å¦åˆ™è¿”å›`it2`

åœ¨ä»¿å‡½æ•°å†…, å°†å‚æ•°å­—ç¬¦éƒ½ä»¥å°å†™çš„å½¢å¼æ¯”è¾ƒ, å°±å¯ä»¥å®ç°å¿½ç•¥å¤§å°å†™æ¯”è¾ƒ:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230017489.gif)

è¿™æ¬¡, å°±å¯ä»¥åœ¨æ–‡æ¡£ä¸­æ‰¾åˆ°å…³é”®è¯äº†.

---

ä»£ç å®ç°åˆ°è¿™é‡Œ, æœ¬åœ°æœç´¢çš„æ¥å£ å…¶å®å·²ç»ç›¸å¯¹å®Œå–„äº†.

ä½†æ˜¯ è¿˜å¹¶æ²¡æœ‰ç»“æŸ

## åœç”¨è¯çš„å¤„ç† *

åœ¨é¡¹ç›®ä¸­, æˆ‘ä»¬ä½¿ç”¨`jieba`åº“é’ˆå¯¹æœç´¢å†…å®¹å’Œæ–‡æ¡£å†…å®¹æ¥åˆ†è¯, åˆ†åˆ«ç”¨æ¥æœç´¢å’Œå»ºç«‹ç´¢å¼•.

ä½†æ˜¯, åˆ†è¯æ—¶å¾ˆå¯èƒ½ä¼šåˆ†å‡ºä¸€äº›éå¸¸å¸¸è§çš„è¯, æ¯”å¦‚ä¸­æ–‡çš„: `äº†` `åœ¨` `çš„` `å®ƒ` `ä»–` `å¥¹` `ä½ `â€¦ è¿˜æœ‰è‹±æ–‡çš„: `a` `an` `the` `you` `it` `that` `this` â€¦  è¿˜æœ‰ä¸€äº›æ ‡ç‚¹ç¬¦å·. è¿™éƒ¨åˆ†è¯ è¢«ç§°ä¸º**åœç”¨è¯**æˆ–**åœæ­¢è¯**æˆ–**æš‚åœè¯**

è¿™äº›è¯, å®é™…å¯¹ è¿™ç§æ–‡æ¡£çš„æœç´¢æ˜¯æ²¡æœ‰ä»€ä¹ˆç”¨çš„. è€Œæˆ‘ä»¬åœ¨åˆ†è¯çš„æ—¶å€™ å¹¶æ²¡æœ‰å»é™¤è¿™äº›å­—, è¿™ä¼šå¯¼è‡´ä»€ä¹ˆç»“æœå‘¢?

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230019837.gif)

æœç´¢`the` ` ` `a` `an`éƒ½èƒ½æœå‡ºæ–‡æ¡£, ä½†æ˜¯æˆ‘ä»¬è¾“å…¥çš„å¹¶ä¸æ˜¯å…·æœ‰ç›®çš„çš„æœ‰æ•ˆå†…å®¹. ç©ºæ ¼éƒ½èƒ½æœå‡ºæ–‡æ¡£.

è€Œ, æˆ‘ä»¬çš„ç›®çš„æ˜¯ é˜²æ­¢ç”¨æˆ·é€šè¿‡åœç”¨è¯æŸ¥æ‰¾åˆ°äº†ä¸€äº›æ— å…³çš„æ–‡æ¡£. 

æ‰€ä»¥, æˆ‘ä»¬å¯ä»¥å°†è¿™äº›**åœç”¨è¯**åœ¨åˆ†è¯ä¹‹å, å»é™¤æ‰.

æ€ä¹ˆå»é™¤å‘¢? `jieba`åˆ†è¯åº“, å·²ç»æä¾›äº† ç»Ÿè®¡äº†å¸¸è§çš„åœç”¨è¯çš„æ–‡ä»¶: 

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230022578.webp)

å†…å®¹æ˜¯è¿™æ ·ä¸€è¡Œä¸€è¡Œçš„:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230024226.webp)

æˆ‘ä»¬åªéœ€è¦å°†æ–‡ä»¶çš„å†…å®¹æŒ‰è¡Œä»¥`string`çš„ç±»å‹ è¯»å–åˆ°å†…å­˜ä¸­, ç„¶ååœ¨åˆ†è¯ä¹‹å éå†åˆ†è¯ è¿›è¡ŒæŸ¥æ‰¾å»é™¤, å°±å¯ä»¥å®ç°å»é™¤åˆ†è¯ä¸­çš„åœç”¨è¯.

> `jieba`æä¾›çš„åœç”¨è¯æœ‰äº›ä¸é€‚åˆè¢«è¿‡æ»¤æ‰, æœ‰å…´è¶£å¯ä»¥è‡ªå·±æ•´ç†ä¸€ä¸‹
>
> æ¯”å¦‚ `about`, æ¯•ç«Ÿ`Boost`åº“æ–‡æ¡£ä¸­çš„ç¬¬ä¸€ä¸ªæ–‡æ¡£åå°±æ˜¯`about`. å¦‚æœè¢«å½“ä½œåœç”¨è¯å»æ‰äº†, æ˜¯ä¸æ˜¯æœ‰ç‚¹ä¸åˆé€‚?
>
> åšä¸»æŠŠ `about` `any` `move` åˆ é™¤æ‰. å› ä¸º`data/input`ç›®å½•ä¸‹å­˜åœ¨ä»¥è¿™ä¸‰ä¸ªå•è¯ä¸ºåçš„æ–‡æ¡£:
>
> ![|wide](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230026306.webp)

ç„¶åå¯ä»¥åœ¨`util.hpp`ä¸­çš„`jiebaUtil`ç±»ä¸­æ·»åŠ ä¸€ä¸ªå»é™¤åœç”¨è¯çš„ç‰ˆæœ¬. 

ç”±äºéœ€è¦å°†åœç”¨è¯ä»æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­, è€Œä¸”åªéœ€è¦åŠ è½½ä¸€æ¬¡, æ‰€ä»¥å¯ä»¥è€ƒè™‘å°†`jiebaUtil`è®¾ç½®ä¸ºå•ä¾‹:

```cpp
const char* const DICT_PATH = "./cppjiebaDict/jieba.dict.utf8";
const char* const HMM_PATH = "./cppjiebaDict/hmm_model.utf8";
const char* const USER_DICT_PATH = "./cppjiebaDict/user.dict.utf8";
const char* const IDF_PATH = "./cppjiebaDict/idf.utf8";
const char* const STOP_WORD_PATH = "./cppjiebaDict/stop_words.utf8";

class jiebaUtil {
    private:
    cppjieba::Jieba _jieba;
    std::unordered_map<std::string, bool> _stopKeywordMap;

    jiebaUtil()
        : _jieba(DICT_PATH, HMM_PATH, USER_DICT_PATH, IDF_PATH, STOP_WORD_PATH) {}

    jiebaUtil(const jiebaUtil&) = delete;
    jiebaUtil& operator=(const jiebaUtil&) = delete;

    static jiebaUtil* _instance;

    private:
    // ä¸»è¦æ˜¯ä¸ºäº†æ”¯æŒ æ¶ˆé™¤åœæ­¢è¯çš„åˆ†è¯
    // ä¹Ÿå°±æ˜¯éœ€è¦å°†åœæ­¢è¯, å†™å…¥åˆ° mapä¸­
    bool initJiebaUtil() {
        // é¦–å…ˆæŒ‰è¡Œè¯»å–æ–‡ä»¶ const char* const STOP_WORD_PATH = "./cppjiebaDict/stop_words.utf8"
        std::ifstream stopFile(STOP_WORD_PATH, std::ios::in);
        if (!stopFile.is_open()) {
            return false;
        }

        std::string line;
        while (std::getline(stopFile, line)) {
            _stopKeywordMap.insert({line, true});
        }

        stopFile.close();

        return true;
    }
    
    void noStopHelper(const std::string& src, std::vector<std::string>* out) {
        _jieba.CutForSearch(src, *out);
        // éå†out æŸ¥è¯¢æ˜¯å¦ä¸ºåœæ­¢è¯ æ˜¯åˆ™åˆ é™¤
        // éœ€è¦æ³¨æ„è¿­ä»£å™¨å¤±æ•ˆçš„é—®é¢˜
        for (auto iter = out->begin(); iter != out->end();) {
            std::string word = *iter;
            boost::to_lower(word);
            // è¿™é‡Œè¦æ³¨æ„, å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•° src ä¼ å…¥çš„ä¸€èˆ¬æ˜¯æ–‡æ¡£åŸæ–‡ æˆ– æœç´¢å†…å®¹çš„åŸæ–‡
            // åŸæ–‡å†…å®¹éƒ½æ˜¯åŒºåˆ†å¤§å°å†™çš„, ä¹Ÿå°±æ˜¯è¯´è¿™é‡Œçš„iteræŒ‡å‘çš„åˆ†è¯éƒ½æ˜¯æœ‰å¤§å°å†™ä¹‹åˆ†çš„
            // è€Œjiebaåº“æä¾›çš„åœç”¨è¯éƒ½æ˜¯å°å†™çš„, ä¹Ÿå°±æ˜¯è¯´_stopKeywordMapå†…å­˜å‚¨çš„å†…å®¹éƒ½æ˜¯å°å†™çš„
            // å¦‚æœæ‹¿ç€æœ‰å¤§å°å†™ä¹‹åˆ†çš„åˆ†è¯, åœ¨åœç”¨è¯è¡¨ä¸­æŸ¥æ‰¾, æ˜¯æŸ¥æ‰¾ä¸åˆ°çš„. 
            // æ‰€ä»¥åœ¨æŸ¥æ‰¾ä¹‹å‰, è¦å…ˆå°†iteræŒ‡å‘çš„åˆ†è¯ å°å†™åŒ–, ç„¶åå†åœ¨åœç”¨è¯è¡¨ä¸­æ‰¾
            auto stopIt = _stopKeywordMap.find(word);
            if (stopIt != _stopKeywordMap.end())
                // æ³¨æ„æ¥æ”¶eraseçš„è¿”å›å€¼ é˜²æ­¢å‡ºç°è¿­ä»£å™¨å¤±æ•ˆé—®é¢˜
                iter = out->erase(iter);
            else
                iter++;
        }
    }

    public:
    static jiebaUtil* getInstance() {
        static std::mutex mtx;
        if (nullptr == _instance) {
            mtx.lock();
            if (nullptr == _instance) {
                _instance = new jiebaUtil;
                _instance->initJiebaUtil(); // åˆå§‹åŒ–å•ä¾‹
            }
            mtx.unlock();
        }

        return _instance;
    }

    // åˆ†è¯: ä¸æ¶ˆé™¤åœæ­¢è¯çš„ç‰ˆæœ¬
    void cutString(const std::string& src, std::vector<std::string>* out) {
        _jieba.CutForSearch(src, *out);
    }
    // åˆ†è¯: æ¶ˆé™¤åœæ­¢è¯çš„ç‰ˆæœ¬
    void cutStringNoStop(const std::string& src, std::vector<std::string>* out) {
        noStopHelper(src, out);
    }
};
jiebaUtil* jiebaUtil::_instance;
```

å…·ä½“çš„å®ç°æ€è·¯æ˜¯: 

1. æ·»åŠ ä¸€ä¸ª`unordered_map<string, bool>`æˆå‘˜å¯¹è±¡, ç”¨æ¥è®°å½•åœç”¨è¯
2. å®šä¹‰ä¸€ä¸ª`initJiebaUtil()`æ¥å£, ç”¨äºåˆå§‹åŒ–`jiebaUtil`ç±». å®é™…åšçš„æ˜¯ å°†åœç”¨è¯åŠ è½½åˆ°`unordered_map`ä¸­çš„å·¥ä½œ
3. ç„¶åå®šä¹‰ä¸€ä¸ªç§æœ‰çš„`noStopHelper()`æ¥å£, ç”¨äºä»¥æ¶ˆé™¤æš‚åœè¯çš„æ–¹å¼åˆ†è¯
4. ç„¶åæä¾›ä¸€ä¸ªå…¬æœ‰çš„`cutStringNoStop()`æ¥å£, å°è£…`noStopHelper()`.
5. ç„¶åå†å®ç°çº¿ç¨‹å®‰å…¨çš„å•ä¾‹æ¨¡å¼å°±å¥½äº†

ç‰¹åˆ«éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯: **å®ç°å¯¹åˆ†è¯è¿›è¡Œå»é™¤åœç”¨è¯çš„æ“ä½œæ—¶, åœ¨å¯¹`src`åˆ†è¯ä¹‹å éœ€è¦éå†åˆ†è¯å¹¶åœ¨åœç”¨è¯è¡¨ä¸­æŸ¥æ‰¾æ˜¯å¦ä¸ºåœç”¨è¯. æŸ¥æ‰¾ æ­¤åˆ†è¯åœ¨åœç”¨è¯è¡¨ä¸­æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æ—¶, å¿…é¡»è¦å…ˆå°†åˆ†è¯å°å†™åŒ–. å› ä¸ºåœç”¨è¯è¡¨ä¸­çš„è¯éƒ½æ˜¯å°å†™çš„, å¦‚æœæ‹¿ç€æœ‰å¤§å°å†™ä¹‹åˆ†çš„è¯, å»æŸ¥å…¨å°å†™çš„è¡¨, ä¼šå‡ºç°åº”è¯¥æ‰¾åˆ° ä½†æ˜¯å´æ²¡æœ‰æ‰¾åˆ°çš„æƒ…å†µ.**

å¹¶ä¸”, å°†`jiebaUtil`è®¾ç½®ä¸ºå•ä¾‹æ¨¡å¼. ä¹Ÿå°±æ„å‘³ç€ä¹‹å‰ è°ƒç”¨åˆ†è¯çš„æ¥å£éœ€è¦ä¿®æ”¹ä¸€ä¸‹. ä¸è¿‡å…ˆä¸æ€¥.

å…ˆæ¥åˆ†æå‡ ä¸ªé—®é¢˜:

1. åˆ†è¯æ“ä½œè¦åœ¨å“ªé‡Œåš?

    ç­”: æœç´¢çš„æ—¶å€™, å¯¹è¾“å…¥çš„å†…å®¹åˆ†è¯ ä»¥åŠ å»ºç«‹å€’æ’ç´¢å¼•çš„æ—¶å€™, å¯¹æ–‡æ¡£çš„å†…å®¹åˆ†è¯

2. å»é™¤åœç”¨è¯çš„åˆ†è¯æ“ä½œ, æ˜¯å¦ä¼šæ¶ˆè€—æ›´é•¿çš„æ—¶é—´ã€æ›´å¤šçš„èµ„æº?

    ç­”: è‚¯å®šä¼šçš„. å› ä¸ºå»é™¤åœç”¨è¯çš„æ­¥éª¤, è¯´åˆ°åº•å°±æ˜¯éå†åˆ†å‡ºæ¥çš„è¯ å¹¶åœ¨`åœç”¨è¯çš„unordered_map`ä¸­æŸ¥æ‰¾æ˜¯å¦æœ‰å½“å‰è¯. è‡³å°‘æ˜¯ä¸€ä¸ª`O(N)`çš„è¿‡ç¨‹

3. æœç´¢æ—¶ å’Œ å»ºç«‹ç´¢å¼•æ—¶, æ˜¯å¦éƒ½éœ€è¦ç”¨åˆ° å»é™¤åœç”¨è¯çš„åˆ†è¯æ“ä½œ?

    ç­”æ¡ˆæ˜¯, **ä¸éœ€è¦**éƒ½ä½¿ç”¨å»é™¤åœç”¨è¯çš„åˆ†è¯æ“ä½œ

    è¿™ä¸¤æ–¹, **åªè¦æœ‰ä¸€æ–¹å»é™¤äº†åœç”¨è¯**. é‚£ä¹ˆåœ¨æœç´¢æ—¶, **å°±ä¸ä¼šæ ¹æ®åœç”¨è¯å»æœç´¢æ–‡æ¡£**. é‚£ä¹ˆä¹Ÿå°±åˆ†äº†ä¸¤ç§æƒ…å†µ:

    1. æœç´¢æ—¶ å»é™¤äº†åœç”¨è¯, å»ºç«‹ç´¢å¼•æ—¶ æ²¡æœ‰å»é™¤åœç”¨è¯

        é‚£ä¹ˆ, å°±åªä¼šä½¿ç”¨ æœ‰æ•ˆè¯ æœç´¢, ç´¢å¼•ä¸­æ˜¯å¦å­˜åœ¨åœç”¨è¯çš„ç›¸å…³ç´¢å¼• ä¹Ÿå°±æ²¡æœ‰å…³ç³»

    2. æœç´¢æ—¶ æ²¡æœ‰å»é™¤åœç”¨è¯, å»ºç«‹ç´¢å¼•æ—¶ å»é™¤äº†åœç”¨è¯

        é‚£ä¹ˆ, ç´¢å¼•ä¸­å°±ä¸ä¼šå­˜åœ¨åœç”¨è¯çš„ç›¸å…³ç´¢å¼•, å°±ç®—ä½¿ç”¨ åœç”¨è¯ å»æœç´¢, ä¹Ÿä¸ä¼šæ ¹æ®åœç”¨è¯æœç´¢åˆ°æ–‡æ¡£.

    è¿™ä¸¤ç§æƒ…å†µ, æœ‰å¾ˆå¤§çš„åŒºåˆ«. æˆ‘ä»¬çŸ¥é“, å»é™¤åœç”¨è¯æ˜¯éœ€è¦æ¶ˆè€—èµ„æºçš„. åˆ†è¯è¶Šå¤š, ç”¨çš„æ—¶é—´å°±è¶Šä¹…, é‚£ä¹ˆå¯¹äºå»ºç«‹ç´¢å¼•æ—¶çš„å»é™¤åœç”¨è¯æ“ä½œæ¥è¯´, é‚£å°†ä¼šæ˜¯ä¸€ä¸ªéå¸¸è€—æ—¶çš„å·¥ç¨‹. 

    æ¯ä¸€ç¯‡æ–‡æ¡£å†…å®¹ éƒ½å¯èƒ½åˆ†å‡ºä¸Šåƒ ç”šè‡³ä¸Šä¸‡çš„è¯. å¦‚æœå¯¹æ¯ç¯‡æ–‡æ¡£çš„åˆ†è¯åœ¨è¿›è¡Œå»é™¤åœç”¨è¯çš„æ“ä½œ. é‚£å°†ä¼šéå¸¸çš„è€—æ—¶.

    é‚£ä¹ˆ:

    1. å¯¹äºç¬¬ä¸€ç§æƒ…å†µ. æœç´¢æ—¶ è¾“å…¥çš„å†…å®¹ç»å¤§æƒ…å†µä¸‹æ˜¯æ¯”æ–‡æ¡£å†…å®¹å°‘çš„. è™½ç„¶ä¹Ÿä¼šæœ‰ä¸€å®šçš„æ¶ˆè€—, ä½†æ˜¯æ²¡æœ‰å»ºç«‹ç´¢å¼•æ—¶æ¶ˆè€—çš„å¤§

        å¦‚æœåªåœ¨æœç´¢æ—¶, å¯¹æœç´¢åˆ†è¯è¿›è¡Œå»é™¤åœç”¨è¯. è€Œå»ºç«‹ç´¢å¼•æ—¶ä¸å»é™¤åœç”¨è¯

        é‚£ä¹ˆ, å¦‚æœä»å…¨å±€çš„è§’åº¦æ¥çœ‹, æœåŠ¡å™¨å°±æ²¡æœ‰éå¸¸å·¨å¤§çš„æ¶ˆè€—

    2. è€Œå¯¹äºç¬¬äºŒç§æƒ…å†µ. 

        å¦‚æœåœ¨å»ºç«‹ç´¢å¼•æ—¶, å¯¹æ¯ç¯‡æ–‡ç« çš„å†…å®¹åˆ†è¯å»é™¤åœç”¨è¯. å°±æ˜¯ä¸€ä¸ªéå¸¸è€—æ—¶çš„å·¥ç¨‹.

        ä»å…¨å±€çš„è§’åº¦æ¥çœ‹, æœåŠ¡å™¨ä¼šå­˜åœ¨ä¸€æ®µéå¸¸å·¨å¤§çš„æ¶ˆè€—

    æ‰€ä»¥, æˆ‘ä»¬åº”è¯¥é€‰ç¬¬2ç§æƒ…å†µå—?

    å¹¶ä¸æ˜¯çš„. 

    **ä»ç”¨æˆ·çš„æ•ˆç‡æ¥è®², æœ€å¥½é€‰ç”¨ç¬¬ä¸€ç§æƒ…å†µ**, ä¸ºä»€ä¹ˆ? 

    å› ä¸ºæˆ‘ä»¬çš„æœç´¢å¼•æ“ æ˜¯ç»™ç”¨æˆ·æä¾›æœåŠ¡çš„, æœç´¢çš„é€Ÿåº¦ç”¨æˆ·å¯ä»¥æ„ŸçŸ¥åˆ°. å¦‚æœåœ¨æœç´¢æ—¶ è¿›è¡Œå»é™¤åœç”¨è¯çš„æ“ä½œ. æŸäº›æƒ…å†µä¸‹, å¯èƒ½ä¼šåœ¨ä¸€å®šç¨‹åº¦ä¸Šå½±å“æœç´¢çš„æ•ˆç‡

    è€Œ ç´¢å¼•çš„å»ºç«‹, æ˜¯å®ç°åœ¨æœåŠ¡å™¨æ­£å¼å¯åŠ¨ä¹‹å‰çš„. è¿™ä¸€éƒ¨åˆ†çš„å¼€é”€å†å¤§, ç”¨æˆ·ä¹Ÿæ˜¯æ„ŸçŸ¥ä¸åˆ°çš„. 

    æ‰€ä»¥, æˆ‘ä»¬è¿™é‡Œé€‰æ‹©ç¬¬1ç§å®ç°.

    > å½“ç„¶, æƒ…å†µçš„é€‰æ‹©ä¸ç»å¯¹. å› ä¸ºç½‘ç»œä¸Šæ•°æ®çš„ä¼ è¾“æƒ…å†µéå¸¸çš„å¤æ‚. å¯èƒ½ä¼ è¾“çš„æ•°æ®é‡ä¹Ÿä¼šå¾ˆå¤§ç¨‹åº¦ä¸Šå½±å“æ•ˆç‡
    >
    > å°±åƒä¸€èˆ¬çš„æœç´¢å¼•æ“éƒ½ä¼šé™åˆ¶è¾“å…¥é•¿åº¦.

æ‰€ä»¥, `ns_index::index` å’Œ `ns_searcher::searcher`ä¸¤ä¸ªç±»ä¸­, å…³äºåˆ†è¯çš„å®ç° å°±éœ€è¦å˜åŒ–ä¸€ä¸‹:

### **`ns_index::index::buildInvertedIndex()`**

```cpp
// å…³äºåˆ†è¯ ä½¿ç”¨ cppjieba ä¸­æ–‡åˆ†è¯åº“
bool buildInvertedIndex(const docInfo_t& doc) {
    // ç”¨æ¥æ˜ å°„å…³é”®å­— å’Œ å…³é”®å­—çš„è¯é¢‘
    std::unordered_map<std::string, keywordCnt_t> keywordsMap;
    ns_util::jiebaUtil* jiebaIns = ns_util::jiebaUtil::getInstance();
    
    // æ ‡é¢˜åˆ†è¯
    std::vector<std::string> titleKeywords;
    jiebaIns->cutStringNoStop(doc._title, &titleKeywords); // å»é™¤åœç”¨è¯åˆ†è¯
    // ns_util::jiebaUtil::cutString(doc._title, &titleKeywords);
    // æ ‡é¢˜è¯é¢‘ç»Ÿè®¡ ä¸ è½¬æ¢ è®°å½•
    for (auto keyword : titleKeywords) {
        boost::to_lower(keyword);		  // å…³é”®å­—è½¬å°å†™
        keywordsMap[keyword]._titleCnt++; // è®°å½•å…³é”®å­— å¹¶ç»Ÿè®¡æ ‡é¢˜ä¸­è¯é¢‘
        // unordered_map çš„ [], æ˜¯ç”¨æ¥é€šè¿‡keywordå€¼ è®¿é—®valueçš„. å¦‚æœkeywordå€¼å·²ç»å­˜åœ¨, åˆ™è¿”å›å¯¹åº”çš„value, å¦‚æœkeywordå€¼ä¸å­˜åœ¨, åˆ™ä¼šæ’å…¥keywordå¹¶åˆ›å»ºå¯¹åº”çš„value
    }

    // å†…å®¹åˆ†è¯
    std::vector<std::string> contentKeywords;
    jiebaIns->cutStringNoStop(doc._content, &contentKeywords); // å»é™¤åœç”¨è¯åˆ†è¯
    // ns_util::jiebaUtil::cutString(doc._content, &contentKeywords);
    // å†…å®¹è¯é¢‘ç»Ÿè®¡ ä¸ è½¬æ¢ è®°å½•
    for (auto keyword : contentKeywords) {
        boost::to_lower(keyword);			// å…³é”®å­—è½¬å°å†™
        keywordsMap[keyword]._contentCnt++; // è®°å½•å…³é”®å­— å¹¶ç»Ÿè®¡å†…å®¹ä¸­è¯é¢‘
    }

    // è¿™ä¸¤ä¸ªconst å˜é‡æ˜¯ç”¨æ¥è®¡ç®— å…³é”®å­—åœ¨æ–‡æ¡£ä¸­çš„æƒé‡çš„.
    // å¹¶ä¸”, å…³é”®å­—å‡ºç°åœ¨æ ‡é¢˜ä¸­  æ–‡æ¡£ä¸å…³é”®å­—çš„ç›¸å…³æ€§å¤§æ¦‚ç‡æ˜¯è¦é«˜çš„, æ‰€ä»¥ å¯ä»¥æŠŠtitleWeight è®¾ç½®çš„å¤§ä¸€äº›
    const int titleWeight = 40;
    const int contentWeight = 1;
    // åˆ†è¯å¹¶ç»Ÿè®¡è¯é¢‘ä¹‹å, keywordsMap ä¸­å·²ç»å­˜å‚¨çš„å½“å‰æ–‡æ¡£çš„æ‰€æœ‰å…³é”®å­—, ä»¥åŠå¯¹åº”çš„åœ¨æ ‡é¢˜ å’Œ å†…å®¹ä¸­ å‡ºç°çš„é¢‘ç‡
    // å°±å¯ä»¥éå† keywordsMap è·å–å…³é”®å­—ä¿¡æ¯, æ„å»º invertedElem å¹¶æ·»åŠ åˆ° invertedIndexä¸­ å…³é”®è¯çš„å€’æ’æ‹‰é“¾ invertedListä¸­äº†
    for (auto& keywordInfo : keywordsMap) {
        invertedElem_t item;
        item._docId = doc._docId;		   // æœ¬æ–‡æ¡£id
        item._keyword = keywordInfo.first; // å…³é”®å­—
        item._weight = keywordInfo.second._titleCnt * titleWeight + keywordInfo.second._contentCnt * contentWeight;

        // ä¸Šé¢æ„å»ºå¥½äº† invertedElem, ä¸‹é¢å°±è¦å°† invertedElem æ·»åŠ åˆ°å¯¹åº”å…³é”®å­—çš„ å€’æ’æ‹‰é“¾ä¸­, æ„å»ºå€’æ’ç´¢å¼•
        invertedList_t& list = invertedIndex[keywordInfo.first]; // è·å–å…³é”®å­—å¯¹åº”çš„å€’æ’æ‹‰é“¾
        list.push_back(std::move(item));
    }

    return true;
}
```

### **`ns_searcher::searcher::search()`**

```cpp
void search(const std::string& query, std::string* jsonString) {
    // 1. å¯¹éœ€è¦æœç´¢çš„å¥å­æˆ–å…³é”®è¯è¿›è¡Œåˆ†è¯
    std::vector<std::string> keywords;
    ns_util::jiebaUtil* jiebaIns = ns_util::jiebaUtil::getInstance();

    jiebaIns->cutString(query, &keywords); // ä¸å»é™¤åœç”¨è¯åˆ†è¯
    // ns_util::jiebaUtil::cutString(query, &keywords);
    
    // ç»Ÿè®¡æ–‡æ¡£ç”¨, å› ä¸ºå¯èƒ½å­˜åœ¨ä¸åŒçš„åˆ†è¯ åœ¨å€’æ’ç´¢å¼•ä¸­æŒ‡å‘åŒä¸€ä¸ªæ–‡æ¡£çš„æƒ…å†µ
    // å¦‚æœä¸å»é‡, ä¼šé‡å¤å±•ç¤º
    std::unordered_map<std::size_t, invertedElemOut_t> invertedElemOutMap;
    // 2. æ ¹æ®åˆ†è¯è·å–å€’æ’ç´¢å¼•ä¸­çš„å€’æ’æ‹‰é“¾, å¹¶æ±‡æ€»å»é‡ invertedElem
    for (std::string word : keywords) {
        boost::to_lower(word);

        ns_index::invertedList_t* tmpInvertedList = _index->getInvertedList(word);
        if (nullptr == tmpInvertedList) {
            // æ²¡æœ‰è¿™ä¸ªå…³é”®è¯
            continue;
        }

        for (auto& elem : *tmpInvertedList) {
            // éå†å€’æ’æ‹‰é“¾, æ ¹æ®æ–‡æ¡£id å¯¹invertedElem å»é‡
            auto& item = invertedElemOutMap[elem._docId]; // åœ¨mapä¸­è·å– æˆ– åˆ›å»ºå¯¹åº”æ–‡æ¡£idçš„ invertedElem
            item._docId = elem._docId;
            item._weight += elem._weight;
            item._keywords.push_back(elem._keyword);
            // æ­¤æ—¶å°±å°†å½“å‰invertedElem å»é‡åˆ°äº† invertedElemMap ä¸­
        }
    }

    // vector å­˜å‚¨ æ–‡æ¡£ç›¸å…³ä¿¡æ¯, æ–¹ä¾¿æ’åº
    std::vector<invertedElemOut_t> allInvertedElemOut;
    // å‡ºå¾ªç¯ä¹‹å, å°±å°†æœç´¢åˆ°çš„ æ–‡æ¡£çš„ idã€æƒé‡å’Œç›¸å…³å…³é”®è¯ å­˜å‚¨åˆ°äº† invertedElemMap
    // ç„¶åå°†æ–‡æ¡£çš„ç›¸å…³ä¿¡æ¯ invertedElemOut éƒ½å­˜å‚¨åˆ° vector ä¸­
    for (const auto& elemOut : invertedElemOutMap) {
        // mapä¸­çš„second: elemOut, åœ¨æ‰§è¡Œæ­¤æ“ä½œä¹‹å, å°±æ²¡ç”¨äº†
        // æ‰€ä»¥ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰, é˜²æ­¢å‘ç”Ÿæ‹·è´
        allInvertedElemOut.push_back(std::move(elemOut.second));
    }

    std::sort(allInvertedElemOut.begin(), allInvertedElemOut.end(),
              [](const invertedElemOut_t& elem1, const invertedElemOut_t& elem2) {
                  return elem1._weight > elem2._weight;
              });

    // ç„¶å é€šè¿‡éå†æ­¤æ•°ç»„, è·å–æ–‡æ¡£id, æ ¹æ®idè·å–æ–‡æ¡£åœ¨æ­£æ’ç´¢å¼•ä¸­çš„å†…å®¹
    // ç„¶åå†å°† æ‰€æœ‰å†…å®¹åºåˆ—åŒ–
    Json::Value root;
    for (auto& elemOut : allInvertedElemOut) {
        // é€šè¿‡Json::Value å¯¹è±¡, å­˜å‚¨æ–‡æ¡£å†…å®¹
        Json::Value elem;
        // é€šè¿‡elemOut._docId è·å–æ­£æ’ç´¢å¼•ä¸­ æ–‡æ¡£çš„å†…å®¹ä¿¡æ¯
        ns_index::docInfo_t* doc = _index->getForwardIndex(elemOut._docId);
        // elemèµ‹å€¼
        elem["url"] = doc->_url;
        elem["title"] = doc->_title;
        // å…³äºæ–‡æ¡£çš„å†…å®¹, æœç´¢ç»“æœä¸­æ˜¯ä¸å±•ç¤ºæ–‡æ¡£çš„å…¨éƒ¨å†…å®¹çš„, åº”è¯¥åªæ˜¾ç¤ºåŒ…å«å…³é”®è¯çš„æ‘˜è¦, ç‚¹è¿›æ–‡æ¡£æ‰æ˜¾ç¤ºç›¸å…³å†…å®¹
        // è€ŒdocInfoä¸­å­˜å‚¨çš„æ˜¯æ–‡æ¡£å»é™¤æ ‡ç­¾ä¹‹åçš„æ‰€æœ‰å†…å®¹, æ‰€ä»¥ä¸èƒ½ç›´æ¥å°† doc._content å­˜å‚¨åˆ°elemå¯¹åº”key:valueä¸­
        elem["desc"] = getDesc(doc->_content, elemOut._keywords[0]); // åªæ ¹æ®ç¬¬ä¸€ä¸ªå…³é”®è¯æ¥è·å–æ‘˜è¦
        // for Debug
        // è¿™é‡Œæœ‰ä¸€ä¸ªbug, jsoncpp 0.10.5.2 æ˜¯ä¸æ”¯æŒlongæˆ–long long ç›¸å…³ç±»å‹çš„, æ‰€ä»¥éœ€è¦è½¬æ¢æˆ double
        // è¿™é‡Œè½¬æ¢æˆ doubleä¸ä¼šæœ‰ä»€ä¹ˆå½±å“, å› ä¸ºè¿™ä¸¤ä¸ªå‚æ•°åªæ˜¯æœ¬åœ°è°ƒè¯•æ˜¾ç¤ºç”¨çš„.
        elem["docId"] = (double)doc->_docId;
        elem["weight"] = (double)elemOut._weight;

        root.append(elem);
    }

    // åºåˆ—åŒ–å®Œæˆä¹‹åå°†ç›¸å…³å†…å®¹å†™å…¥å­—ç¬¦ä¸²
    // for Debug ç”¨ styledWriter
    Json::StyledWriter writer;
    *jsonString = writer.write(root);
}
```

### ç»“æœæ¼”ç¤º

æˆ‘ä»¬é€‰æ‹©çš„è¿™ç§æ–¹å¼, **ä¼šå°†å»ºç«‹ç´¢å¼•çš„æ—¶é•¿æ‹‰çš„å¾ˆé•¿**, æœ€èµ·ç æ¯”ä¹‹å‰è¦é•¿çš„å¤š:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230032658.gif)

ç„¶åå°±å¯ä»¥è¿›è¡Œæœç´¢äº†:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710230034502.gif)

---

# é¡¹ç›®å½“å‰ ç›®å½•ç»“æ„

`Boost`æ–‡æ¡£æœç´¢å¼•æ“åº“è¿™ä¸ªé¡¹ç›®, å½“å‰å·²ç»å®ç°äº†:

1. `parser`æ–‡æ¡£å†…å®¹å¤„ç†æ¨¡å—
2. `index`ç´¢å¼•å»ºç«‹ç›¸å…³æ¥å£
3. `searcher`æœç´¢å®ç°ç›¸å…³æ¥å£

å½“å‰é¡¹ç›®ç›®å½•ç»“æ„ä¸º:

```bash
â¯ pwd
/home/July/gitCode/gitHub/Boost-Doc-Searcher
â¯ tree -L 3
.
â”œâ”€â”€ cppjieba
â”‚Â Â  â”œâ”€â”€ DictTrie.hpp
â”‚Â Â  â”œâ”€â”€ ...(jiebaåº“ç›¸å…³å¤´æ–‡ä»¶)
â”‚Â Â  â””â”€â”€ Unicode.hpp
â”œâ”€â”€ cppjiebaDict
â”‚Â Â  â”œâ”€â”€ hmm_model.utf8
â”‚Â Â  â”œâ”€â”€ ...(jiebaåº“æä¾›çš„åˆ†è¯åº“)
â”‚Â Â  â””â”€â”€ user.dict.utf8
â”œâ”€â”€ data
â”‚Â Â  â”œâ”€â”€ input
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ about.html
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ...(Booståº“æ–‡æ¡£æ–‡ä»¶)
â”‚Â Â  â”‚Â Â  â””â”€â”€ yap.html
â”‚Â Â  â””â”€â”€ output
â”‚Â Â      â””â”€â”€ raw
â”œâ”€â”€ index.hpp
â”œâ”€â”€ LICENSE
â”œâ”€â”€ makefile
â”œâ”€â”€ parser.cc
â”œâ”€â”€ README.md
â”œâ”€â”€ searcher.hpp
â”œâ”€â”€ serverDebug.cc
â””â”€â”€ util.hpp

63 directories, 279 files
```

# ç´¢å¼•æ¥å£ ä»¥åŠ æœç´¢æ¥å£ ç›¸å…³ä»£ç æ•´åˆ

å½“å‰, `util.hpp` `index.hpp` å’Œ `searcher.hpp` çš„ä»£ç :

## **`util.hpp`:**

```cpp
// util.hpp ä¸€èˆ¬å®šä¹‰ä¸€äº›é€šç”¨çš„å®å®šä¹‰ã€å·¥å…·å‡½æ•°ç­‰

#pragma once

#include <boost/algorithm/string/case_conv.hpp>
#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>
#include <fstream>
#include <mutex>
#include <boost/algorithm/string.hpp>
#include "cppjieba/Jieba.hpp"

namespace ns_util {
    class fileUtil {
    public:
        // readFile ç”¨äºè¯»å–æŒ‡å®šæ–‡æœ¬æ–‡ä»¶çš„å†…å®¹, åˆ°stringè¾“å‡ºå‹å‚æ•°ä¸­
        static bool readFile(const std::string& filePath, std::string* out) {
            // è¦è¯»å–æ–‡ä»¶å†…å®¹, å°±è¦å…ˆæ‰“å¼€æ–‡ä»¶
            // 1. ä»¥è¯»å–æ¨¡å¼æ‰“å¼€æ–‡ä»¶
            std::ifstream in(filePath, std::ios::in);
            if (!in.is_open()) {
                // æ‰“å¡æ–‡ä»¶å¤±è´¥
                std::cerr << "Failed to open " << filePath << "!" << std::endl;
                return false;
            }

            // èµ°åˆ°è¿™é‡Œæ‰“å¼€æ–‡ä»¶æˆåŠŸ
            // 2. è¯»å–æ–‡ä»¶å†…, å¹¶å­˜å‚¨åˆ°outä¸­
            std::string line;
            while (std::getline(in, line)) {
                *out += line;
            }

            in.close();

            return true;
        }
    };

    class stringUtil {
    public:
        static bool split(const std::string& file, std::vector<std::string>* fileResult, const std::string& sep) {
            // ä½¿ç”¨ booståº“ä¸­çš„splitæ¥å£, å¯ä»¥å°† string ä»¥æŒ‡å®šçš„åˆ†å‰²ç¬¦åˆ†å‰², å¹¶å­˜å‚¨åˆ°vector<string>è¾“å‡ºå‹å‚æ•°ä¸­
            boost::split(*fileResult, file, boost::is_any_of(sep), boost::algorithm::token_compress_on);
            // boost::algorithm::token_compress_on è¡¨ç¤ºå‹ç¼©è¿ç»­çš„åˆ†å‰²ç¬¦

            if (fileResult->empty()) {
                return false;
            }

            return true;
        }
    };

    const char* const DICT_PATH = "./cppjiebaDict/jieba.dict.utf8";
    const char* const HMM_PATH = "./cppjiebaDict/hmm_model.utf8";
    const char* const USER_DICT_PATH = "./cppjiebaDict/user.dict.utf8";
    const char* const IDF_PATH = "./cppjiebaDict/idf.utf8";
    const char* const STOP_WORD_PATH = "./cppjiebaDict/stop_words.utf8";

    class jiebaUtil {
    private:
        cppjieba::Jieba _jieba;
        std::unordered_map<std::string, bool> _stopKeywordMap;

        jiebaUtil()
            : _jieba(DICT_PATH, HMM_PATH, USER_DICT_PATH, IDF_PATH, STOP_WORD_PATH) {}

        jiebaUtil(const jiebaUtil&) = delete;
        jiebaUtil& operator=(const jiebaUtil&) = delete;

        static jiebaUtil* _instance;

    private:
        void noStopHelper(const std::string& src, std::vector<std::string>* out) {
            _jieba.CutForSearch(src, *out);
            // éå†out æŸ¥è¯¢æ˜¯å¦ä¸ºåœæ­¢è¯ æ˜¯åˆ™åˆ é™¤
            // éœ€è¦æ³¨æ„è¿­ä»£å™¨å¤±æ•ˆçš„é—®é¢˜
            for (auto iter = out->begin(); iter != out->end();) {
                std::string word = *iter;
                boost::to_lower(word);
                auto stopIt = _stopKeywordMap.find(word);
                // auto stopIt = _stopKeywordMap.find(*iter);
                if (stopIt != _stopKeywordMap.end()) {
                    // æ³¨æ„æ¥æ”¶eraseçš„è¿”å›å€¼ é˜²æ­¢å‡ºç°è¿­ä»£å™¨å¤±æ•ˆé—®é¢˜
                    iter = out->erase(iter);
                }
                else {
                    iter++;
                }
            }
        }

        // ä¸»è¦æ˜¯ä¸ºäº†æ”¯æŒ æ¶ˆé™¤åœæ­¢è¯çš„åˆ†è¯
        // ä¹Ÿå°±æ˜¯éœ€è¦å°†åœæ­¢è¯, å†™å…¥åˆ° mapä¸­
        bool initJiebaUtil() {
            // é¦–å…ˆæŒ‰è¡Œè¯»å–æ–‡ä»¶ const char* const STOP_WORD_PATH = "./cppjiebaDict/stop_words.utf8"
            std::ifstream stopFile(STOP_WORD_PATH, std::ios::in);
            if (!stopFile.is_open()) {
                return false;
            }

            std::string line;
            while (std::getline(stopFile, line)) {
                _stopKeywordMap.insert({line, true});
            }

            stopFile.close();

            return true;
        }

    public:
        static jiebaUtil* getInstance() {
            static std::mutex mtx;
            if (nullptr == _instance) {
                mtx.lock();
                if (nullptr == _instance) {
                    _instance = new jiebaUtil;
                    _instance->initJiebaUtil();
                }
                mtx.unlock();
            }

            return _instance;
        }

        // åˆ†è¯: ä¸æ¶ˆé™¤åœæ­¢è¯çš„ç‰ˆæœ¬
        void cutString(const std::string& src, std::vector<std::string>* out) {
            _jieba.CutForSearch(src, *out);
        }
        // åˆ†è¯: æ¶ˆé™¤åœæ­¢è¯çš„ç‰ˆæœ¬
        void cutStringNoStop(const std::string& src, std::vector<std::string>* out) {
            noStopHelper(src, out);
        }
    };
    jiebaUtil* jiebaUtil::_instance;
    // cppjieba::Jieba jiebaUtil::jieba(DICT_PATH, HMM_PATH, USER_DICT_PATH, IDF_PATH, STOP_WORD_PATH);
}
```

## **`index.hpp`:**

```cpp
// æœ¬ä»£ç æ˜¯ å»ºç«‹ç´¢å¼•ç›¸å…³çš„æ¥å£
// ç´¢å¼• æ˜¯ç”¨æ¥å¿«é€Ÿæœç´¢çš„
// parseræ¨¡å—, å·²ç»å°†æ‰€æœ‰æ–‡æ¡£å†…å®¹å¤„ç†å¥½, å¹¶å­˜å‚¨åˆ°äº† data/output/raw ä¸­
// ç´¢å¼•çš„å»ºç«‹, å°±æ˜¯é€šè¿‡è·å– å·²ç»å¤„ç†å¥½çš„æ–‡æ¡£å†…å®¹ æ¥å»ºç«‹çš„
// é¡¹ç›®ä¸­, éœ€è¦åˆ†åˆ«å»ºç«‹æ­£æ’ç´¢å¼•å’Œå€’æ’ç´¢å¼•
// æ­£æ’ç´¢å¼•, æ˜¯ä»æ–‡æ¡£id æ‰¾åˆ°æ–‡ä»¶å†…å®¹çš„ç´¢å¼•
// å€’æ’ç´¢å¼•, æ˜¯ä»å…³é”®è¯ æ‰¾åˆ°å…³é”®è¯æ‰€åœ¨æ–‡æ¡£id çš„ç´¢å¼•

// é¦–å…ˆç¬¬ä¸€ä¸ªé—®é¢˜:
// æ­£æ’ç´¢å¼•ä¸­ æ–‡ä»¶å†…å®¹è¯¥å¦‚ä½•è¡¨ç¤º?
// å…¶å®åœ¨parseræ¨¡å—ä¸­, å·²ç»æœ‰è¿‡ç›¸å…³çš„å¤„ç†äº†, å³ç”¨ç»“æ„ä½“(docInfo) æˆå‘˜ä¸º: titleã€contentã€url
// ä¸è¿‡, åœ¨å»ºç«‹ç´¢å¼•æ—¶, æ–‡æ¡£åœ¨ç´¢å¼•ä¸­ åº”è¯¥å­˜åœ¨ä¸€ä¸ªæ–‡æ¡£id.

// æ­£æ’ç´¢å¼•ç»“æ„
// æ­£æ’ç´¢å¼• å¯ä»¥é€šè¿‡æ–‡æ¡£idæ‰¾åˆ°æ–‡ä»¶å†…å®¹. é‚£ä¹ˆ æ­£æ’ç´¢å¼•å¯ä»¥ç”¨ vector å»ºç«‹, vector å­˜å‚¨docInfoç»“æ„ä½“ é‚£ä¹ˆæ•°ç»„ä¸‹æ ‡å°±å¤©ç„¶æ˜¯ æ–‡æ¡£id

// å€’æ’ç´¢å¼•ç»“æ„
// å€’æ’ç´¢å¼• éœ€è¦é€šè¿‡å…³é”®å­— æ‰¾åˆ°åŒ…å«å…³é”®å­—çš„æ–‡æ¡£id, æ–‡æ¡£id å¯¹åº”æ­£æ’ç´¢å¼•ä¸­çš„ä¸‹æ ‡, æ‰€ä»¥éœ€è¦å…ˆå»ºç«‹æ­£æ’ç´¢å¼•, å†å»ºç«‹å€’æ’ç´¢å¼•
// ç”±äºå¯èƒ½å¤šä¸ªæ–‡æ¡£åŒ…å«ç›¸åŒçš„å…³é”®å­—, å€’æ’ç´¢å¼•æ›´é€‚åˆ keyword:value ç»“æ„å­˜å‚¨. æ‰€ä»¥ å¯ä»¥ä½¿ç”¨ unordered_map
// å¹¶ä¸”, åŒæ ·å› ä¸ºå…³é”®å­—å¯èƒ½æ‰¾åˆ°å¤šä¸ªæ–‡æ¡£, valueçš„ç±»å‹å°± å¯ä»¥æ˜¯å­˜å‚¨ç€æ–‡æ¡£idçš„vector, ç§°ä¸ºå€’æ’æ‹‰é“¾

// å€’æ’ç´¢å¼•ä¸­, é€šè¿‡å…³é”®å­—æ‰¾åˆ°çš„ å€’æ’æ‹‰é“¾ä¸­ ä¸åº”è¯¥ä»…ä»…æ˜¯æ–‡æ¡£idçš„æ•°æ®.
// å› ä¸ºå€’æ’ç´¢å¼•çš„æŸ¥æ‰¾ç»“æœæ˜¯å…³ä¹åˆ°æŸ¥æ‰¾ç»“æœçš„æ˜¾ç¤ºé¡ºåºçš„. æ‰€ä»¥ è¿˜éœ€è¦çŸ¥é“å¯¹åº”æ–‡æ¡£id åœ¨æœ¬æ¬¡æœç´¢çš„æƒé‡.
// æ‰€ä»¥, æœ€å¥½å°†æ–‡æ¡£idå’Œæƒé‡ç»“åˆèµ·æ¥, æ„æˆä¸€ä¸ªç»“æ„ä½“(invertedElem)å­˜å‚¨.
// ä¸è¿‡, ä¸éœ€è¦ å…ˆå°†æ‰€æœ‰æ–‡æ¡£çš„æ­£æ’ç´¢å¼•å»ºç«‹å®Œæˆä¹‹å å†å»ºç«‹å€’æ’ç´¢å¼•. å¯ä»¥å…ˆç»™ æŸæ–‡æ¡£å»ºç«‹æ­£æ’ç´¢å¼•ä¹‹å, ç›´æ¥å¯¹æ­¤æ–‡æ¡£å»ºç«‹å€’æ’ç´¢å¼•

#pragma once

#include <iostream>
#include <fstream>
#include <utility>
#include <vector>
#include <string>
#include <unordered_map>
#include <mutex>
#include "util.hpp"

namespace ns_index {

    // ç”¨äºæ­£æ’ç´¢å¼•ä¸­ å­˜å‚¨æ–‡æ¡£å†…å®¹
    typedef struct docInfo {
        std::string _title;   // æ–‡æ¡£æ ‡é¢˜
        std::string _content; // æ–‡æ¡£å»æ ‡ç­¾ä¹‹åçš„å†…å®¹
        std::string _url;     // æ–‡æ¡£å¯¹åº”å®˜ç½‘url
        std::size_t _docId;   // æ–‡æ¡£id
    } docInfo_t;

    // ç”¨äºå€’æ’ç´¢å¼•ä¸­ è®°å½•å…³é”®å­—å¯¹åº”çš„æ–‡æ¡£idå’Œæƒé‡
    typedef struct invertedElem {
        std::size_t _docId;    // æ–‡æ¡£id
        std::string _keyword;  // å…³é”®å­—
        std::uint64_t _weight; // æœç´¢æ­¤å…³é”®å­—, æ­¤æ–‡æ¡£id æ‰€å æƒé‡

        invertedElem() // æƒé‡åˆå§‹åŒ–ä¸º0
            : _weight(0) {}
    } invertedElem_t;

    // å…³é”®å­—çš„è¯é¢‘
    typedef struct keywordCnt {
        std::size_t _titleCnt;   // å…³é”®å­—åœ¨æ ‡é¢˜ä¸­å‡ºç°çš„æ¬¡æ•°
        std::size_t _contentCnt; // å…³é”®å­—åœ¨å†…å®¹ä¸­å‡ºç°çš„æ¬¡æ•°

        keywordCnt()
            : _titleCnt(0)
            , _contentCnt(0) {}
    } keywordCnt_t;

    // å€’æ’æ‹‰é“¾
    typedef std::vector<invertedElem_t> invertedList_t;

    class index {
    private:
        // æ­£æ’ç´¢å¼•ä½¿ç”¨vector, ä¸‹æ ‡å¤©ç„¶æ˜¯ æ–‡æ¡£id
        std::vector<docInfo_t> forwardIndex;
        // å€’æ’ç´¢å¼• ä½¿ç”¨ å“ˆå¸Œè¡¨, å› ä¸ºå€’æ’ç´¢å¼• ä¸€å®šæ˜¯ ä¸€ä¸ªkeyword å¯¹åº”ä¸€ç»„ invertedElemæ‹‰é“¾
        std::unordered_map<std::string, invertedList_t> invertedIndex;

        // å•ä¾‹æ¨¡å¼è®¾è®¡
        index() {}

        index(const index&) = delete;
        index& operator=(const index&) = delete;

        static index* _instance; // å•ä¾‹
        static std::mutex _mtx;

    public:
        // è·å–å•ä¾‹
        static index* getInstance() {
            if (nullptr == _instance) {
                _mtx.lock();
                if (nullptr == _instance) {
                    _instance = new index;
                }
                _mtx.unlock();
            }

            return _instance;
        }

        // é€šè¿‡å…³é”®å­— æ£€ç´¢å€’æ’ç´¢å¼•, è·å–å¯¹åº”çš„ å€’æ’æ‹‰é“¾
        invertedList_t* getInvertedList(const std::string& keyword) {
            // å…ˆæ‰¾ å…³é”®å­— æ‰€åœ¨è¿­ä»£å™¨
            auto iter = invertedIndex.find(keyword);
            if (iter == invertedIndex.end()) {
                std::cerr << keyword << " have no invertedList!" << std::endl;
                return nullptr;
            }

            // æ‰¾åˆ°ä¹‹å
            return &(iter->second);
        }

        // é€šè¿‡å€’æ’æ‹‰é“¾ä¸­ æ¯ä¸ªå€’æ’å…ƒç´ ä¸­å­˜å‚¨çš„ æ–‡æ¡£id, æ£€ç´¢æ­£æ’ç´¢å¼•, è·å–å¯¹åº”æ–‡æ¡£å†…å®¹
        docInfo_t* getForwardIndex(std::size_t docId) {
            if (docId >= forwardIndex.size()) {
                std::cerr << "docId out range, error!" << std::endl;
                return nullptr;
            }

            return &forwardIndex[docId];
        }

        // æ ¹æ®parseræ¨¡å—å¤„ç†è¿‡çš„ æ‰€æœ‰æ–‡æ¡£çš„ä¿¡æ¯
        // æå–æ–‡æ¡£ä¿¡æ¯, å»ºç«‹ æ­£æ’ç´¢å¼•å’Œå€’æ’ç´¢å¼•
        // input ä¸º ./data/output/raw
        bool buildIndex(const std::string& input) {
            // å…ˆä»¥è¯»å–æ–¹å¼æ‰“å¼€æ–‡ä»¶
            std::ifstream in(input, std::ios::in);
            if (!in.is_open()) {
                std::cerr << "Failed to open " << input << std::endl;
                return false;
            }

            std::size_t count = 0;

            std::string line;
            while (std::getline(in, line)) {
                // æŒ‰ç…§parseræ¨¡å—çš„å¤„ç†, getline ä¸€æ¬¡è¯»å–åˆ°çš„æ•°æ®, å°±æ˜¯ä¸€ä¸ªæ–‡æ¡£çš„: title\3content\3url\n
                docInfo_t* doc = buildForwardIndex(line); // å°†ä¸€ä¸ªæ–‡æ¡£çš„æ•°æ® å»ºç«‹åˆ°ç´¢å¼•ä¸­
                if (nullptr == doc) {
                    std::cerr << "Failed to buildForwardIndex for " << line << std::endl;
                    continue;
                }

                // æ–‡æ¡£å»ºç«‹æ­£æ’ç´¢å¼•æˆåŠŸ, æ¥ç€å°±é€šè¿‡ doc å»ºç«‹å€’æ’ç´¢å¼•
                if (!buildInvertedIndex(*doc)) {
                    std::cerr << "Failed to buildInvertedIndex for " << line << std::endl;
                    continue;
                }

                count++;
                if (count % 50 == 0)
                    std::cout << "å½“å‰å·²ç»å»ºç«‹çš„ç´¢å¼•æ–‡æ¡£: " << count << std::endl;
            }

            return true;
        }

    private:
        // å¯¹ä¸€ä¸ªæ–‡æ¡£å»ºç«‹æ­£æ’ç´¢å¼•
        docInfo_t* buildForwardIndex(const std::string& file) {
            // ä¸€ä¸ªæ–‡æ¡£çš„ æ­£æ’ç´¢å¼•çš„å»ºç«‹, æ˜¯å°† title\3content\3url (file) ä¸­title content url æå–å‡ºæ¥
            // æ„æˆä¸€ä¸ª docInfo_t doc
            // ç„¶åå°† doc å­˜å‚¨åˆ°æ­£æ’ç´¢å¼•vectorä¸­
            std::vector<std::string> fileResult;
            const std::string sep("\3");
            // stringUtil::split() å­—ç¬¦ä¸²é€šç”¨å·¥å…·æ¥å£, åˆ†å‰²å­—ç¬¦ä¸²
            ns_util::stringUtil::split(file, &fileResult, sep);

            docInfo_t doc;
            doc._title = fileResult[0];
            doc._content = fileResult[1];
            doc._url = fileResult[2];

            // å› ä¸ºdocæ˜¯éœ€è¦å­˜å‚¨åˆ° forwardIndexä¸­çš„, å­˜å‚¨ä¹‹å‰ forwardIndexçš„size å°±æ˜¯å­˜å‚¨ä¹‹å docæ‰€åœ¨çš„ä½ç½®
            doc._docId = forwardIndex.size();

            forwardIndex.push_back(std::move(doc));

            return &forwardIndex.back();
        }

        // å¯¹ä¸€ä¸ªæ–‡æ¡£å»ºç«‹å€’æ’ç´¢å¼•
        // å€’æ’ç´¢å¼•æ˜¯ç”¨æ¥é€šè¿‡å…³é”®è¯å®šä½æ–‡æ¡£çš„.
        // å€’æ’ç´¢å¼•çš„ç»“æ„æ˜¯ std::unordered_map<std::string, invertedList_t> invertedIndex;
        // keywordå€¼å°±æ˜¯å…³é”®å­—, valueå€¼åˆ™æ˜¯å…³é”®å­—æ‰€æ˜ å°„åˆ°çš„æ–‡æ¡£çš„å€’æ’æ‹‰é“¾
        // å¯¹ä¸€ä¸ªæ–‡æ¡£å»ºç«‹å€’æ’ç´¢å¼•çš„åŸç†æ˜¯:
        //  1. é¦–å…ˆå¯¹æ–‡æ¡£çš„æ ‡é¢˜ å’Œ å†…å®¹è¿›è¡Œåˆ†è¯, å¹¶è®°å½•åˆ†è¯
        //  2. åˆ†åˆ«ç»Ÿè®¡æ•´ç†æ ‡é¢˜åˆ†æçš„è¯é¢‘ å’Œ å†…å®¹åˆ†è¯çš„è¯é¢‘
        //     ç»Ÿè®¡è¯é¢‘æ˜¯ä¸ºäº†å¯ä»¥å¤§æ¦‚è¡¨ç¤ºå…³é”®å­—åœ¨æ–‡æ¡£ä¸­çš„ ç›¸å…³æ€§.
        //     åœ¨æœ¬é¡¹ç›®ä¸­, å¯ä»¥ç®€å•çš„è®¤ä¸ºå…³é”®è¯åœ¨æ–‡æ¡£ä¸­å‡ºç°çš„é¢‘ç‡, ä»£è¡¨äº†æ­¤æ–‡æ¡£å†…å®¹ä¸å…³é”®è¯çš„ç›¸å…³æ€§. å½“ç„¶è¿™æ˜¯éå¸¸è‚¤æµ…çš„è”ç³», ä¸€èˆ¬æ¥è¯´ç›¸å…³æ€§çš„åˆ¤æ–­éƒ½æ˜¯éå¸¸å¤æ‚çš„. å› ä¸ºæ¶‰åŠåˆ°è¯ä¹‰ è¯­ä¹‰ç­‰ç›¸å…³åˆ†æ.
        //     æ¯ä¸ªå…³é”®å­— åœ¨æ ‡é¢˜ä¸­å‡ºç°çš„é¢‘ç‡ å’Œ åœ¨å†…å®¹ä¸­å‡ºç°çš„é¢‘ç‡, å¯ä»¥è®°å½•åœ¨ä¸€ä¸ªç»“æ„ä½“ä¸­. æ­¤ç»“æ„ä½“å°±è¡¨ç¤ºå…³é”®å­—çš„è¯é¢‘
        //  3. ä½¿ç”¨ unordered_map<std::string, wordCnt_t> è®°å½•å…³é”®å­—ä¸å…¶è¯é¢‘
        //  4. é€šè¿‡éå†è®°å½•å…³é”®å­—ä¸è¯é¢‘çš„ unordered_map, æ„å»º invertedElem: _docId, _keyword, _weight
        //  5. æ„å»ºäº†å…³é”®å­—çš„invertedElem ä¹‹å, å†å°†å…³é”®è¯çš„invertedElem æ·»åŠ åˆ°åœ¨ invertedIndexä¸­ å…³é”®è¯çš„å€’æ’æ‹‰é“¾ invertedListä¸­
        // æ³¨æ„, æœç´¢å¼•æ“ä¸€èˆ¬ä¸åŒºåˆ†å¤§å°å†™, æ‰€ä»¥å¯ä»¥å°†åˆ†è¯å‡ºæ¥çš„æ‰€æœ‰çš„å…³é”®å­—, åœ¨å€’æ’ç´¢å¼•ä¸­å‡ä»¥å°å†™çš„å½¢å¼æ˜ å°„. åœ¨æœç´¢æ—¶ åŒæ ·å°†æœç´¢è¯·æ±‚åˆ†è¯å‡ºçš„å…³é”®å­—å° å†™åŒ–, åœ¨è¿›è¡Œæ£€ç´¢. å°±å¯ä»¥å®ç°æœç´¢ä¸åŒºåˆ†å¤§å°å†™.

        // å…³äºåˆ†è¯ ä½¿ç”¨ cppjieba ä¸­æ–‡åˆ†è¯åº“
        bool buildInvertedIndex(const docInfo_t& doc) {
            // ç”¨æ¥æ˜ å°„å…³é”®å­— å’Œ å…³é”®å­—çš„è¯é¢‘
            std::unordered_map<std::string, keywordCnt_t> keywordsMap;
            ns_util::jiebaUtil* jiebaIns = ns_util::jiebaUtil::getInstance();

            // æ ‡é¢˜åˆ†è¯
            std::vector<std::string> titleKeywords;
            jiebaIns->cutStringNoStop(doc._title, &titleKeywords);
            // jiebaIns->cutString(doc._title, &titleKeywords);
            // æ ‡é¢˜è¯é¢‘ç»Ÿè®¡ ä¸ è½¬æ¢ è®°å½•
            for (auto keyword : titleKeywords) {
                boost::to_lower(keyword);         // å…³é”®å­—è½¬å°å†™
                keywordsMap[keyword]._titleCnt++; // è®°å½•å…³é”®å­— å¹¶ç»Ÿè®¡æ ‡é¢˜ä¸­è¯é¢‘
                                                  // unordered_map çš„ [], æ˜¯ç”¨æ¥é€šè¿‡keywordå€¼ è®¿é—®valueçš„. å¦‚æœkeywordå€¼å·²ç»å­˜åœ¨, åˆ™è¿”å›å¯¹åº”çš„value, å¦‚æœkeywordå€¼ä¸å­˜åœ¨, åˆ™ä¼šæ’å…¥keywordå¹¶åˆ›å»ºå¯¹åº”çš„value
            }

            // å†…å®¹åˆ†è¯
            std::vector<std::string> contentKeywords;
            jiebaIns->cutStringNoStop(doc._content, &contentKeywords);
            // jiebaIns->cutString(doc._content, &contentKeywords);
            // å†…å®¹è¯é¢‘ç»Ÿè®¡ ä¸ è½¬æ¢ è®°å½•
            for (auto keyword : contentKeywords) {
                boost::to_lower(keyword);           // å…³é”®å­—è½¬å°å†™
                keywordsMap[keyword]._contentCnt++; // è®°å½•å…³é”®å­— å¹¶ç»Ÿè®¡å†…å®¹ä¸­è¯é¢‘
            }

            // è¿™ä¸¤ä¸ªconst å˜é‡æ˜¯ç”¨æ¥è®¡ç®— å…³é”®å­—åœ¨æ–‡æ¡£ä¸­çš„æƒé‡çš„.
            // å¹¶ä¸”, å…³é”®å­—å‡ºç°åœ¨æ ‡é¢˜ä¸­  æ–‡æ¡£ä¸å…³é”®å­—çš„ç›¸å…³æ€§å¤§æ¦‚ç‡æ˜¯è¦é«˜çš„, æ‰€ä»¥ å¯ä»¥æŠŠtitleWeight è®¾ç½®çš„å¤§ä¸€äº›
            const int titleWeight = 40;
            const int contentWeight = 1;
            // åˆ†è¯å¹¶ç»Ÿè®¡è¯é¢‘ä¹‹å, keywordsMap ä¸­å·²ç»å­˜å‚¨çš„å½“å‰æ–‡æ¡£çš„æ‰€æœ‰å…³é”®å­—, ä»¥åŠå¯¹åº”çš„åœ¨æ ‡é¢˜ å’Œ å†…å®¹ä¸­ å‡ºç°çš„é¢‘ç‡
            // å°±å¯ä»¥éå† keywordsMap è·å–å…³é”®å­—ä¿¡æ¯, æ„å»º invertedElem å¹¶æ·»åŠ åˆ° invertedIndexä¸­ å…³é”®è¯çš„å€’æ’æ‹‰é“¾ invertedListä¸­äº†
            for (auto& keywordInfo : keywordsMap) {
                invertedElem_t item;
                item._docId = doc._docId;          // æœ¬æ–‡æ¡£id
                item._keyword = keywordInfo.first; // å…³é”®å­—
                item._weight = keywordInfo.second._titleCnt * titleWeight + keywordInfo.second._contentCnt * contentWeight;

                // ä¸Šé¢æ„å»ºå¥½äº† invertedElem, ä¸‹é¢å°±è¦å°† invertedElem æ·»åŠ åˆ°å¯¹åº”å…³é”®å­—çš„ å€’æ’æ‹‰é“¾ä¸­, æ„å»ºå€’æ’ç´¢å¼•
                invertedList_t& list = invertedIndex[keywordInfo.first]; // è·å–å…³é”®å­—å¯¹åº”çš„å€’æ’æ‹‰é“¾
                list.push_back(std::move(item));
            }

            return true;
        }
    };
    // å•ä¾‹ç›¸å…³
    index* index::_instance = nullptr;
    std::mutex index::_mtx;
}
```

## **`searcher.hpp`:**

```cpp
// æœ¬æ–‡ä»¶å®ç° æœç´¢ç›¸å…³æ¥å£

// æœ¬é¡¹ç›®ä¸­çš„æœç´¢, æ˜¯æ ¹æ®è¾“å…¥çš„å…³é”®è¯:
//  1. å…ˆå¯¹å…³é”®è¯è¿›è¡Œåˆ†è¯
//  2. ç„¶åé€šè¿‡åˆ†è¯, åœ¨å€’æ’ç´¢å¼•ä¸­è¿›è¡Œæ£€ç´¢, æ£€ç´¢åˆ°ç›¸å…³çš„å€’æ’æ‹‰é“¾
//  3. ç„¶åå†é€šè¿‡å€’æ’æ‹‰é“¾ä¸­ å€’æ’å…ƒç´ çš„å¯¹åº”æ–‡æ¡£id, åœ¨æ­£æ’ç´¢å¼•ä¸­è·å–æ–‡ä»¶å†…å®¹

// ä¸è¿‡åœ¨æ­£å¼å¼€å§‹æœç´¢ä¹‹å‰, è¦å…ˆæ„å»ºç´¢å¼•
// è€Œç´¢å¼•çš„æ„å»º, åœ¨æ•´ä¸ªç¨‹åºä¸­åªéœ€è¦æ„å»ºä¸€æ¬¡, æ‰€ä»¥å¯ä»¥å°†ç´¢å¼•è®¾è®¡ä¸ºå•ä¾‹æ¨¡å¼
#pragma once

#include <algorithm>
#include <cctype>
#include <iostream>
#include <iterator>
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <boost/algorithm/string.hpp>
#include <jsoncpp/json/json.h>
#include "util.hpp"
#include "index.hpp"

namespace ns_searcher {
    typedef struct invertedElemOut {
        std::size_t _docId;
        std::uint64_t _weight;
        std::vector<std::string> _keywords;
    } invertedElemOut_t;

    class searcher {
    private:
        ns_index::index* _index; // å»ºç«‹ç´¢å¼•çš„ç±»

        ns_util::jiebaUtil* _jiebaIns;

    public:
        void initSearcher(const std::string& input) {
            // æœç´¢å‰çš„åˆå§‹åŒ–æ“ä½œ
            // è·å–å•ä¾‹
            _index = ns_index::index::getInstance();
            _jiebaIns = ns_util::jiebaUtil::getInstance();

            std::cout << "è·å–å•ä¾‹æˆåŠŸ ..." << std::endl;
            // å»ºç«‹ç´¢å¼•
            _index->buildIndex(input);
            std::cout << "æ„å»ºæ­£æ’ç´¢å¼•ã€å€’æ’ç´¢å¼•æˆåŠŸ ..." << std::endl;
        }

        // æœç´¢æ¥å£
        // æœç´¢éœ€è¦å®ç°ä»€ä¹ˆåŠŸèƒ½?
        // é¦–å…ˆå‚æ•°éƒ¨åˆ†éœ€è¦æ€ä¹ˆå®ç°?
        // å‚æ•°éƒ¨åˆ†, éœ€è¦æ¥æ”¶éœ€è¦æœç´¢çš„å¥å­æˆ–å…³é”®å­—, è¿˜éœ€è¦ä¸€ä¸ªè¾“å‡ºå‹å‚æ•° ç”¨äºè¾“å‡ºæŸ¥æ‰¾ç»“æœ
        //  æŸ¥æ‰¾ç»“æœæˆ‘ä»¬ä½¿ç”¨jsoncppè¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–
        // search() å…·ä½“éœ€è¦å®ç°çš„åŠŸèƒ½:
        //  1. å¯¹æ¥æ”¶çš„å¥å­æˆ–å…³é”®è¯è¿›è¡Œåˆ†è¯
        //  2. æ ¹æ®åˆ†è¯, åœ¨å€’æ’ç´¢å¼•ä¸­æŸ¥æ‰¾åˆ°æ‰€æœ‰åˆ†è¯çš„å€’æ’æ‹‰é“¾ æ±‡æ€» çš„ invertedElem, å¹¶æ ¹æ®ç›¸å…³æ€§è¿›è¡Œæ’åº
        //  4. ç„¶åå†éå†æ‰€æœ‰çš„ invertedElem, æ ¹æ® invertedElemä¸­å­˜å‚¨çš„ æ–‡æ¡£id, åœ¨æ­£æ’ç´¢å¼•ä¸­è·å–åˆ°æ–‡æ¡£å†…å®¹
        //  5. ç„¶åå°†è·å–åˆ°çš„æ–‡æ¡£å†…å®¹ä½¿ç”¨jsoncpp è¿›è¡Œåºåˆ—åŒ–, å­˜å‚¨åˆ°è¾“å‡ºå‹å‚æ•°ä¸­
        // ç›´åˆ°éå†å®ŒinvertedElem
        void search(const std::string& query, std::string* jsonString) {
            // 1. å¯¹éœ€è¦æœç´¢çš„å¥å­æˆ–å…³é”®è¯è¿›è¡Œåˆ†è¯
            std::vector<std::string> keywords;

            _jiebaIns->cutString(query, &keywords);
            // _jiebaIns->cutStringNoStop(query, &keywords);
            // ns_util::jiebaUtil::cutString(query, &keywords);

            // std::vector<invertedElemOut_t> allInvertedElemOut;
            // std::vector<ns_index::invertedElem_t> allInvertedElem;

            // ç»Ÿè®¡æ–‡æ¡£ç”¨, å› ä¸ºå¯èƒ½å­˜åœ¨ä¸åŒçš„åˆ†è¯ åœ¨å€’æ’ç´¢å¼•ä¸­æŒ‡å‘åŒä¸€ä¸ªæ–‡æ¡£çš„æƒ…å†µ
            // å¦‚æœä¸å»é‡, ä¼šé‡å¤å±•ç¤º
            // std::unordered_map<std::size_t, ns_index::invertedElem_t> invertedElemMap;
            std::unordered_map<std::size_t, invertedElemOut_t> invertedElemOutMap;
            // 2. æ ¹æ®åˆ†è¯è·å–å€’æ’ç´¢å¼•ä¸­çš„å€’æ’æ‹‰é“¾, å¹¶æ±‡æ€»å»é‡ invertedElem
            for (std::string word : keywords) {
                boost::to_lower(word);

                ns_index::invertedList_t* tmpInvertedList = _index->getInvertedList(word);
                if (nullptr == tmpInvertedList) {
                    // æ²¡æœ‰è¿™ä¸ªå…³é”®è¯
                    continue;
                }

                for (auto& elem : *tmpInvertedList) {
                    // éå†å€’æ’æ‹‰é“¾, æ ¹æ®æ–‡æ¡£id å¯¹invertedElem å»é‡
                    auto& item = invertedElemOutMap[elem._docId]; // åœ¨mapä¸­è·å– æˆ– åˆ›å»ºå¯¹åº”æ–‡æ¡£idçš„ invertedElem
                    item._docId = elem._docId;
                    item._weight += elem._weight;
                    // æƒé‡éœ€è¦+= æ˜¯å› ä¸ºå¤šä¸ªå…³é”®è¯æŒ‡å‘äº†åŒä¸€ä¸ªæ–‡æ¡£ é‚£ä¹ˆå°±è¯´æ˜æ­¤æ–‡æ¡£çš„ä¸æœç´¢å†…å®¹çš„ç›¸å…³æ€§æ›´é«˜
                    // æ‰€ä»¥, å°±å¯ä»¥å°†å¤šä¸ªå…³é”®å­—å…³äºæ­¤æ–‡æ¡£çš„æƒé‡ç›¸åŠ , è¡¨ç¤ºæœç´¢ç›¸å…³æ€§é«˜
                    // æœ€å¥½è¿˜å°† æ­¤æ–‡æ¡£ç›¸å…³çš„å…³é”®è¯ ä¹Ÿå­˜å‚¨èµ·æ¥, å› ä¸ºåœ¨å®¢æˆ·ç«¯æœç´¢ç»“æœä¸­, éœ€è¦å¯¹ç½‘é¡µä¸­æœ‰çš„å…³é”®å­—è¿›è¡Œé«˜äº®
                    // ä½†æ˜¯ invertedElem çš„ç¬¬ä¸‰ä¸ªæˆå‘˜æ˜¯ å•ç‹¬çš„ä¸€ä¸ªstringå¯¹è±¡, ä¸å¤ªåˆé€‚
                    // æ‰€ä»¥, å¯ä»¥å®šä¹‰ä¸€ä¸ªä¸invertedElem ç›¸ä¼¼çš„, ä½†æ˜¯ç¬¬ä¸‰ä¸ªæˆå‘˜æ˜¯ä¸€ä¸ª vector çš„ç±», æ¯”å¦‚ invertedElemOut
                    item._keywords.push_back(elem._keyword);
                    // æ­¤æ—¶å°±å°†å½“å‰invertedElem å»é‡åˆ°äº† invertedElemMap ä¸­
                }
            }

            // vector å­˜å‚¨ æ–‡æ¡£ç›¸å…³ä¿¡æ¯, æ–¹ä¾¿æ’åº
            std::vector<invertedElemOut_t> allInvertedElemOut;
            // å‡ºå¾ªç¯ä¹‹å, å°±å°†æœç´¢åˆ°çš„ æ–‡æ¡£çš„ idã€æƒé‡å’Œç›¸å…³å…³é”®è¯ å­˜å‚¨åˆ°äº† invertedElemMap
            // ç„¶åå°†æ–‡æ¡£çš„ç›¸å…³ä¿¡æ¯ invertedElemOut éƒ½å­˜å‚¨åˆ° vector ä¸­
            for (const auto& elemOut : invertedElemOutMap) {
                // mapä¸­çš„second: elemOut, åœ¨æ‰§è¡Œæ­¤æ“ä½œä¹‹å, å°±æ²¡ç”¨äº†
                // æ‰€ä»¥ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰, é˜²æ­¢å‘ç”Ÿæ‹·è´
                allInvertedElemOut.push_back(std::move(elemOut.second));
            }

            // æ‰§è¡Œåˆ°è¿™é‡Œ, å¯ä»¥æœç´¢åˆ°çš„æ–‡æ¡£id æƒé‡ å’Œ ç›¸å…³å…³é”®è¯çš„ä¿¡æ¯, å·²ç»éƒ½åœ¨allInvertedElemOut ä¸­äº†.
            // ä½†æ˜¯, è¿˜ä¸èƒ½ç›´æ¥ æ ¹æ®æ–‡æ¡£id åœ¨æ­£æ’ç´¢å¼•ä¸­æ£€ç´¢
            // å› ä¸º, æ­¤æ—¶å¦‚æœç›´æ¥è¿›è¡Œæ–‡æ¡£å†…å®¹çš„ç´¢å¼•, åœ¨æ‰¾åˆ°æ–‡æ¡£å†…å®¹ä¹‹å, å°±è¦ç›´æ¥è¿›è¡Œåºåˆ—åŒ–å¹¶è¾“å‡ºäº†. è€Œå®¢æˆ·ç«¯æ˜¾ç¤ºçš„æ—¶å€™, ååºåˆ—åŒ–å‡ºæ¥çš„æ–‡æ¡£é¡ºåº, å°±æ˜¯æ˜¾ç¤ºçš„æ–‡æ¡£é¡ºåº
            // ä½†æ˜¯ç°åœ¨æ‰¾åˆ°çš„æ–‡æ¡£è¿˜æ˜¯ä¹±åºçš„. è¿˜éœ€è¦å°†allInvertedElemOutä¸­çš„ç›¸å…³æ–‡æ¡£, é€šè¿‡_weight è¿›è¡Œå€’åºæ’åˆ—
            // è¿™æ ·, åºåˆ—åŒ–å°±æ˜¯æŒ‰ç…§å€’åºæ’åˆ—çš„, ååºåˆ—åŒ–ä¹Ÿä¼šå¦‚æ­¤, æ˜¾ç¤ºåŒæ ·å¦‚æ­¤
            std::sort(allInvertedElemOut.begin(), allInvertedElemOut.end(),
                      [](const invertedElemOut_t& elem1, const invertedElemOut_t& elem2) {
                          return elem1._weight > elem2._weight;
                      });

            // æ’åºä¹‹å, allInvertedElemOut ä¸­æ–‡æ¡£çš„æ’åºå°±æ˜¯å€’åºäº†
            // ç„¶å é€šè¿‡éå†æ­¤æ•°ç»„, è·å–æ–‡æ¡£id, æ ¹æ®idè·å–æ–‡æ¡£åœ¨æ­£æ’ç´¢å¼•ä¸­çš„å†…å®¹
            // ç„¶åå†å°† æ‰€æœ‰å†…å®¹åºåˆ—åŒ–
            Json::Value root;
            for (auto& elemOut : allInvertedElemOut) {
                // é€šè¿‡Json::Value å¯¹è±¡, å­˜å‚¨æ–‡æ¡£å†…å®¹
                Json::Value elem;
                // é€šè¿‡elemOut._docId è·å–æ­£æ’ç´¢å¼•ä¸­ æ–‡æ¡£çš„å†…å®¹ä¿¡æ¯
                ns_index::docInfo_t* doc = _index->getForwardIndex(elemOut._docId);
                // elemèµ‹å€¼
                elem["url"] = doc->_url;
                elem["title"] = doc->_title;
                // å…³äºæ–‡æ¡£çš„å†…å®¹, æœç´¢ç»“æœä¸­æ˜¯ä¸å±•ç¤ºæ–‡æ¡£çš„å…¨éƒ¨å†…å®¹çš„, åº”è¯¥åªæ˜¾ç¤ºåŒ…å«å…³é”®è¯çš„æ‘˜è¦, ç‚¹è¿›æ–‡æ¡£æ‰æ˜¾ç¤ºç›¸å…³å†…å®¹
                // è€ŒdocInfoä¸­å­˜å‚¨çš„æ˜¯æ–‡æ¡£å»é™¤æ ‡ç­¾ä¹‹åçš„æ‰€æœ‰å†…å®¹, æ‰€ä»¥ä¸èƒ½ç›´æ¥å°† doc._content å­˜å‚¨åˆ°elemå¯¹åº”key:valueä¸­
                elem["desc"] = getDesc(doc->_content, elemOut._keywords[0]); // åªæ ¹æ®ç¬¬ä¸€ä¸ªå…³é”®è¯æ¥è·å–æ‘˜è¦
                // for Debug
                // è¿™é‡Œæœ‰ä¸€ä¸ªbug, jsoncpp 0.10.5.2 æ˜¯ä¸æ”¯æŒlongæˆ–long long ç›¸å…³ç±»å‹çš„, æ‰€ä»¥éœ€è¦è½¬æ¢æˆ double
                // è¿™é‡Œè½¬æ¢æˆ doubleä¸ä¼šæœ‰ä»€ä¹ˆå½±å“, å› ä¸ºè¿™ä¸¤ä¸ªå‚æ•°åªæ˜¯æœ¬åœ°è°ƒè¯•æ˜¾ç¤ºç”¨çš„.
                elem["docId"] = (double)doc->_docId;
                elem["weight"] = (double)elemOut._weight;

                root.append(elem);
            }

            // åºåˆ—åŒ–å®Œæˆä¹‹åå°†ç›¸å…³å†…å®¹å†™å…¥å­—ç¬¦ä¸²
            // for Debug ç”¨ styledWriter
            Json::StyledWriter writer;
            *jsonString = writer.write(root);
        }

        std::string getDesc(const std::string& content, const std::string& keyword) {
            // å¦‚ä½•è·å–æ‘˜è¦å‘¢?
            // æˆ‘ä»¬å°è¯•è·å–æ­£æ–‡ä¸­ ç¬¬ä¸€ä¸ªkeyword çš„å‰50ä¸ªå­—èŠ‚å’Œå100ä¸ªå­—èŠ‚çš„å†…å®¹ ä½œä¸ºæ‘˜è¦
            const std::size_t prevStep = 50;
            const std::size_t nextStep = 100;
            // è·å–æ­£æ–‡ä¸­ ç¬¬ä¸€ä¸ª keyword çš„ä½ç½®

            // std::size_t pos = content.find(keyword);
            // if (pos == std::string::npos)
            //  return "keyword does not exist!";
            // ç›´æ¥è¿™æ ·å¤„ç†, ä¼šå‡ºç°ä¸€ä¸ªé—®é¢˜:
            // keywordæ˜¯æœ‰å¤§å°å†™çš„. å€’æ’ç´¢å¼•ä¸­æŸ¥æ‰¾ æˆ‘ä»¬å®ç°çš„æ˜¯å¿½ç•¥å¤§å°å†™, æ‰€ä»¥å¯ä»¥æ‰¾åˆ°æ–‡æ¡£
            // è€Œ string::find() æ˜¯åŒºåˆ†å¤§å°å†™çš„æŸ¥æ‰¾, å¯èƒ½æ— æ³•åœ¨å†…å®¹ä¸­æ‰¾åˆ°å¯¹åº”çš„å…³é”®è¯
            // stringå®¹å™¨ä¹Ÿæ²¡æœ‰æä¾›ä¸åŒºåˆ†å¤§å°å†™çš„æŸ¥æ‰¾æ–¹æ³•
            // æ­¤æ—¶, å¯ä»¥ç”¨std::search()
            // std::search(it1, it2, it3, it4, pred);
            // å¯ä»¥åœ¨[it1, it2)ä¸­ æŸ¥æ‰¾ç¬¬ä¸€ä¸ª[it3, it4)(è¯è¯­)çš„å‡ºç°ä½ç½®.
            // å¹¶ä¸”, å¦‚æœä½¿ç”¨ç¬¬5ä¸ªå‚æ•°, å°±å¯ä»¥ä¼ å…¥ å¸¦æœ‰ä¸¤ä¸ªå‚æ•°çš„ä»¿å‡½æ•°, è¿™ä¸¤ä¸ªå‚æ•°å°±æ˜¯éœ€è¦æ¯”è¾ƒçš„å­—ç¬¦
            // å¯ä»¥åœ¨ä»¿å‡½æ•°å†…è®¾ç½®è¿™ä¸¤ä¸ªå­—ç¬¦çš„æ¯”è¾ƒæ–¹å¼
            // æœ€ç»ˆä¼šè¿”å›æ‰¾åˆ°çš„æ‰¾åˆ°çš„å•æ¬¡ç¬¬ä¸€ä¸ªå­—ç¬¦ä½ç½®çš„è¿­ä»£å™¨, å¦åˆ™è¿”å›it2

            auto iter = std::search(content.begin(), content.end(), keyword.begin(), keyword.end(),
                                    [](int x, int y) {
                                        return std::tolower(x) == std::tolower(y);
                                    });
            if (iter == content.end())
                return "keyword does not exist!";
            std::size_t pos = std::distance(content.begin(), iter);

            std::size_t begin = 0;
            std::size_t end = content.size() - 1;

            // è·å–å‰50å­—èŠ‚ å’Œ å100å­—èŠ‚çš„è¿­ä»£å™¨ä½ç½®
            if (pos > begin + prevStep)
                begin += (pos - prevStep);
            if (pos + nextStep < end)
                end = pos + nextStep;

            if (begin >= end)
                return "nothing!";

            // è·å–æ‘˜è¦
            std::string desc;
            if (pos <= begin + prevStep)
                desc = "...";
            desc += content.substr(begin, end - begin);
            if (pos + nextStep < end)
                desc += "...";

            return desc;
        }
    };
}
```

---

æœ¬ç¯‡æ–‡ç« åˆ°æ­¤ç»“æŸ

æ„Ÿè°¢é˜…è¯»~
