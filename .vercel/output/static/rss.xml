<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:version="2.0"><channel><title>💠 Youngestar&apos;s backyard</title><description>Youngestar 的个人博客, 希望是一个静悄悄但有意思的地方🌻</description><link>https://frosti.saroprock.com/</link><language>zh</language><item><title>博客搭建成功</title><link>https://frosti.saroprock.com/blog/about-my-blog/</link><guid isPermaLink="true">https://frosti.saroprock.com/blog/about-my-blog/</guid><description>关于我的博客的小故事和我想说的话</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://frosti.saroprock.com/blog/about-my-blog/&quot;&gt;https://frosti.saroprock.com/blog/about-my-blog/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;博客搭建成功&lt;/h2&gt;
&lt;p&gt;当我写下这篇文章时, 代表我的博客终于要搭建完成了. 在看到不少佬的 so cooool 的博客后, 觉得有博客这件事蛮帅, 于是便临时起意想搞个自己的博客. 现在写着文章, 才发现自己写点东西磕磕绊绊的, 写过的作文都还给老师了, 哈哈.&lt;/p&gt;
&lt;p&gt;开始也是雄性壮志想搞个自己的框架, 后来发现自己是只癞蛤蟆想吃天鹅肉... 后面挑了好久, 选择了大家看到的这个博客框架(看着还是挺不错嘛). 从起意到准备到尝试到实践, 前前后后可能也花了 20 天左右? 途中遇到了不少小问题, 但综合来说还是没有自己预想的那么困难. 希望以后能在博客上多更新一些东西吧(看到我断更了请踢我谢谢). 做博客的过程也见识了不少的新技术, 总体来说还是挺有意思的.&lt;/p&gt;
&lt;p&gt;现在写点感想?&lt;/p&gt;
&lt;p&gt;单从作息和管束来讲, 大学就是爽哈. 每天这这那那, 然后感觉就像哦哦啊啊呃呃噢噢噢哦哦...... 我以前就在想: 如果以后能做什么电什么信息什么实验巴拉巴拉之类的专业和工作一定会很帅和很爽, 但说实话是阴差阳错进入了计算机的领域; 阴差阳错捡起了我手中的笔记本然后估计再也放不开; 阴差阳错发现自己已经走到了这里, 回头一望发现已经走了挺远的路但是还有更远更远的路要走...... 也许电脑和代码是一种挺有趣, 挺时髦, 挺 cool 的玩意? 反正学着好像没有高数那么要我命, 哈哈.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;--&amp;quot;长者有云: 世上有一颗高高的树, 上面挂满了人&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;希望这个博客能见证我的成长, 也希望我能带着这个 blog 尽量地走下去... 在这个 backyard 中, 我尽力地写一些我的技术的 “小巧思” 吧, 如果兴致来了也有可能会记录自己的生活或者写一些呜呜噫噫啊啊的小故事? 谁知道呢.&lt;/p&gt;
&lt;p&gt;希望能收集各位大佬的友链! 希望你们主动联系我, 不要逼我求你们😗. 如果有哪位 bro 或者 sis 想借我的博客发一些东西, 也可以联系我哦.&lt;/p&gt;
&lt;p&gt;可以在留言区里留言! 写一些 想对我 | 想对这个博客 说的话或者提的建议, 也许你也可以通过上面留下的联系方式联系我, 咱们偷偷地唠两句?&lt;/p&gt;
&lt;p&gt;最后再介绍一下这个博客:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hi, I&amp;#39;m Youngestar!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里是我的后院&lt;/p&gt;
&lt;p&gt;是一名前端的开发者和学习者, 目前还是技术小白&lt;/p&gt;
&lt;p&gt;希望能做一个很有趣的人, 希望能一直向前进&lt;/p&gt;
&lt;p&gt;与君共勉✌️&lt;/p&gt;
&lt;p&gt;&lt;em&gt;后记: 自以为整完博客就离成功不远了, 结果部署出了好多好多问题...花了好长好长时间......&lt;/em&gt;&lt;/p&gt;
</content:encoded><dc:creator>youngestar-backyard</dc:creator><pubDate>Wed, 09 Apr 2025 16:00:00 GMT</pubDate></item><item><title>React 文档笔记</title><link>https://frosti.saroprock.com/blog/react-text-note/</link><guid isPermaLink="true">https://frosti.saroprock.com/blog/react-text-note/</guid><description>前段时间阅读 React 官方文档时, 顺手记录了一些个人认为比较重要的知识点作为笔记</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://frosti.saroprock.com/blog/react-text-note/&quot;&gt;https://frosti.saroprock.com/blog/react-text-note/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;React 文档笔记&lt;/h2&gt;
&lt;p&gt;前段时间阅读 React 官方文档时, 顺手记录了一些个人认为比较重要的知识点作为笔记, 都是比较基础的知识&lt;br/&gt;
(如果发现有误, 请联系我)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;style 写法: &lt;code&gt;{{  }}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;tailwind 与 组件库容易冲突, 支持 tailwind 的组件库: heroui(最好使用 next.js 在搭建项目时直接一起搭建)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\export default 默认导出, export 具名导出, 有很多区别, 可以自己思考一下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建议将 props 解构使用并提供默认值(默认值只会对 undefined 生效)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;大量组件渲染, 涉及变动时建议添加 key 进行绑定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列表渲染组件 map 返回 tsx(同样记得加 key) 或者 fliter 返回 过滤后数组 (=&amp;gt; 直接少量数据返回 或者 =&amp;gt; {return ...})&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 及 &lt;code&gt;&amp;lt;/&amp;gt;&lt;/code&gt; 不可添加 key, 此时替换为 &lt;code&gt;&amp;lt;Fragment&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;/ Fragment&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组件不应当更改任何值, 只负责进行渲染&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命名惯例: 按照惯例，通常将事件处理程序命名为 &lt;code&gt;handle&lt;/code&gt;，后接事件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;某些浏览器事件具有与事件相关联的默认行为, 例:点击 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 表单内部的按钮会触发表单提交事件，默认情况下将重新加载整个页面, 应当使用 e.preventDefault() 进行阻止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;e.stopPropagation()&lt;/code&gt; 阻止冒泡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{ }&lt;/code&gt; 内部应当传递事件而非函数调用, 实际上, 传递函数调用的话将在每次渲染时被运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://zh-hans.react.dev/reference/react/useState&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; 最终提供功能: &lt;strong&gt;State 变量&lt;/strong&gt; 用于保存渲染间的数据, &lt;strong&gt;State setter 函数&lt;/strong&gt; 更新变量并触发 React 再次渲染组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hooks 依托于一个稳定的调用顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;react 渲染机制: 初次渲染根组件, 之后渲染 被更新的组件 及 其子组件( 递归过程 ), 在开发环境中，React 会在组件首次挂载后立即重新挂载一次, 以便于发现各种问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;state setter 处理机制: react 将会收集 该事件处理函数 中的所有更新(需要重新渲染组件的操作), 并在该函数执行完毕后 &lt;strong&gt;一次性&lt;/strong&gt; 合并更新并触发重新渲染, 在 react 18 前, 异步函数中的所有更新将被 &lt;strong&gt;立刻执行&lt;/strong&gt; ,但在 react 18 后, 异步函数中的更新同样将被收集并合并更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用函数式更新可以在末尾集中运行时, 每次运行后及时更新 state 的值(但是还是可以被后面的赋值给覆盖)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import { useState } from &amp;#39;react&amp;#39;;

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    &amp;lt;&amp;gt;
      \&amp;lt;h1&amp;gt;{number}\&amp;lt;/h1&amp;gt;
      &amp;lt;button onClick={() =&amp;gt; {
        setNumber(number + 5);
        setNumber(n =&amp;gt; n + 1);
        setNumber(42);
      }}&amp;gt;增加数字\&amp;lt;/button&amp;gt;
    &amp;lt;/&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;更新步骤&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;队列中的值变化&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;初始值&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;渲染时的初始状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setNumber(0 + 5)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;计划更新为 &lt;code&gt;5&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;基于当前值 &lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setNumber(n =&amp;gt; n + 1)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;计划更新为 &lt;code&gt;6&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;基于前一次队列值 &lt;code&gt;5&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setNumber(42)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;覆盖为 &lt;code&gt;42&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;直接赋值，忽略前序计算结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;最终结果&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;&lt;code&gt;42&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最后一次更新覆盖所有前序值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ol start=&quot;19&quot;&gt;
&lt;li&gt;&lt;p&gt;使用展开语法 &lt;code&gt;[...a, b]&lt;/code&gt; 或 &lt;code&gt;{ ...a, b:&amp;#39;b&amp;#39;}&lt;/code&gt; 可以进行数组或对象的快速合并, 在对象中使用 [ ] 可以做到动态命名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;useImmer&lt;/code&gt; 代替 &lt;code&gt;useState&lt;/code&gt; 可以更快和更直接地更新对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;react 中推荐与不推荐使用的数组方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;避免使用 (会改变原始数组)&lt;/th&gt;
&lt;th&gt;推荐使用 (会返回一个新数组） )&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;添加元素&lt;/td&gt;
&lt;td&gt;&lt;code&gt;push&lt;/code&gt;，&lt;code&gt;unshift&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;concat&lt;/code&gt;，&lt;code&gt;[...arr]&lt;/code&gt; 展开语法（&lt;a href=&quot;https://zh-hans.react.dev/learn/updating-arrays-in-state#adding-to-an-array&quot;&gt;例子&lt;/a&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除元素&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pop&lt;/code&gt;，&lt;code&gt;shift&lt;/code&gt;，&lt;code&gt;splice&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;filter&lt;/code&gt;，&lt;code&gt;slice&lt;/code&gt;（&lt;a href=&quot;https://zh-hans.react.dev/learn/updating-arrays-in-state#removing-from-an-array&quot;&gt;例子&lt;/a&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;替换元素&lt;/td&gt;
&lt;td&gt;&lt;code&gt;splice&lt;/code&gt;，&lt;code&gt;arr[i] = ...&lt;/code&gt; 赋值&lt;/td&gt;
&lt;td&gt;&lt;code&gt;map&lt;/code&gt;（&lt;a href=&quot;https://zh-hans.react.dev/learn/updating-arrays-in-state#replacing-items-in-an-array&quot;&gt;例子&lt;/a&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;排序&lt;/td&gt;
&lt;td&gt;&lt;code&gt;reverse&lt;/code&gt;，&lt;code&gt;sort&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;先将数组复制一份（&lt;a href=&quot;https://zh-hans.react.dev/learn/updating-arrays-in-state#making-other-changes-to-an-array&quot;&gt;例子&lt;/a&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;22. 对象并不是 &lt;em&gt;真的&lt;/em&gt; 位于数组“内部”, 可能他们在代码中看起来像是在数组“内部”. 同样 对象并不是真的嵌套, 只是看起来像嵌套&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ol start=&quot;23&quot;&gt;
&lt;li&gt;&lt;p&gt;state 设置原则: &lt;strong&gt;使 state 易于更新而不引入错误&lt;/strong&gt; , 例: 少使用 Boolean 类型的 state, 而将其直接命名为各种状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始 state 命名惯例: 以 &lt;code&gt;initial&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;state 不建议多层嵌套, 建议扁平化处理, 使用 递归 对子元素进行渲染和使用 递归 对子元素进行处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以在组件中间添加 JSX 等内容, 将作为 children 特殊属性传给组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 react 中, **UI 树中 **相同位置的相同组件会被视为同一个组件, state 会被保留下来, 而在一般情况下, 组件被销毁后, state 会被重置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 key 可以很方便地独立组件并重置 state, 想要在这种情况下保留 state 的话, 请使用状态提升&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复杂情况下 useState 的代替: useReducer, reducer 可以整合状态逻辑, 增加代码的可理解性和易维护性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给予初始值: initailTasks, 集中处理函数: tasksReducer, 初始值及后续更改后的值将被封装在 tasks 中, 使用 dispatch 将触发 tasksReducer 函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;function tasksReducer(tasks, action) {
          switch (action.type) {
            case &amp;#39;added&amp;#39;: {
              return ...;
            }
            case &amp;#39;changed&amp;#39;: {
              return ...;
            case &amp;#39;deleted&amp;#39;: {
              return ...;
            }
            default: {
              throw Error(&amp;#39;未知 action: &amp;#39; + action.type);
            }
          }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tasksReducer 函数中集中处理 tasks 变化, 通过 switch 来对应 action 中传递的各种情况并 return 处理后的 tasks(使用 action 中的参数对 tasks 进行修改), 还可以使用 default 进行意外的错误处理&lt;/p&gt;
&lt;p&gt;在对应情况的函数中, 使用 &lt;code&gt;dispatch(action)&lt;/code&gt; 分发 action 触发 tasksReducer 函数, 便会根据 dispatch 中 type 的值使用对应的 switch 进行 tasks 的对应处理&lt;/p&gt;
&lt;ol start=&quot;30&quot;&gt;
&lt;li&gt;&lt;p&gt;使用 context 代替 props 层层透传&lt;/p&gt;
&lt;p&gt;首先, 创建一个 context (一般在新的文件中),&lt;/p&gt;
&lt;p&gt;例: &lt;code&gt;export const LevelContext = createContext(1);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;creatContext()&lt;/code&gt; 中的为初始值, LevelContext 为创建后的 context 名&lt;/p&gt;
&lt;p&gt;然后, 在需要应用的组件(注意: 指最终接收和应用 context 的子组件)中导入 LevelContext ,&lt;/p&gt;
&lt;p&gt;使用 useContext 将它赋值给一个变量以便投入使用,&lt;/p&gt;
&lt;p&gt;例: &lt;code&gt;const level = useContext(LevelContext);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此后, 可以在该组件中使用 level 作为正常变量进行对应的操作&lt;/p&gt;
&lt;p&gt;最后, 在需要进行透传的组件中(上文子组件的父组件)中使用 level 作为 props, 并在定义组件时, 引入 LevelContext 并用其包裹子组件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import { LevelContext } from &amp;#39;./LevelContext.js&amp;#39;;

export default function Section({ level, children }) {
  return (
    &amp;lt;section className=&amp;quot;section&amp;quot;&amp;gt;
     &amp;lt;LevelContext value={level}&amp;gt; //传给子组件的值
        {children}
      &amp;lt;/LevelContext&amp;gt;
    &amp;lt;/section&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此后, context 便会在组件间进行透传(可以传到上文的两种组件中), 并会穿过中间层级的组件&lt;/p&gt;
&lt;ol start=&quot;31&quot;&gt;
&lt;li&gt;&lt;p&gt;ts 中, 可以使用 &lt;code&gt;:React.FC&amp;lt;{}&amp;gt;&lt;/code&gt; 快捷地为传入的 props 中的各项数据进行类型声明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Object.keys(obj)&lt;/code&gt; 方法可以快速地得到 obj 的键名组成的数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;context 及 reducer 函数在多数时候可以使用 store 库进行代替, store 库中的状态更改时也会触发重新渲染&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每次组件触发重新渲染时, 常规变量的值都会被重置, 想要保存变量的值, 应当使用 useState 或者 useRef&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数: useRef&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;const ref = useRef(0);&lt;/code&gt; 创建一个 ref, 括号中为提供的初始值&lt;/p&gt;
&lt;p&gt;然而, ref 返回的是一个对象 &lt;code&gt;{ current: 0  // 你向 useRef 传入的值 }&lt;/code&gt; 在组件中应当使用 ref.current 访问储存的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ref 与 state 异同&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ref&lt;/th&gt;
&lt;th&gt;state&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;useRef(initialValue)&lt;/code&gt;返回 &lt;code&gt;{ current: initialValue }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;useState(initialValue)&lt;/code&gt; 返回 state 变量的当前值和一个 state 设置函数 ( &lt;code&gt;[value, setValue]&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;更改时不会触发重新渲染&lt;/td&gt;
&lt;td&gt;更改时触发重新渲染。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可变 —— 你可以在渲染过程之外修改和更新 &lt;code&gt;current&lt;/code&gt; 的值。&lt;/td&gt;
&lt;td&gt;“不可变” —— 你必须使用 state 设置函数来修改 state 变量，从而排队重新渲染。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;你不应在渲染期间读取（或写入） &lt;code&gt;current&lt;/code&gt; 值。&lt;/td&gt;
&lt;td&gt;你可以随时读取 state。但是，每次渲染都有自己不变的 state &lt;a href=&quot;https://zh-hans.react.dev/learn/state-as-a-snapshot&quot;&gt;快照&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;ref 可以被便利地更改: 不需要使用 set 函数&lt;/p&gt;
&lt;p&gt;ref &lt;strong&gt;不是快照&lt;/strong&gt;, state 则是, 例如在异步操作中, state 被提交后则固定, 而 ref 在操作执行前仍可以更改并将变化反应到结果上, 所以 ref 也常常被用于各种异步操作中&lt;/p&gt;
&lt;p&gt;ref &lt;strong&gt;不会&lt;/strong&gt;触发浏览器的重新渲染, 所以它不应当被使用在与 DOM 相关的变化中, 相反, 在一些频繁触发的操作中, 使用 ref 可以极大地优化性能: 例如: 制作秒表, 制作防抖函数中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;element.scrollIntoView()&lt;/code&gt; 方法将元素滚动到视野中, 可传入参数对象:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;        {
          behavior: &amp;#39;...&amp;#39;,
          block: &amp;#39;...&amp;#39;,
          inline: &amp;#39;...&amp;#39;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;38&quot;&gt;
&lt;li&gt;&lt;p&gt;ref 在很多时候被用来控制 DOM , 处理一些 react 无法处理的 DOM 事件, 常见示例包括管理焦点、滚动位置或调用 React 未暴露的浏览器 API, 但是，如果尝试手动 &lt;strong&gt;修改&lt;/strong&gt; DOM，则可能会与 React 所做的更改发生冲突, &lt;strong&gt;尽量不要这么做&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要实现功能, 首先: &lt;code&gt;const myRef = useRef(null);&lt;/code&gt; 将 ref 设置为null&lt;/p&gt;
&lt;p&gt;之后, 将 DOM 绑定在 JSX 上: &lt;code&gt;&amp;lt;div ref={myRef}&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 DOM 节点被创建时, React 会把对该节点的引用放入 &lt;code&gt;myRef.current&lt;/code&gt; , 然后便可以访问这个 DOM 元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以使用 ref 回调更精确地控制 ref: 即&lt;strong&gt;将函数传递给 &lt;code&gt;ref&lt;/code&gt; 属性&lt;/strong&gt;以控制 ref 在不同情况下的各种状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如同其他 props , ref 也可以被传给子元素, 便可以透过父元素控制子元素状态&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;useImperativeHandle&lt;/code&gt; 控制父元素可以访问的子元素特性的范围&lt;/p&gt;
&lt;p&gt;配置: &lt;code&gt;useImperativeHandle(ref, createHandle, [deps])&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt;：传递给组件的 &lt;code&gt;ref&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;createHandle&lt;/code&gt;：返回一个对象，该对象就是暴露给父组件的实例值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[deps]&lt;/code&gt;：可选参数，是一个依赖数组，当依赖项发生变化时，&lt;code&gt;createHandle&lt;/code&gt; 会重新执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 flushSync 可以使 set state 函数不等待更新队列立刻更新 DOM&lt;/p&gt;
&lt;p&gt;配置: &lt;code&gt;flushSync(callback)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;callback&lt;/code&gt;：一个回调函数，在该函数中进行状态更新操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Effect&lt;/strong&gt; 是 React 范式中的一种脱围机制, 它&lt;strong&gt;允许你指定由渲染自身，而不是特定事件引起的副作用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Effect 在 &lt;a href=&quot;https://zh-hans.react.dev/learn/render-and-commit&quot;&gt;提交&lt;/a&gt; 结束后、页面更新后运行: 此时是将 React 组件与外部系统（如网络或第三方库）同步的最佳时机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Effect 的使用:&lt;/p&gt;
&lt;p&gt;导入 Effect 后 &lt;strong&gt;&lt;code&gt;( import { useEffect } from &amp;#39;react&amp;#39;)&lt;/code&gt;&lt;/strong&gt; , 在组件顶部进行调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;function MyComponent() {
 useEffect(() =&amp;gt; {
    // 每次渲染后都会执行此处的代码

  });

  return &amp;lt;div /&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单来讲, &lt;strong&gt;&lt;code&gt;useEffect&lt;/code&gt; 会“延迟”一段代码的运行，直到渲染结果反映在页面上&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;useEffect 还可以接收第二个参数: 依赖数组,&lt;/p&gt;
&lt;p&gt;当无依赖数组时: 在每次渲染后调用&lt;/p&gt;
&lt;p&gt;当存在依赖数组时, 需要将 Effect 中使用的参数放入其中, 否则会报错&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当依赖数组为空时: 在组件挂载后调用(注意)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用正常的依赖数组时, 依赖数组中的 &lt;strong&gt;任意元素变化&lt;/strong&gt; 将调用 Effect (注意: Effect 为浅比较)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按需添加清理（cleanup）函数: 因为在每次渲染后都会调用 Effect , 所以 Effect 产生的副作用应当被及时进行清理&lt;/p&gt;
&lt;p&gt;可以在 Effect 中返回一个 &lt;strong&gt;清理（cleanup）函数&lt;/strong&gt;, React 会在每次 Effect 重新运行之前调用清理函数，并在组件卸载（被移除）时最后一次调用清理函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content:encoded><dc:creator>youngestar-backyard</dc:creator><pubDate>Wed, 02 Apr 2025 16:00:00 GMT</pubDate></item></channel></rss>